در این فصل به طور اجمالی بر روش‌های پایه‌ای مورد استفاده در این پژوهش تمرکز خواهیم کرد. در هر مورد تلاش شده است تا تنها از منظر کاربرد در این پژوهش به روش‌ها پرداخته شده و اختصار رعایت شود.

\section{مدل بازیگر}
آن‌گونه که در فصل قبل اشاره شد، آزمون مبتنی بر مدل روشی برای تولید خودکار موارد آزمون بر اساس مدل‌های صوری از سیستم تحت آزمون است. در این بخش ابتدا نگاهی گذرا به جایگاه آزمون مبتنی بر مدل در میان روش‌های دیگر \gls*{بازرسی}\LTRfootnote{inspection} کارکرد نرم‌افزار انداخته و سپس به نحوه‌ی کار و پایه‌های نظری ‌\gls*{آی‌او‌کو}\LTRfootnote{ioco} خواهیم پرداخت. در پژوهش حاضر گسترشی از آی‌اوکو برای آزمون سیستم‌های در حضور داده‌ مورد استفاده قرار گرفته است. با توجه به تعدد نمادهای مورد استفاده و پیچیدگی بیان آن‌ها، در این‌جا ابتدا گونه‌ی اولیه‌ی آی‌اوکو را در بخش \ref{subsection:ioco} بررسی می‌کنیم و سپس آن‌را در بخش \ref{subsection:dataioco} به حضور مقادیر داده‌ای نیز تعمیم می‌دهیم.

\subsection{جایگاه آزمون مبتنی بر مدل در میان روش‌های بازرسی کارکرد نرم‌افزار}
روش‌های زیادی برای بازرسی سیستم‌های نرم‌افزاری به هدف اطمینان از کارکرد صحیح آن‌ها ارائه شده است. اگرچه نمی‌توان به طور مشخص در مورد برتری یکی از این روش‌ها به دیگری نظر داد اما می‌‌توان آن‌ها را از نظر شیوه‌ی استفاده طبقه‌بندی نمود. در زیر، یک طبقه‌بندی برای روش‌های آزمون مبتنی بر مدل، با توجه به نوع محصولات مورد استفاده و روش استفاده از آن‌ها، آمده است.

\begin{description}
\item[روش‌های مبتنی بر بررسی مدل:]
 در این روش‌ها مدلی از نرم‌افزار مورد بازرسی تحلیل، و درستی \glspl*{مشخصه}\LTRfootnote{properties}مختلفی از آن تحقیق می‌شود. تمامی این روش‌ها در استفاده از مدلی  که به طور مجزا طراحی شده است، مشترک می‌باشند. روش‌های مختلفی مانند \gls*{بررسی مدل}\LTRfootnote{model checking}\cite{Clarke99MC} و یا اثبات قضیه\LTRfootnote{theorem proving}\cite{Loveland78TP} در این دسته قرار می‌گیرند. مزیت اصلی این روش‌ها حصول اطمینان از درستی خصوصیت مورد بازرسی در مدل سیستم است. دیگر برتری آن‌ها امکان طراحی مدل برنامه به صورت مستقل از پیاده‌سازی و امکان کشف دسته‌ای از خطاها پیش از پیاده‌سازی نهایی برنامه است. علی‌رغم این برتری، در این روش‌ها طراحی مدل‌ها به صورت مجزا ممکن است خود باعث بروز خطاهای جدیدی شود. به علاوه ممکن است برنامه‌ی پیاده‌سازی شده با مدل مورد آزمون قرار گرفته منطبق نباشند. مشکل دیگری که در این روش‌ها باید به آن اشاره کرد هزینه‌ی بالای بازرسی مدل‌ها به دلیل نیاز به ساخت فضاهای حالت به طور کامل و پیمایش آن‌هاست.
\item[روش‌های \gls*{بررسی ایستا}ی متن:]\LTRfootnote{static analysis} در این روش‌ها خصوصیات مورد نظر مستقیماً روی متن پیاده‌سازی شده‌ی برنامه مورد بازرسی قرار می‌گیرند. در این روش‌ها به جای توصیف مدلی مجزا از سیستم، این مدل‌های به طور خودکار از متن برنامه استخراج می‌شود. قابلیت‌های کنونی این روش‌ها چندان زیاد نیست و در موارد بسیاری هنوز در مرحله‌ی پژوهشی قرار دارد. به این ترتیب باید استفاده از این روش‌ها را به عنوان جایگزینی برای تمامی روش‌های دیگر به دیده‌ی تردید نگریست \cite{ayewa08staticanalysis}.
\item[روش‌های مبتنی بر اجرای سیستم:] انواع مختلف آزمون‌ها در این دسته قرار می‌گیرند. این دسته‌ از روش‌ها بر مبنای اجرای برنامه‌ی مورد آزمون با ورودی‌های مشخص و مشاهده‌ی خروجی تولید شده توسط آن در مورد درستی سیستم اظهار نظر می‌کنند. روش‌های مبتنی بر اجرای سیستم می‌توانند از مراحل ابتدایی پیاده‌سازی تا آخرین مراحل نصب و نگه‌داری نرم‌افزار مورد استفاده قرار گیرند. مهم‌ترین اشکال این روش‌ها نیز عدم تضمین درستی خصوصیت مورد بازرسی حتی بعد از موفقیت‌آمیز بودن همه‌ی مراحل آزمون است. 
\end{description}

آزمون مبتنی بر مدل با بهره‌گیری از ایده‌ی مدل‌سازی از روش‌های تحلیل مدل از یک سو و اجرای موارد آزمون تولید شده از سوی دیگر تلاش می‌کند گونه‌ای کارا از آزمون نرم‌افزار را ارائه نماید. آزمون مبتنی بر مدل با استفاده از مدل ارائه شده از رفتار سیستم (که به آن \gls*{توصیف سیستم}\LTRfootnote{system specification} می‌گوییم) و پیمایش فضای حالت، به صورت سیستماتیک موارد آزمونی تولید می‌کند که تمامی حالت‌های مجاز در مدل رفتاری را دربرگیرد. این آزمون‌ها بر روی \gls*{سیستم تحت آزمون}\LTRfootnote{System Under Test (SUT)} (که در ادامه‌ی متن حاضر برای راحتی سیستم نامیده خواهد شد) اجرا می‌شوند. 

\subsection{؟؟}
\label{subsection:ioco}
رابطه مطابقت ورودی و خروجی\LTRfootnote{Input Output Conformance Relation (ioco)}\cite{tret96} (یا آی‌اوکو) رابطه‌ای است که بر روی دو مدل رفتاری تعریف می‌شود و نشان می‌دهد که آیا رفتار یکی بر دیگری منطبق هست، یا خیر. هم‌چنین آی‌اوکو یک الگوریتم برای ساختن موارد آزمون به طور خودکار از روی  توصیف سیستم، مقایسه آن با پیاده‌سازی موجود و اعلام نظر در مورد مطابقت و یا عدم مطابقت این دو ارائه می‌کند.

روش‌های زیادی برای نگارش توصیف سیستم معرفی شده است. برای نمونه می‌توان به نمادگذاری‌های مبتنی بر حالت\LTRfootnote{state based notations}، نمادگذاری‌های مبتنی بر گذار\LTRfootnote{transition based notations}، نمادگذاری‌ها عملکردی\LTRfootnote{operational notations}و نمادگذاری‌های تصادفی\LTRfootnote{stochastic notations} اشاره نمود\cite{utting06}. در این میان آی‌اوکو از نوع خاصی از نمادگذار مبتنی بر مدل به نام \emph{ماشین گذار برچسب‌گذاری‌شده‌ی ورودی و خروجی\LTRfootnote{Input Output Labelled Transition System (IOLTS)}}(که اختصاراً \lr{IOLTS} نیز نامیده می‌شود) استفاده می‌کند که در ادامه توضیح داده خواهد شد. در این بخش تلاش شده تا حد امکان وفاداری به نمادگذاری ترتمانس\LTRfootnote{Tretmans} در \cite{tret96} حفظ شود. با این حال در مواردی که از نمادگذاری دیگری استفاده شده است، تطبیق کامل آن با نمادگذاری \cite{tret96} در پیوست \ref{appendix} انجام شده است.

\subsubsection{ماشین گذار برچسب‌گذاری شده‌ی ورودی و خروجی}

\begin{definition}
\label{definition:IOLTS}
یک \lr{IOLTS} عبارت است از یک پنج‌تایی مرتب $P = \langle S, L_I, L_U, \rightarrow, S_0\rangle$  که در آن
\begin{itemize}
\item $S$ مجموعه‌ای شمارا و غیر تهی از حالت‌ها؛
\item $L_I$ مجموعه‌ای شمارا از برچسب‌های کنش‌های ورودی سیستم؛
\item $L_U$ مجموعه‌ای شمارا از برچسب‌های کنش‌های خروجی سیستم و تعریف می‌کنیم\\* $L = L_I \cup L_U$ و $L_U \cap L_I = \emptyset$؛
\item $\rightarrow \text{ } \subseteq S \times (L \cup \{\tau\}) \times S$ رابطه‌ی گذار را نشان می‌دهد، که در آن برچسب خاص $\tau$ نشان‌گر عملیات داخلی سیستم است که نمود بیرونی ندارد؛
\item $S_0 \subseteq S$ حالت یا حالت‌های شروع را نشان می‌دهد.
\end{itemize}
\end{definition}

\section{طراحی مبتنی بر دامنه}
\label{section:CategoryPartitionMethod}
اگرچه رابطه‌ی معرفی شده از مطابقت ماشین‌های گذار نمادین امکان بازرسی رفتار سیستم به همراه داده را فراهم می‌کند، با این‌حال این روش مشخص نمی‌کند که مقادیر داده‌ای که باید مورد آزمون قرار بگیرند از چه طریقی باید مشخص شوند. 
 
یکی دیگر از جنبه‌های آزمون نرم‌افزار که در کنار روش‌های توصیف رفتار سیستم‌های نرم‌افزاری پیشرفت داده شده است، توصیف نرم‌افزار از حیث دامنه‌ی داده‌های آن است. بر خلاف رابطه‌های مطابقت که از گذار بین حالت‌های مختلف برای توصیف رفتار سیستم استفاده می‌کنند، در این دسته از روش‌ها هر رفتار سیستم معادل با دادن مقداردهی مشخصی به ورودی سیستم در نظر گرفته می‌شود. از آن‌جا که ممکن است مقداردهی‌های مختلفی از مقادیر ورودی رفتار یکسانی تولید کنند، این مقداردهی‌های داده‌ای بر حسب رفتار سیستم در قبال آن‌ها، به مجموعه‌های هم‌ارز \emph{\gls*{افراز}}\LTRfootnote{partition} می‌شود. هر مجموعه‌ی هم‌ارز از مقداردهی‌های ورودی به سیستم، رفتار یکسانی از سیستم را نیز در پی دارد. به دست آوردن مجموعه‌های هم‌ارز داده‌ای در این روش‌ها باید در یک سناریوی رفتاری مشخص (که از قبل شناخته و معرفی شده است) صورت بگیرد و این روش‌ها فقط به تعیین مقادیر ورودی در هر یک از گام‌های چنین سناریوی شناخته شده‌ای می‌پردازند.

برای مشخص شدن مقادیر داده‌ای در این روش‌ها، از روش‌های مختلفی می‌توان استفاده کرد. این روش‌ها بازه‌ای از بررسی توصیف‌های  سطح بالا تا بررسی متن برنامه را پوشش می‌دهد. واضح است که در صورت استفاده از متن پیاده‌سازی شده‌ی برنامه (و یا دانش مستخرج از آن) به عنوان منبع تعریف مقادیر داده‌ای\cite{Gotlieb98atc,Tillman08pex}، آزمون تولید شده در حوزه‌ی آزمون‌های ساختاری (یا به عبارت دیگر جعبه سفید) طبقه‌بندی می‌شود.

یکی از روش‌های ساده و در عین حال کارا برای مدل‌سازی داده‌های نرم‌افزار به هدف آزمون روش \emph{افراز رده‌‌‌ای}\LTRfootnote{category partition} است\cite{ostrand88}. این روش علاوه بر آن‌که راه‌کاری برای تولید مجموعه‌های افراز داده‌های ورودی  ارائه می‌دهد، چهارچوبی برای تولید موارد آزمون نیز بر اساس آن‌ها معرفی می‌کند. 

تولید توصیف‌های سیستم و رده‌های داده‌ای در این روش در چند مرحله انجام می‌شود که در ادامه به طور خلاصه آن‌ها را بررسی می‌کنیم:
\begin{enumerate}
\item اولین مرحله‌ی این روش تحلیل توصیف سیستم و تجزیه‌ی از نظر رفتاری به \textit{\glspl*{واحد کارکردی}}\LTRfootnote{functional unit} است. خصوصیت این واحدها این است که هر یک دارای قابلیت آزمون مجزا هستند. رفتار مورد انتظار از هر یک از این واحدهای کارکردی نیز باید شناسایی و ثبت شود. این رفتار عبارت از توالی ورودی‌هایی است که به سیستم داده خواهد شد و خروجی‌هایی باید در قبال آن‌ها دریافت شود. 

برای هر یک از واحدهای کارکردی شناسایی شده، لازم است مجموعه‌ای از \emph{پارامترها} نیز معرفی شوند که در واقع متغیرهای داد‌ه‌ای هستند که برای آزمون آن واحد کارکردی مورد استفاده قرار می‌گیرند. باید توجه کرد که مقادیر این پارامترها مشخص کننده‌ی رفتار سیستم خواهد بود، بنابراین، انتخاب صحیح ‌آن‌ها اهمیت قابل توجهی در کیفیت نتیجه‌ی آزمون دارد. هر پارامتر توصیف شده را در این روش یک \emph{\gls*{رده}}‌\LTRfootnote{category} می‌نامند.

\textbf{مثال.} یک برنامه‌ی \gls*{مرتب‌سازی}\LTRfootnote{sort} را که یک آرایه از اعداد از کاربر دریافت کرده و آن را به صورت مرتب باز می‌گرداند، در نظر بگیرید. با فرض این‌که طول آرایه‌ی ورودی نیز از کاربر دریافت شود و گونه‌های مختلف داده‌ای امکان مرتب شدن با این تابع را داشته باشند، می‌توان رده‌هایی مانند «طول آرایه‌ی ورودی»، «گونه‌ی داده‌ای» و «جایگاه بزرگترین و کوچکترین عنصر در آرایه‌ی ورودی» را برای آزمون چنین سیستمی معرفی نمود.

هم‌چنین توالی رفتاری آزمون را نیز برای واحد کارکردی معرفی شده در این مثال را می‌توان به صورت زیر بیان نمود:
\begin{center}
\textit{
\begin{supertabular}{r| r}
۱. & طول آرایه به سیستم وارد کن. \\
۱. & آرایه‌ی مقادیر را به سیستم وارد کن.\\
۳. & آرایه‌ی پاسخ را از خروجی سیستم دریافت کن.\\
\end{supertabular}
}
\end{center}

\item هر رده را می‌توان در مرحله‌ی بعدی به تعدادی \emph{\gls*{گزینه}}\LTRfootnote{choice} افراز نمود. هر یک از این گزینه‌ها معادل با یک مقدار داده‌ای مشخص است که با توجه به رفتار سیستم مورد آزمون به گونه‌ای انتخاب شده‌ است که رفتاری خاص از سیستم را مورد مشاهده قرار دهند.

در مثال بالا یک نمونه از مقداردهی ممکن آن است که چهار گزینه از طول آرایه را برابر مقادیر \}۰، ۱، ۲، ۱۰۰\{ قرار داده و چهار افراز به صورت \textit{طول آرایه} = ۰، \textit{طول آرایه} = ۱، ۱۰۰ $\leq$ \textit{طول آرایه} $\leq$ ۲ و \textit{طول آرایه} > ۱۰۰، تشکیل داد. باید توجه کرد که تعیین این مقادیر خاص تنها بر اساس این اطلاع است که احتمال بروز خطا در این سیستم در قبال تغییر در طول آرایه وجود دارد.

در صورتی که اطلاعی از نحوه‌ی پیاده‌سازی کارکرد مورد آزمون وجود داشته باشد می‌توان آن‌را نیز در فرآیند انتخاب گزینه‌ها دخیل نمود. در مثال بالا در صورتی که بدانیم در ساختار حافظه‌ای که برنامه روی آن اجرا می‌شود، آرایه‌ها را در بلوک‌های ۲۵۶تایی ذخیره می‌کند، می‌توان افرازی به شکل  \textit{طول آرایه} < ۲۵۶ ، \textit{طول آرایه} = ۲۵۶ و \textit{طول آرایه} > ۲۵۶ معرفی نمود.

\item با توجه به خصوصیت هر یک از رده‌ها و ارتباط آن‌ها با یکدیگر، در صورت لزوم محدودیت‌های متقابل رده‌ها در این مرحله تعیین می‌شود. این مسئله حائز اهمیت است که با توجه به توصیف سیستم ممکن است همه‌ی ترکیب‌های تمام گزینه‌ها، به عنوان ورودی مجاز محسوب نشوند. در این صورت از تعریف محدودیت بین رده‌های برای حذف حالت‌های نامطلوب استفاده می‌شود.
\end{enumerate}

بعد از طی این مراحل و تکمیل اطلاعات در مورد مقادیر داده‌ای، در نهایت موارد آزمون نهایی با جایگزینی گزینه‌های انتخاب شده از رده‌های مختلف و اجرای رفتار مشخص شده‌ی آزمون برای هر واحد کارکردی، تولید می‌شود.

\subsubsection{؟}
اگرچه روش افراز داده‌ای راه‌حلی سطح بالا برای رده‌بندی داده‌های آزمون به دست می‌دهد، در این روش تمامی گزینه‌های انتخاب شده باید در یک سطح بیان شوند و امکان طبقه‌بندی داده‌ای در آن وجود ندارد (به این معنی که نمی‌توان یک رده‌ی انتخاب شده را به رده‌های کوچکتری شکست). گسترشی از روش افراز داده‌ای به نام \emph{\gls*{درخت‌ طبقه‌بندی}}\LTRfootnote{classification tree} این امکان را فراهم می‌کند که هر کدام از گزینه‌های یک رده، خود مجدداً به تعدادی گزینه‌ی دیگر افراز شود \cite{Grochtmann93ct}. تکرار این کار منجر به ایجاد یک درخت از مقادیر داده‌ای می‌شود. نهایتاً در این روش، مقدار‌دهی که برای آزمون مورد استفاده قرار می‌گیرد، از انتخاب مقادیر داده‌ای برگ‌های این درخت انتخاب می‌شود.

\textbf{مثال.} یک سیستم بینایی ماشین ساده را فرض کنید که کار شناسایی اشکال هندسی را بر عهده دارد. برای آزمون این سیستم یک رده‌بندی نمونه عبارت خواهد بود از \textit{اندازه، رنگ و شکل} اجسامی که برای آزمون مورد استفاده قرار می‌گیرند. از طرفی گزینه‌ی اشکال مثلثی را می‌توان به سه گزینه‌ی \textit{مثلث‌های متساوی‌الاضلاع، متساوی‌الساقین و مختلف‌الاضلاع} شکست. به این ترتیب درختی مشابه شکل \ref{fig:ctSample} به دست می‌آید.
