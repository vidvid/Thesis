\section{مقدمه}
\label{sectio:design:preface}
در این فصل از پژوهش، یک سیستم نرم‌افزاری نمونه معرفی شده و با استفاده از رویکرد تبادل ناهمگام پیغام طراحی می‌گردد. کلیه‌ی نکات مطرح شده در ادامه‌ی این بخش در قالب این مثال ارائه شده است و در فصل‌های بعد پژوهش نیز، از این سیستم به عنوان مرجع استفاده شده است.
در انتخاب سیستم نمونه نکات ذیل مورد توجه قرار گرفته‌ است:
\begin{enumerate}
\item \textbf{دامنه‌ی سیستم انتخابی:}
رده‌ی دامنه‌ی سیستم انتخاب شده به طور کلی سیستم‌های اطلاعاتی\LTRfootnote{Information System} است. اولین دلیل انتخاب این رده این است که در این نوع دامنه همروندی به طور ذاتی وجود ندارد و به همین دلیل زمینه‌ی مقایسه‌ی طراحی بر اساس تبادل ناهمگام با  طراحی‌های شیءگرای ترتیبی فراهم می‌شود. با توجه به اینکه یکی از موارد مقایسه‌ی این نوع طراحی با طراحی شیءگرای ترتیبی تفاوت کارایی این دو رویکرد است، دامنه‌ی انتخاب شده باید در حالت ترتیبی هم قابلیت اضافه شدن همروندی را داشته باشد. سیستم‌های اطلاعاتی از این حیث نیز انتخاب مناسبی محسوب می‌شوند چرا که در اکثر پیاده‌سازی‌های عملیاتی، علیرغم داشتن طراحی ترتیبی، به وسیله‌ی ریسمان‌هایی که وب‌سرورها برای پاسخگویی به درخواست‌های همزمان کاربران ایجاد می‌کنند، خاصیت همروندی نیز به آنها اضافه می‌گردد. به همین دلیل در بخش ارزیابی می‌توانیم با شبیه‌سازی عملیات وب‌سرورها، کارایی و نیز تغییرپذیری دو نوع طراحی مذکور را ارزیابی و مقایسه کنیم.
 دلیل دیگر این انتخاب بالا بودن میزان آشنایی جامعه‌ی طراحی شیءگرا با این نوع سیستم‌ها و استفاده‌ی گسترده از این نوع سیستم‌ها می‌باشد. شایان ذکر است که سعی شده است در ارائه‌ی الگوها و نکات استخراج شده از این طراحی بر دامنه‌ی انتخاب شده تکیه‌ نشود. با توجه به آشنایی دانشجویان و اساتید با سیستم آموزش دانشگاه، سیستم‌های اتوماسیون آموزش به عنوان دامنه‌ی سیستم نمونه انتخاب شده است. 
\item \textbf{ بزرگی منطق دامنه:}
از نظر میزان بزرگی سیستم (تعداد کلاس‌ها و موارد کاربرد\LTRfootnote{use cases})،‌  سعی شده است تا منطق دامنه، حداقل بزرگی و پیچیدگی لازم را داشته باشد تا ضمن امکان مشاهده‌ی الگوهای مختلف، نیازی به تکرار نکات طراحی برای مولفه‌های متعدد و مشابه نباشد. 
\end{enumerate} 

\section{معرفی یک سیستم آموزش ساده }
\label{section:eduIntro}
با توجه به توضیحات بخش \ref{sectio:design:preface}،‌ یک سیستم آموزش ساده به عنوان گزینه‌ی طراحی انتخاب شده است. در ادامه‌ی این بخش ابتدا موارد کاربرد انتخاب شده در این سیستم را توصیف می‌کنیم و سپس با توجه به‌ آنها مدل دامنه\LTRfootnote{Domain Model} سیستم را در قالب نمودار کلاس نمایش می‌دهیم.

\subsection{موارد کاربرد}
در این بخش موارد کاربرد انتخاب شده برای سیستم آموزش معرفی می‌شوند. لازم به تأکید است که علیرغم این که این موارد کاربرد، مرتبط و هماهنگ با موارد کاربرد یک سیستم آموزش واقعی هستند، به هیچ عنوان تمام موارد کاربرد مورد نیاز برای ساختن سیستم واقعی را شامل نمی‌شوند و علاوه‌ بر آن، موارد انتخاب شده دارای جزئیات و دقت کافی برای پوشش فرایند‌های واقعی نیستند. در ادامه‌ی این بخش، هر \gls{مورد کاربرد} در قالب یک جدول توصیفی ارائه شده‌ است.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  GPA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}
\begin{center}
\begin{tabular}{|p{5cm}|p{10cm}|}
	\hline
	\textbf{نام مورد کاربرد} &
درخواست محاسبه‌ی معدل ترم دانشجو\\
	\hline
	\textbf{بازیگر(ان)} &
کاربر\\
	\hline
	\textbf{شروع می‌شود زمانی که} &
درخواست محاسبه‌ی معدل ترم وارد سیستم می‌شود.\\
	\hline
	\textbf{پیش‌شرط‌ها} &
دانشجو و ترم در سیستم تعریف شده باشند.\\
	\hline
	\textbf{جریان اصلی} &
۱. درخواست محاسبه‌ی معدل دانشجو در ترم مربوطه وارد سیستم می‌شود.\newline
۲. سیستم سوابق تحصیلی دانشجو در ترم مربوطه را بررسی ‌می‌کند. معدل ترم با توجه به نمرات اخذ شده و تعداد واحد هر درس محاسبه و اعلام می‌شود. در صورتی که نمره‌ی درس سابقه‌ای وارد نشده باشد، درس مربوطه در محاسبه‌ی معدل لحاظ نمی‌گردد.\\
	\hline
\textbf{جریان استثنا ۱} &
۲.الف) در صورتی که دانشجو هیچ واحدی در ترم جاری اخذ نکرده باشد پیغام خطای مناسب صادر می‌شود و جریان اصلی خاتمه می‌یابد.\\
	\hline
%	\textbf{جریان استثنا ۲} &
%۴-ج. رمز وارد شده نامعتبر است، پیام خطای رمز نامعتبر است به کاربر نمایش داده شده و تراکنش متوقف می‌شود\\
%	\hline
	\textbf{تمام می‌شود زمانی که} &
معدل دانشجو اعلام می‌شود یا خطای مناسب صادر می‌گردد.\\
	\hline
%	\textbf{پس شرط‌ها} &
%کاربر موجودی کارت و یا خطای تراکنش را مشاهده کرده است.\\
%	\hline
\end{tabular}
\caption{\label{table:uc_gpa} توصیف مورد کاربرد محاسبه‌ی معدل یک دانشجو در یک ترم}
\end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  Take Course
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}
\begin{center}
\begin{tabular}{|p{4cm}|p{12cm}|}
	\hline
	\textbf{نام مورد کاربرد} &
درخواست اخذ یک ارائه در یک ترم\\
	\hline
	\textbf{بازیگر(ان)} &
کاربر\\
	\hline
	\textbf{شروع می‌شود زمانی که} &
درخواست اخذ ارائه وارد سیستم می‌شود.\\
	\hline
	\textbf{پیش‌شرط‌ها} &
۱. ‌انتخاب واحد در ترم امکان‌پذیر باشد. (رجوع کنید به جدول \ref{table:uc_disableofferings})\\
	\hline
	\textbf{جریان اصلی} &
۱. سیستم کنترل می‌کند که دانشجو در ترم‌های قبل این درس را نگذرانده باشد.\newline
۲. سیستم کنترل می‌کند که دانشجو در ترم‌ جاری این درس را اخذ نکرده باشد.\newline
۳. سیستم کنترل می‌کند که دانشجو تمام پیش‌نیاز‌های این درس را با موفقیت گذرانده باشد.\newline
۴. سیستم یک سابقه از ارائه‌ی انتخاب شده برای دانشجو تشکیل می‌دهد و آن را در سوابق دانشجو ثبت می‌کند.\\
	\hline
\textbf{جریان استثنا ۱} &
۱.الف)در صورتی که دانشجو قبلا این درس را گذرانده باشد، خطای ''درس انتخاب شده قبلاً گذرانده شده است`` صادر می‌شود و جریان اصلی خاتمه می‌یابد.\\
	\hline
\textbf{جریان استثنا ۲} &
۲.الف)در صورتی که دانشجو در ترم جاری این درس را اخذ کرده باشد، خطای ''این درس در ترم جاری قبلاً اخذ شده است`` صادر می‌شود و جریان اصلی خاتمه می‌یابد.\\
	\hline
\textbf{جریان استثنا ۳} &
۳.الف)در صورتی که دانشجو یکی از پیش‌نیاز‌های درس‌ را نگذرانده باشد، خطای ''پیش‌نیازهای درس گذرانده نشده‌اند`` صادر می‌شود و جریان اصلی خاتمه می‌یابد.\\
	\hline
	\textbf{تمام می‌شود زمانی که} &
سابقه‌ی جدید در سوابق دانشجو ثبت می‌شود و یا خطای مناسب صادر می‌گردد.\\
	\hline
\end{tabular}
\caption{\label{table:uc_takecoure} توصیف مورد کاربرد اخذ یک ارائه توسط یک دانشجو در یک ترم}
\end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  DISABLE_TERM_OFFERINGS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}
\begin{center}
\begin{tabular}{|p{5cm}|p{10cm}|}
	\hline
	\textbf{نام مورد کاربرد} &
درخواست غیر فعال کردن ارائه‌های یک ترم برای انتخاب واحد\\
	\hline
	\textbf{بازیگر(ان)} &
کاربر(مدیر سیستم)\\
	\hline
	\textbf{شروع می‌شود زمانی که} &
درخواست غیرفعال کردن ارائه‌های یک ترم وارد سیستم می‌شود.\\
	\hline
	\textbf{پیش‌شرط‌ها} &
 ترم در سیستم تعریف شده باشند.\\
	\hline
	\textbf{جریان اصلی} &
۱. درخواست غیر فعال کردن ارائه‌های یک ترم وارد سیستم می‌شود.\newline
۲.سیستم تمام ارائه‌های یک ترم را غیرفعال می‌کند.\\
	\hline
	\textbf{تمام می‌شود زمانی که} &
تمام ارائه‌های ترم برای انتخاب واحد غیرفعال می‌شوند.\\
	\hline
	\textbf{پس شرط‌ها} &
انتخاب واحد در ترم امکان پذیر نیست.\\
	\hline
\end{tabular}
\caption{\label{table:uc_disableofferings} توصیف مورد کاربرد غیرفعال کردن ارائه‌های یک ترم برای انتخاب واحد}
\end{center}
\end{table}


\subsection{اشیاء دامنه}
\label{subsec:mainEntities}
 موجودیت‌های اصلی  مدل ابتدایی این سیستم عبارتند از:
\textbf{\textit{دانشجو}}\LTRfootnote{Student}، \textbf{\textit{درس}}\LTRfootnote{Course}، \textbf{\textit{ترم}}\LTRfootnote{Term}، \textbf{\textit{ارائه}}\LTRfootnote{Offering} و \textbf{\textit{سابقه}}\LTRfootnote{Study Record}.\\
در هر \textit{ترم} تحصیلی، تعدادی \textit{ارائه} از دروس مختلف وجود دارد. هر درس می‌تواند \textit{ارائه}های مختلفی داشته باشد. به عنوان مثال درس ریاضی۱ می‌تواند در ترم ۹۰-۹۱-۱ سه ارائه‌ی مختلف داشته باشد. دانشجو با اخذ هر ارائه \textit{سابقه}‌ای از آن ارائه را به اسم خود ثبت می‌کند. در این سابقه اطلاعاتی مثل نمره‌ی دانشجو و وضعیت قبول یا مردودی درس در طول ترم ثبت خواهد شد. دروس می‌توانند رابطه‌ی پیش‌نیازی\LTRfootnote{prerequisite} باهم داشته باشند. 
\begin{figure*}
    \begin{center}
	\includegraphics[width=12cm]{4-ProposedFramework/Figures/SimpleClassDiagram.pdf}
    \end{center}
    \caption{\label{fig:edu_class1} نمودار کلاس مدل ابتدایی سیستم آموزش ساده }
\end{figure*}
شکل \ref{fig:edu_class1} مدل دامنه‌ی سیستم را به وسیله‌ی یک نمودار کلاس مبتنی بر \textbf{یو‌ام‌ال}\LTRfootnote{UML} نشان می‌دهد.

\newpage
\section{طراحی سیستم آموزش به روش تبادل ناهمگام پیغام}
در این بخش طراحی سیستم معرفی شده در بخش \ref{section:eduIntro} به روش تبادل ناهمگام پیغام ارائه می‌گردد. سعی شده است تا به جای ارائه‌ی یکباره‌ی طراحی نهایی، یک رویکرد \gls{افزایشی}\LTRfootnote{incremental} برای طراحی اتخاذ شود. در این رویکرد مراحل تشکیل نهایی طرح و حتی اقدامات اشتباهی که در طول طراحی برداشته شده است ارائه خواهد شد. به  این ترتیب علاوه بر قابل استفاده‌تر بودن پژوهش به صورت یک دستورالعمل \LTRfootnote{recipe} طراحی، قابلیت فهم روش طراحی هم بالاتر می‌رود.
\subsection{طراحی اکتور‌های مدل دامنه}
اکتورهای اصلی سیستم همان اشیاء مدل دامنه هستند که در بخش \ref{subsec:mainEntities} معرفی شدند. البته احتمالاً علاوه بر این اکتورها، اکتورهای دیگری نیز برای پیاده‌سازی کارکردهای سیستم، در ادامه‌ی روند طراحی استفاده خواهند شد. در طراحی اکتورهای اصلی، صرفا فیلد‌های داده‌ای اکتور و نیز پیغام‌های اصلی که از روابط موجود در نمودار کلاس \ref{fig:edu_class1} قابل استخراج هستند در نظر گرفته ‌می‌شود. منطق پیاده‌سازی عملیات هر پیغام و  پیغام‌های دیگری که به این منظور ایجاد می‌شوند در ادامه به طراحی افزوده خواهد شد. 
با توجه به اینکه در مدل اکتور،‌ تنها راه ارتباط بین اکتور‌ها استفاده از تبادل پیغام است و این که یک اکتور برای امکان ارسال پیغام به اکتور دیگر نیاز به دسترسی به اسم آن دارد، بهترین راه برای طراحی رابطه‌های وابستگی\LTRfootnote{association} این است که در کلاس یک اکتور برای هر کلاس دیگر که رابطه‌ای با آن وجود دارد یک فیلد از نوع کلاس طرف دیگر در نظر گرفته شود. این مورد مشابه طراحی شیءگرای عادی (ترتیبی) است. از طرف دیگر در مدل طراحی شیءگرای ترتیبی برای هر کارکرد اصلی یک شیء نیز یک متد در کلاس متناظر با آن در نظر گرفته می‌شود که برای اجرای کارکرد، متد مورد نظر فراخوانی می‌شود. با توجه به اینکه در مدل اکتور مکانیزم کنترلی برنامه به جای فراخوانی متد، تبادل پیغام است، باید به ازای هر متد متناظر در حالت شیءگرا، یک پیغام دریافت شود. البته در این مرحله از طراحی منطق پیاده‌سازی کارکرد هر پیغام در نظر گرفته نشده است و در مراحل بعدی به تدریج اضافه خواهد شد.
\begin{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%										Student												%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item\textbf{اکتور دانشجو:}
این اکتور دارای فیلد‌های نام و شناسه است. به علت ارتباط دانشجو با سابقه‌ها و نیاز  به ارسال پیغام به آنها یک فیلد از نوع لیست سابقه نیز در کلاس دانشجو وجود دارد. قطعه کد \ref{fig:mainActors:student} طرح ابتدایی کلاس اکتور دانشجو را نشان می‌دهد. همان‌طور که در بخش قبل ذکر شد منطق پیاده‌سازی کارکرد پیغام‌ها در این مرحله اضافه نشده و در ادامه‌ی فصل به تدریج تکمیل خواهد شد. پیغام‌هایی که اکتور دانشجو دریافت می‌کند عبارتند از:
\begin{enumerate}
%\item\textbf{:\lr{HasPassed(course)}}
%با دریافت این پیغام اکتور دانشجو باید پاسخ بدهد که آیا درس مربوطه را گذرانده است یا خیر.
%\item\textbf{:\lr{HasTaken(course)}}
%با دریافت این پیغام دانشجو باید پاسخ دهد که در ترم جاری این درس را اخذ کرده است یا خیر.
\item\textbf{:\lr{GPARequest(term)}}
با دریافت این پیغام دانشجو باید پاسخ دهد که معدل دانشجو در ترم جاری  چند بوده است.
\item\textbf{:\lr{TakeCourse(offering)}}
با دریافت این پیغام دانشجو باید درس ارائه‌ی مربوطه را اخذ کند. طبیعتاً تمام شرایط ذکر شده در مورد کاربرد \ref{table:uc_takecoure} باید بررسی شود.
\end{enumerate}
طبیعتاً این موارد تنها شامل پیغام‌هایی است که مستقیماً از موارد کاربرد قابل استخراج هستند. در هنگام طراحی کارکردهای موارد کاربرد، در صورت لزوم پیغام‌های جدیدی به این کلاس اضافه خواهد شد.
\codelisting[language=scala]{4-ProposedFramework/src/mainActors/Student.scala}{ساختار کلاس اکتور دانشجو}{fig:mainActors:student}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%										StudyRecord										%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item\textbf{اکتور سابقه:}
مطابق مدل دامنه‌ که در شکل \ref{fig:edu_class1} ارائه شده است، تنها فیلد داده‌ای این اکتور، نمره است. به علت ارتباط سابقه با اکتور ارائه، یک فیلد از نوع ارائه نیز در کلاس سابقه وجود دارد. قطعه کد \ref{fig:mainActors:studyrecord} طرح ابتدایی کلاس اکتور سابقه را نشان می‌دهد. همان‌طور که در بخش قبل ذکر شد منطق پیاده‌سازی کارکرد پیغام‌ها در این مرحله اضافه نشده و در ادامه‌ی فصل به تدریج تکمیل خواهد شد. در این مرحله، پیغامی که مستقیماً از موارد کاربرد قابل استخراج باشد وجود ندارد
و در هنگام طراحی کارکردهای موارد کاربرد، در صورت لزوم پیغام‌های جدیدی به این کلاس اضافه خواهد شد.
\codelisting[language=scala]{4-ProposedFramework/src/mainActors/StudyRecord.scala}{ساختار کلاس اکتور سابقه}{fig:mainActors:studyrecord}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%										Offering										%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item\textbf{اکتور ارائه:}
مطابق مدل دامنه‌ که در شکل \ref{fig:edu_class1} ارائه شده است، فیلدهای داده‌ای این اکتور عبارتند از شناسه و تاریخ امتحان\LTRfootnote{examDate}. به علت ارتباط ارائه با اکتور‌های درس و ترم، یک فیلد از نوع درس و یک فیلد از نوع ترم نیز در کلاس ارائه وجود دارد. قطعه کد \ref{fig:mainActors:offering} طرح ابتدایی کلاس اکتور ارائه را نشان می‌دهد. در این مرحله، پیغامی که مستقیماً از موارد کاربرد قابل استخراج باشد وجود ندارد
و در هنگام طراحی کارکردهای موارد کاربرد، در صورت لزوم پیغام‌های جدیدی به این کلاس اضافه خواهد شد.
\codelisting[language=scala]{4-ProposedFramework/src/mainActors/Offering.scala}{ساختار کلاس اکتور ارائه}{fig:mainActors:offering}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%										Course										%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item\textbf{اکتور درس:}
مطابق مدل دامنه‌ که در شکل \ref{fig:edu_class1} ارائه شده است، فیلدهای داده‌ای این اکتور عبارتند از شناسه، نام و تعداد واحد. تنها ارتباط این کلاس که نیاز به ایجاد فیلد دارد ارتباط دروس پیش‌نیاز است. بنابراین یک فیلد از نوع لیست درس نیز به این منظور باید به کلاس اضافه شود. قطعه کد \ref{fig:mainActors:course} طرح ابتدایی کلاس اکتور درس را نشان می‌دهد. در این مرحله، پیغامی که مستقیماً از موارد کاربرد قابل استخراج باشد وجود ندارد
و در هنگام طراحی کارکردهای موارد کاربرد، در صورت لزوم پیغام‌های جدیدی به این کلاس اضافه خواهد شد.
\codelisting[language=scala]{4-ProposedFramework/src/mainActors/Course.scala}{ساختار کلاس اکتور درس}{fig:mainActors:course}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%										Term										%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item\textbf{اکتور ترم:}
مطابق مدل دامنه‌ که در شکل \ref{fig:edu_class1} ارائه شده است، فیلدهای داده‌ای این اکتور عبارتند از نام و تاریخ شروع {startDate}. با توجه به موارد کاربرد مطرح شده، اکتور ترم آغاز کننده‌ی هیچ ارتباطی نیست و به همین دلیل نیازی به داشتن فیلدی برای این منظور نیست. اکتور ترم قطعه کد \ref{fig:mainActors:term} طرح ابتدایی کلاس اکتور ترم را نشان می‌دهد. در این مرحله، پیغامی که مستقیماً از موارد کاربرد قابل استخراج باشد وجود ندارد
و در هنگام طراحی کارکردهای موارد کاربرد، در صورت لزوم پیغام‌های جدیدی به این کلاس اضافه خواهد شد.
\codelisting[language=scala]{4-ProposedFramework/src/mainActors/Term.scala}{ساختار کلاس اکتور ترم}{fig:mainActors:term}
\end{enumerate}
\newpage
\subsection{مورد کاربرد محاسبه‌ی معدل}
این مورد کاربرد در جدول \ref{table:uc_gpa} توصیف شده است. 
\subsubsection{رویکرد اول}
\label{gpa_approach1}
برای محاسبه‌ی معدل ترم یک دانشجو نیاز داریم نمره‌ی تمام درس‌های دانشجو در ترم به همراه تعداد واحد‌های آن درس‌ها را در اختیار داشته باشیم. درخواست معدل برای ترم از طرف دانشجو صورت می‌گیرد بنابراین شروع پیغام‌ها از این اکتور آغاز می‌شود.
 اکتور دانشجو به هر کدام از اکتور‌های سابقه\LTRfootnote{StudyRecord} یک پیغام می‌فرستد و به وسیله‌ی آن اعلام می‌کند نمره و تعداد واحد‌های درس مربوط به سابقه در پاسخ ارسال شود. علاوه بر این، در پاسخ باید مشخص شود که آیا سابقه‌ مربوط به همان ترم است که معدل برای آن درخواست شده یا خیر. بنابراین پیغام‌های  درخواست نمره برای معدل و پاسخ آن به صورت زیر خواهند بود:
\begin{latin}
 \begin{description}
 \item[\lr{request: GPAInfoRequest( term: Term)}]
  \item[\lr{response: GPAInfoResponse(isForTerm:Boolean, grade: Double, units:Int)}]
 \end{description}
 \end{latin}
  اکتور سابقه امکان اینکه بدون برقراری ارتباط با اکتور ارائه\LTRfootnote{Offering} جواب این پیغام را بدهد، ندارد. دلیل این امر این است که اولا سابقه‌ لزوما مربوط به ترمی نیست که معدل برای آن درخواست شده است، ثانیا سابقه اطلاعی از تعداد واحد‌های درس مربوطه ندارد. به همین دلیل، سابقه باید برای جمع‌آوری این اطلاعات با اکتورهای دیگر تبادل پیغام انجام دهد. از طرف دیگر تنها اکتوری که به نمره‌ی دانشجو دسترسی ادارد، اکتور سابقه است. در نتیجه فرستادن پاسخ به درخواست دانشجو نیاز به همکاری ۳ اکتور سابقه، درس و ترم دارد. با توجه به اینکه دسترسی سابقه به اکتورهای درس و ترم از طریق اکتور ارائه ممکن می‌شود، این اکتور نیز در تبادل پیغام‌ها مشارکت خواهد داشت.\\
با توجه به موارد ذکر شده، اکتور سابقه دو راهکار پیش رو دارد:
\begin{enumerate}
\item اکتور سابقه به وسیله‌ی درخواست‌هایی، تعیین کند که ترم مربوط به این سابقه همان ترم مورد درخواست در معدل است یا خیر، و نیز تعداد واحد‌های درس چند است. و  در ادامه با ترکیب این اطلاعات با نمره‌ی سابقه، خود پاسخ اکتور دانشجو را ارسال کند.
\item اکتور سابقه نمره را در پاسخ قرار دهد ولی با توجه به اینکه پاسخ هنوز کامل نیست (هنوز معلوم نیست که درس چند واحدی است و آیا مربوط به ترم درخواستی است یا خیر)، به جای اینکه پاسخ را برای دانشجو پس بفرستد، آن را برای تکمیل به اکتور ارائه منتقل کند.
\end{enumerate} 
در این رویکرد فرض بر انتخاب اول است، یعنی اینکه خود اکتور سابقه، با گرفتن اطلاعات مورد نیاز از ارائه، پاسخ دانشجو را ارسال می‌کند.\\
برای این کار اکتور سابقه پیغام GPAInfoRequest را برای اکتور ارائه ارسال می‌کند و منتظر دریافت پاسخ می‌ماند. اکتور ارائه با دریافت GPAInfoRequest دو پیغام به صورت زیر به ترتیب برای اکتور ترم و اکتور درس ارسال می‌کند و منتظر پاسخ آنها می‌ماند:
\begin{latin}
 \begin{description}
 \item[\lr{IsYourTermRequest(term: Term)}]
  \item[\lr{NumOfUnitsRequest}]
 \end{description}
 \end{latin}
هدف از درخواست اول این است که مشخص شود که  درسی که سابقه به آن متعلق است، متعلق به همان ترمی است که معدل برای‌ آن درخواست شده یا خیر (اگر جواب خیر باشد نمره‌ی درس در معدل در نظر گرفته نخواهد شد). پیغام دوم هم تعداد واحد‌های درس را از اکتور درس درخواست می‌کند. ترم و درس به سادگی به این دو پیغام پاسخ می‌دهند و ارائه با گرفتن پاسخ‌ها، اطلاعات آنها را تجمیع\footnote{منظور از تجمیع در اینجا این است که  پاسخ فرضی true برای پیغام \lr{IsYourTermRequest(term)} و پاسخ فرضی 3 برای پیغام \lr{NumOfUnitsRequest} را که به ترتیب از اکتورهای ترم و درس گرفته شده، به صورت پیغام \lr{GPAInfoResponse(isForTerm=true,grade=null,unit=3)} باهم ترکیب می‌کند.} کرده و برای اکتور سابقه ارسال می‌کند.  سابقه با دریافت این پیغام، به تمام اطلاعات لازم برای این که پاسخ اکتور دانشجو را بدهد، دسترسی دارد. بنابراین می‌تواند با اضافه کردن مقدار فیلد نمره‌ی خود به پیغام آن را برای دانشجو ارسال کند. دانشجو با گرفتن این پاسخ، یکی از نمره‌های لازم برای محاسبه‌ی معدل را در دست دارد. بقیه‌ی نمره‌ها از تکرار همین عملیات برای تمام اکتورهای سابقه‌ی مربوط به دانشجو به طور مشابه به دست می‌آیند. در نهایت اکتور دانشجو با جمع نمراتی که مربوط به ترم درخواستی بوده‌اند (که از مقدار فیلد isForTerm از پیغام‌های پاسخ قابل تشخیص است) و تقسیم آن بر جمع واحد‌های مربوط به ترم (فیلد units پیغام پاسخ) معدل را محاسبه کرده و برای اکتوری که درخواست معدل داده ارسال می‌کند.
   شکل \ref{fig:gpa1_sequence} نمودار ترتیب\LTRfootnote{sequence diagram} برای پیغام‌های مبادله شده در این رویکرد را در قالب یک مثال نشان می‌دهد. در بخشی از این مثال که در شکل قابل مشاهده است فرض شده ترم مربوط به درخواست معدل باشد و تعداد واحد‌های درس ۳ باشد. نمره‌ی سابقه‌ای که درخواست برای آن ارسال شده ۱۲ است. در نهایت پس از تکرار حلقه‌ی مشخص شده در شکل و ارسال پیغام‌‌ها به تمام سابقه‌ها عدد فرضی ۱۵/۲۵ به عنوان معدل محاسبه شده و به صورت پیغام ارسال شده است. لازم به ذکر است که در این شکل برای سادگی نمایش فرض شده که تکرارهای حلقه برای سابقه‌های مختلف انجام شده است و طبیعتا استاندارد یو‌ام‌ال برای آن به طور کامل رعایت نشده است.

\begin{figure*}
    \begin{center}
	\includegraphics[width=16cm]{4-ProposedFramework/Figures/gpa_1_sequence.pdf}
    \end{center}
    \caption{\label{fig:gpa1_sequence} نمودار ترتیب برای رویکرد اول محاسبه‌ی معدل }
\end{figure*}
\FloatBarrier
در این بخش از طراحی لازم است به دو پرسش مهم پاسخ دهیم:\\
پرسش اول این است که در هر کدام از قسمت‌های طراحی که یک اکتور پیغام را فرستاده و منتظر جواب می‌ماند، آیا اکتور می‌تواند در طول مدت انتظار به فعالیت‌های دیگر بپردازد؟ به عبارت بهتر، \textbf{آیا ارسال پیغام‌ها به صورت همگام است یا ناهمگام؟}\\
پرسش دوم این است که در صورتی که ارسال پیغام ناهمگام باشد ادامه‌ی فعالیت اکتور به چه صورتی مجاز است؟ آیا می‌تواند پیغام‌های جدیدی دریافت کند و به اجرای منطق مربوط به آنها بپردازد؟\\
برای پاسخ به این پرسش‌ها در رویکرد اول، در هر مورد که پیغامی دریافت و فرستاده می‌شود این پرسش‌ها را بررسی می‌کنیم:
\begin{enumerate}
\item اکتور دانشجو:\\
تنها پیغامی که اکتور دانشجو تا این مرحله از طراحی ارسال می‌کند پیغام GPAInfoRequest است. ابتدا منطق پیاده‌سازی شده در این تبادل این پیغام را بررسی ‌می‌کنیم:\\
 شبه کد \ref{fig:usecases:gpa:1:student_sync} تبادل پیغام‌های دانشجو با اکتور‌های سابقه را نشان می‌دهد. در این قطعه‌کد از دستور \lr{?!} (تبادل همگام) برای فرستادن پیغام استفاده شده است. اکتور دانشجو به هر اکتور سابقه یک پیغام GPAInfoRequest می‌فرستد و با دریافت هر پاسخ GPAInfoResponse این عملیات را انجام می‌دهد:
در صورتی که فیلد isForTerm از پیغام مقدار true داشته باشد مجموع وزن‌دار\footnote{عددی که از جمع حاصل‌ضرب هر نمره در تعداد واحدهای درس حاصل شده است.} نمرات گرفته شده تا حال را با حاصل ضرب فیلد grade در فیلد units جمع می‌کند و حاصل جمع واحد‌ها را به اندازه‌ی units افزایش می‌دهد. نهایتا بعد از مبادله‌ی پیغام با تمام اکتور‌های سابقه، حاصل تقسیم  مجموع وزن‌دار نمرات بر تعداد واحد‌ها به عنوان معدل دانشجو در ترم اعلام می‌شود.
\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/Student_sync.scala}{شبه‌کد اسکالا برای اکتور دانشجو در رویکرد ۱ با ارسال همگام پیغام}{fig:usecases:gpa:1:student_sync} 

حال پرسش اول برای اکتور دانشجو به این صورت بیان می‌شود:\\
آیا اکتور دانشجو بعد از ارسال پیغام GPAInfoRequest به یک اکتور سابقه و در مدتی که هنوز پاسخی از این اکتور دریافت نکرده می‌تواند به فعالیت خود ادامه دهد؟ ابتدا باید به این نکته دقت کرد که تفاوت اصلی رویکرد حاصل از پاسخ مثبت به این پرسش (ارسال ناهمگام) و پاسخ منفی به آن (ارسال همگام) از دیدگاه اکتور فرستنده‌ی درخواست چیست؟ با کمی دقت و تحلیل می‌توان دریافت که تفاوت اصلی این دو رویکرد از دیدگاه فرستنده در نحوه‌ی برخورد با پاسخ پیغام است. به بیان دقیق‌تر در حالت همگام، این که پاسخ دریافت شده مربوط به کدام درخواست بوده است، به طور ضمنی مشخص است. ولی اگر بعد از ارسال پیغام، اکتور منتظر جواب نماند و به کار خود ادامه دهد در هر زمان دیگری ممکن است پاسخ دریافت شود و در این هنگام امکان اینکه تشخیص داده شود این پاسخ مربوط به کدام درخواست بوده ممکن است امکان‌پذیر نباشد. دقت به منطق پیاده شده برای دریافت پیغام GPAInfoResponse نشان می‌دهد که اینکه هر پاسخ مربوط به کدام درخواست بوده اهمیتی ندارد. به بیان دیگر ترتیب دریافت این پاسخ‌ها تاثیری در معدل اعلام شده ندارد. بنابراین پاسخ به پرسش اول در مورد اکتور دانشجو مثبت است. \\
\textbf{نتیجه:}
می‌توانیم پیغام‌های GPAInfoRequest را به صورت ناهمگام ارسال کنیم.\\
اکنون نوبت به پرسش دوم می‌رسد: آیا اکتور دانشجو در حالی که هنوز پاسخ تمام پیغام‌ها را دریافت نکرده می‌تواند درخواست جدیدی را پردازش کند؟\\
برای پاسخ به این پرسش فرض می‌کنیم که اکتور دانشجو در حالی که پاسخ تعدادی از پیغام‌های GPAInfoRequest را دریافت نکرده، یک پیغام جدید \lr{GPARequest} دریافت می‌کند (یک درخواست جدید برای محاسبه‌ی معدل). برای محاسبه‌ی معدل، اکتور دانشجو مطابق منطق پیاده شده اقدام به ارسال پیغام GPAInfoRequest به تمام اکتور‌های سابقه می‌کند. در این حالت فرض کنیم یک پیغام پاسخ GPAInfoResponse دریافت شود. با دریافت این پیغام باید متغیرهای محلی اکتور دانشجو به هدف محاسبه‌ی معدل بروزرسانی می‌شوند. اما با توجه به اینکه مشخص نیست که پاسخ دریافت شده مربوط به کدام در خواست بوده است نمی‌توانیم معدل را به صورت صحیح محاسبه کنیم. به عبارت دیگر منطق محاسبه‌ی معدل برای دو درخواست باهم مخلوط می‌شوند. به همین دلیل پاسخ به پرسش دوم منفی است.\\
\textbf{نتیجه:}
علیرغم اینکه ارسال پیغام‌های GPAInfoRequest را می‌توانیم به صورت ناهمگام انجام دهیم (چون ترتیب دریافت پیغام‌ها اهمیتی ندارد)، قبل از دریافت همه‌ی پاسخ‌های مربوط به درخواست معدل درحال پردازش، نمی‌توانیم درخواست جدیدی دریافت کنیم.\\
البته باید دقت کرد که با وجود اینکه میزان به تعویق انداختن دریافت پاسخ‌ها محدود است (به دلیل پرسش دوم)، کماکان ارسال ناهمگام پیغام‌های  GPAInfoRequest ارزشمند است. چرا که در حالت تبادل ناهمگام، تمام اکتورهای سابقه، به صورت همروند پاسخ این پیغام را آماده می‌کنند در حالی که در حالت همگام به صورت نوبتی و ترتیبی این اتفاق می‌افتد.\\
با توجه به پاسخ به این دو پرسش، طراحی اکتور دانشجو برای محاسبه‌ی معدل به صورت شبه‌کد شکل \ref{fig:usecases:gpa:1:student_Async} تغییر می‌کند. در این شبه‌کد از روش تبادل پیغام  \gls{آینده}\LTRfootnote{Future} (رجوع کنید به بخش \ref{section:scalaActorLib}) استفاده شده است.

\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/Student_Async.scala}{شبه‌کد اسکالا برای اکتور دانشجو در رویکرد ۱ با ارسال ناهمگام پیغام (آینده)}{fig:usecases:gpa:1:student_Async} 

 \FloatBarrier
% در واقع این حالت، رویکرد پیش‌فرض در طراحی به روش شیءگرا است. ارسال پیغام همگام در مدل اکتور در واقع معادل با فراخوانی یک متد در مدل شیءگرای ترتیبی است. و این خاصیت طراحی ترتیبی زیربنای نحوه‌ی استدلال در مورد طرز کار طراحی است. در طراحی ترتیبی اطمینان داریم که تفاوت حالت شیء قبل از  فراخوانی یک متد و بعد از آن، صرفا به منطق پیاده شده در داخل متد وابسته است و خارج از آن هیچ تغییر دیگری رخ نخواهد داد. در صورتی که در طراحی همروند به صورت ناهمگام، این‌گونه نیست.
\item اکتور سابقه:\\
در مورد اکتور سابقه جواب دادن به ۲ پرسش مذکور آسان‌تر است. این اکتور فقط پیغام GPAInfoRequest را ارسال می‌کند و با دریافت هر پیغام پاسخ GPAInfoResponse، صرفا نمره‌ی سابقه را به آن اضافه کرده و برای اکتور دانشجو ارسال می‌کند. واضح است که در این تبادل پیغام، ترتیب پیغام‌‌های پاسخ اهمیتی ندارد. بنابراین پاسخ اولین پرسش مثبت است (ارسال ناهمگام مجاز است). در مورد پرسش دوم با اینکه این اکتور هیچ حالتی\LTRfootnote{state} برای درخواست‌ها نگه نمی‌دارد.\footnote{بر خلاف حالت اکتور دانشجو که در آن متغیر‌هایی برای هر درخواست مقداردهی می‌شدند.} اما دریافت درخواست جدید قبل از گرفتن پاسخ‌های درخواست قبلی  مشکل دیگری ایجاد می‌کند. با توجه به اینکه  هر درخواست که از اکتور دانشجو به اکتور سابقه می‌رسد، نهایتا باید توسط خود اکتور سابقه پاسخ داده شود، در هنگام فرستادن پیغام پاسخ باید آدرس فرستنده‌ی درخواست اولیه موجود باشد. در حالی که اگر قبل از پاسخ به درخواست اکتور دانشجو، درخواست جدیدی دریافت شود و عملیات پردازش درخواست جدید آغاز گردد، هیچ اثری از فرستنده‌ی 
درخواست اول برای ارسال پاسخ به آن موجود نخواهد بود. برای روشن شدن مطلب، شبه‌کد  \ref{fig:usecases:gpa:1:studyrec_Async_wrong} را در نظر بگیرید که در آن فرض شده اکتور سابقه بتواند قبل از فرستادن پاسخ درخواست قبلی، درخواست جدیدی را پردازش کند. همان‌طور که در خط ۱۱ کد اشاره شده است، در هنگامی‌که یک پاسخ از اکتور ارائه دریافت شده، دسترسی به اکتور فرستنده‌ی پیغام اصلی (که در خط ۸ دریافت شده) وجود ندارد تا بتوانیم پاسخ را برای آن ارسال کنیم. باید دقت شود که با اینکه فرستنده‌ی یک پیغام به وسیله‌ی شیء sender قابل دسترسی است، اما این شیء به فرستنده‌ی پیغامی اشاره می‌کند که پیغام آن در حال پردازش است. در مورد خط ۱۱ این شیء اشاره به اکتور ارائه دارد که فرستنده‌ی آخرین پیغام بوده، نه اکتور دانشجو که در انتظار گرفتن پاسخ از اکتور سابقه است. بنابراین پاسخ به پرسش دوم در مورد اکتور سابقه منفی است و این اکتور باید پاسخ هر درخواست را قبل از  پردازش درخواست‌های دیگر ارسال کند. نکته‌ی قابل توجه این است که با توجه به اینکه اکتور سابقه برای پاسخ به درخواست GPAInfoRequest تنها یک پیغام ارسال می‌کند و بدون دریافت پاسخ آن قادر به پاسخگویی به درخواست مذکور نیست، تفاوتی در ارسال همگام و ناهمگام پیغام وجود ندارد چرا که پس از ارسال تنها یک پیغام مجبور به توقف و انتظار برای دریافت پاسخ است. شبه کد \ref{fig:usecases:gpa:1:studyrec_Async_right} طراحی صحیح تبادل پیغام در اکتور سابقه را برای رویکرد ۱ نشان می‌دهد.

\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/StudyRecord_Async_wrong.scala}{شبه‌کد اکتور سابقه برای حالتی که بتواند قبل از پاسخ به درخواست قبلی، درخواست جدیدی را پردازش کند. (این رویکرد اشتباه است.)}{fig:usecases:gpa:1:studyrec_Async_wrong} 

\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/StudyRecord_Async_right.scala}{شبه‌کد صحیح برای  اکتور سابقه در رویکرد ۱}{fig:usecases:gpa:1:studyrec_Async_right} 

\FloatBarrier
\item اکتور ارائه:\\
اکتور ارائه پس از دریافت درخواست GPAInfoRequest دو پیغام به ترتیب برای اکتور‌های ترم و درس ارسال می‌کند و در هر کدام از این دو پیغام بخشی از اطلاعات لازم برای فرستادن پاسخ به اکتور سابقه را از آنها دریافت می‌کند.
پرسش اول در مورد اکتور ارائه اینطور مطرح می‌شود که آیا اکتور ارائه پس از فرستادن هر کدام از پیغام‌های مذکور به ترم و درس می‌تواند پیغام بعدی را ارسال کند یا باید پس از ارسال هرکدام بلافاصله منتظر دریافت پاسخ بماند؟ جواب این پرسش مثبت است به این دلیل که ترتیب پیغام‌های پاسخ اهمیتی ندارد. اما با استدلالی مشابه آنچه که در مورد اکتور سابقه توضیح داده شد، جواب پرسش دوم برای اکتور ارائه منفی است. یعنی اکتور ارائه تا زمانی که پاسخ یک درخواست را به اکتور سابقه‌ی مربوطه نفرستاده، نمی‌تواند درخواست جدیدی (احتمالاً از یک اکتور سابقه‌ی دیگر) پردازش کند. به همین دلیل حداکثر میزان ناهمگامی در ارسال پیغام‌ها برای اکتور ارائه این است که دو پیغام IsYourTermRequest و  NumOfUnitsRequest را به صورت ناهمگام برای اکتورهای ترم و درس ارسال کند و سپس منتظر دریافت پاسخ آنها بماند. بنابراین طراحی تبادل پیغام اکتور ارائه در رویکرد ۱ مطابق شبه‌کد شکل \ref{fig:usecases:gpa:1:offering_Async_right}  خواهد بود. در این شکل نیز از ویژگی آینده\LTRfootnote{Future} (رجوع کنید به \ref{section:scalaActorLib}) استفاده شده است.
\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/Offering_Async_right.scala}{شبه‌کد طراحی نحوه‌ی تبادل پیغام برای  اکتور ارائه در رویکرد ۱.}{fig:usecases:gpa:1:offering_Async_right} 
\FloatBarrier
\item اکتورهای ترم و درس:\\
در مورد  این دو اکتور تصمیم به استفاده از ارسال همگام یا ناهمگام بسیار ساده است. با توجه به اینکه در هر دو اکتور مذکور، تمام اطلاعات لازم برای پاسخ به درخواست‌ها در خود اکتور موجود است، نیازی به ارسال پیغام به سایر اکتورها وجود ندارد و پاسخ درخواست‌ها بلافاصله ارسال می‌شود. لذا هیچ نیازی به تبادل همگام وجود ندارد (چون پاسخی دریافت نخواهد شد). طراحی این دو اکتور از نظر تبادل پیغام در شبه‌کدهای \ref{fig:usecases:gpa:1:term}  و \ref{fig:usecases:gpa:1:course}  نمایش داده شده است.
\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/Term.scala}{شبه‌کد طراحی نحوه‌ی تبادل پیغام برای  اکتور ترم در رویکرد ۱.}{fig:usecases:gpa:1:term} 
\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/Course.scala}{شبه‌کد طراحی نحوه‌ی تبادل پیغام برای  اکتور درس در رویکرد ۱.}{fig:usecases:gpa:1:course} 
\FloatBarrier

\end{enumerate}

\subsubsection{رویکرد دوم}
\label{gpa_approch2}
رویکرد دوم از طراحی مورد کاربرد محاسبه‌ی مدل را با بررسی رویکرد ۱ و طرح چند پرسش در مورد آن آغاز می‌کنیم. نحوه‌ی طراحی ارتباطات و پیغام‌ها در رویکرد اول در بخش قبل به طور کامل توضیح داده شد. در این قسمت خلاصه‌ای از این طراحی را بررسی می‌کنیم:\\
عملیات با دریافت پیغام درخواست معدل \lr{GPARequest(term)} در اکتور دانشجو آغاز می‌شود. اکتور دانشجو به هر کدام از اکتورهای سابقه، یک پیغام درخواست اطلاعات معدل \lr{GPAInfoRequest(term)} ارسال می‌کند. این پیغام از طریق اکتور سابقه به دست اکتور ارائه می‌رسد و از طریق این اکتور به دست اکتورهای درس و ترم می‌رسد و هر کدام از این اکتورها اطلاعات لازم را برای اکتور ارائه ارسال می‌کنند. در ادامه اکتور ارائه یک پیغام پاسخ اطلاعات معدل \lr{(GPAInfoResponse)}  تولید می‌کند و برای اکتور سابقه ارسال می‌کند. سابقه عدد نمره را به پیغام اضافه کرده و برای دانشجو می‌فرستد. دانشجو با تکرار همین عملیات برای تمام سابقه‌ها تمام اطلاعات لازم برای محاسبه‌ی معدل در اختیار دارد.\\
هر اکتور در این مورد کاربرد به دلایل مختلفی اقدام به مشارکت در محاسبه‌ی معدل می‌کند: دانشجو به این دلیل که مسئولیتِ گرفتن درخواست اصلی را دارد و نیز به این دلیل که به اکتور سابقه دسترسی دارد. اکتور سابقه به این دلیل که نمره (یکی از اطلاعات لازم برای محاسبه‌ی معدل) را در اختیار دارد و نیز از طریق اکتور ارائه به درس و ترم دسترسی دارد. اکتور ارائه به دلیل دسترسی به درس و ترم. و اکتورهای درس و ترم به دلیل اینکه اطلاعات مورد نیاز برای محاسبه‌ی معدل را در اختیار دارند. در نتیجه مشارکت تمام این اکتورها در محاسبه‌ی معدل ضروری است. اما پرسشی که پیش می‌آید این است که آیا میزان مشارکت این اکتورها نیز باید در همین میزان باشد؟ اگر هر دریافت یا ارسال یک نوع پیغام را یک مشارکت برای اکتور در طراحی این مورد کاربرد در نظر بگیریم، آیا می‌توان تعداد مشارکت‌های اکتورها را کاهش داد؟ به عنوان مثال اکتور سابقه را در نظر می‌گیریم. همان‌طور که ذکر شد مشارکت این اکتور به دلیل داشتن فیلد نمره و نیز دسترسی به اکتور ارائه ضروری است. تعداد مشارکت اکتور  سابقه با توجه به تعریف ارائه شده، از روی نمودار ترتیب شکل \ref{fig:gpa1_sequence} به این ترتیب قابل استخراج است: هر فلشی که از خط زمان\LTRfootnote{time line} اکتور سابقه خارج یا به آن وارد می‌شود معادل ارسال یا دریافت یک نوع پیغام است. بنابراین تعداد مشارکت اکتور سابقه در این مورد کاربرد ۴ است. مشارکت اول مربوط به دریافت پیغامِ درخواست از دانشجو است، مشارکت دوم مربوط به ارسال درخواست به ارائه است، مشارکت سوم دریافت پاسخ از ارائه و مشارکت چهارم مربوط به ارسال پاسخ به دانشجو است. حال بررسی می‌کنیم که از این تعداد مشارکت، دو مورد الزامی است. یکی دریافت درخواست از دانشجو به دلیل اینکه دانشجو از طریق دیگری به اطلاعات مورد نیاز برای محاسبه‌ی معدل دسترسی ندارد، و دیگری ارسال درخواست برای ارائه. دو مورد دیگر یعنی دریافت پاسخ ارائه و تحویل آن به دانشجو را می‌توان حذف کرد. روش حذف به این صورت است که اکتور ارائه به نحوی مطلع شود که جواب نهایی به چه کسی ارسال خواهد شد (دانشجو). این کار از طریق \textbf{قرار دادن مقصد نهایی پیغام در داخل پیغام} قابل انجام است. در این حالت دیگر نیازی به برگشت پیغام به دست سابقه وجود ندارد. تنها موردی که به نظر مشکل‌ساز می‌آید این است که فیلد نمره در رویکرد ۱ در هنگام برگشت پیغام در  آن قرار داده می‌شود و اگر پیغام از طریق سابقه برگشت داده نشود فیلد نمره را نخواهد داشت. البته این مورد به سادگی قابل حل است و در همان بار اول که پیغام به دست سابقه رسید، می‌تواند نمره را به پیغام اضافه کند. البته مثال اکتور سابقه در مورد بقیه‌ی اکتورها نیز قابل بررسی است ولی به دلیل پرهیز از تکرار استدلال به همین مورد اکتفا می‌کنیم.\\
مورد دیگری که در رویکرد ۱ بررسی می‌کنیم عدم امکان پردازش درخواست‌های جدید در هنگام انتظار برای تکمیل اطلاعات مورد نیاز برای پاسخ به درخواست قبلی است. مثلا در مورد دانشجو این مورد باعث شد که در رویکرد ۱، دانشجو قبل از ارسال پاسخ درخواست معدل،‌ درخواست دیگری را بررسی کند. در مورد دانشجو دلیل این پدیده این بود که منطق محاسبه‌ی معدل قسمتی از حالت\LTRfootnote{state} این اکتور بود و تداخل درخواست‌های معدل می‌تواند باعث عملکرد غلط اکتور شود. یک راه برای حل این مشکل این است که به نوعی مشخص کنیم که هر پاسخی که اکتور دانشجو دریافت می‌کند مربوط به کدام درخواست اصلی بوده‌ است. یعنی حالت اکتور را در قالب نگاشت‌هایی از پیغام‌ها حفظ کنیم. مثلا برای اکتور دانشجو، به جای اینکه یک متغیر برای مجموع نمره‌هایی که تا این لحظه پاسخ آنها بررسی شده (رجوع کنید به شبه‌کد شکل \ref{fig:usecases:gpa:1:student_Async})، می‌توانیم نگاشتی\LTRfootnote{map} از شناسه‌ی درخواست معدل به متغیر مجموع نگهداری کنیم، به این ترتیب با رسیدن یک پاسخ، متغیر مربوط به درخواست مربوطه برای محاسبه استفاده می‌شود. البته این روش اولاً باعث پیچیده‌تر شدن منطق اکتور می‌شود و ثانیاً نگهداری ساختار داده‌ی نگاشت اهمیت زیادی پیدا می‌کند. به این دلایل استفاده از نگاشت رویکرد مناسبی نیست. روش دیگر این است که کل عملیات بررسی یک درخواست را به اکتور دیگری که به همین منظور ایجاد می‌شود، منتقل کنیم. مثلا وقتی اکتور دانشجو یک درخواست محاسبه‌ی معدل دریافت می‌کند، یک اکتور مختص همان درخواست ایجاد کنیم و همه‌ی تبادلات مربوط به آن درخواست را به اکتور جدید واگذار کنیم. طبیعتا تمام اطلاعات لازم از جمله دسترسی به اکتور سابقه باید به اکتور جدید منتقل شود. در نتیجه‌ی این رویکرد، دانشجو می‌تواند با دریافت هر درخواست معدل، بلافاصله به پردازش آن بپردازد.\\
با توجه به موارد ذکر شده و بدون تکرار نکاتی که در رویکرد اول ذکر شد به ارائه‌ی خلاصه‌ای از طراحی اکتورها در رویکرد دوم می‌پردازیم.
شکل \ref{fig:gpa2_sequence} نمودار ترتیب برای رویکرد دوم محاسبه‌ی معدل را نشان ‌می‌دهد. برای پرهیز از تکرار، در این رویکرد مراحل طراحی معرفی شده در رویکرد اول بسط داده نشده است و صرفاً چند تغییر اساسی توضیح داده می‌شود.

\begin{figure*}
    \begin{center}
	\includegraphics[width=16cm]{4-ProposedFramework/Figures/gpa_2_sequence.pdf}
    \end{center}
    \caption{\label{fig:gpa2_sequence} نمودار ترتیب برای رویکرد دوم محاسبه‌ی معدل }
\end{figure*}
\FloatBarrier
\begin{enumerate}
\item اکتور محاسبه‌ی معدل \lr{(GPAActor)}:\\
همان طور که قبلا توضیح داده شد، این اکتور برای انجام کل فعالیت‌های مربوط به یک درخواست معدل را انجام می‌دهد (در رویکرد اول این‌ کار توسط خود اکتور دانشجو انجام می‌شد).  این اکتور برای انجام وظیفه‌ی خود اولاً نیاز به برقراری ارتباط با اکتورهای سابقه دارد، و ثانیاً نیاز به دسترسی به مقصد پاسخ درخواست دارد تا بتواند نتیجه را برای آن ارسال کند. این موارد توسط اکتور دانشجو در اختیار اکتور محاسبه‌ی معدل قرار می‌گیرد. شبه کد \ref{fig:usecases:gpa:2:gpaActor} نحوه‌ی طراحی این اکتور را نشان می‌دهد. اکتور محاسبه‌ی معدل با شروع به کار پیغام‌های لازم برای سایر اکتور‌ها را ارسال می‌کند و با گرفتن هر پاسخ، متغیر‌های حالت خود را بروزرسانی می‌کند. پایان کار این اکتور زمانی مشخص می‌شود که به تعدادی که پیغام ارسال کرده پاسخ دریافت کند. این تعداد برابر با تعداد اکتورهای سابقه است. بنابراین پس از دریافت این تعداد پیغام، معدل محاسبه شده را برای مقصد نهایی ارسال می‌کند.

\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/2/GPAActor.scala}{شبه‌کد طراحی اکتور محاسبه‌ی معدل در رویکرد ۲.}{fig:usecases:gpa:2:gpaActor} 

تغییر مهم اکتور دانشجو این است که با توجه به واگذاری عملیات محاسبه‌ی معدل به اکتوری دیگر، نیازی به نگهداری متغیرهای حالت که به این منظور ایجاد شده بودند، ندارد. شبه کد 
اکتور دانشجو در رویکرد جدید در شکل \ref{fig:usecases:gpa:2:student}  نشان داده شده است. مقایسه‌ی طراحی این اکتور در دو رویکرد نشان می‌دهد که با انجام این عمل، طراحی اکتور دانشجو بسیار ساده‌تر شده است.

\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/2/Student.scala}{شبه‌کد طراحی اکتور دانشجو در رویکرد ۲.}{fig:usecases:gpa:2:student} 
\FloatBarrier

\end{enumerate}
%۱: نقش سابقه در این پیغام‌ها چیه؟ یکی اینکه نمره دست اونه و دیگه اینکه راهیه که به بقیه اطلاعات برسیم. اولی باعث می‌شه که حتما به دست اون برسه. ولی آیا اینکه جواب اول دست سابقه برسه بعد به دانشجو برسه الزامیه؟ با توجه به اینکه یک بار از زیر دستش رد می‌شه و دفعه‌ی دوم فقط relay می‌کنه.
%۲: یادآوری سوال ۲ بخش قبل. تاکید بر اینکه این بده چون ما همروندی رو پایین میاریم. آیا راهی برای این کار وجود نداره؟ یه اکتور درست می‌کنیم که فقط اینو ....
%۳: هیچ جا نمی‌شه مسیرو کوتاهتر کرد؟ زودتر جواب آخر رو فرستاد؟ منظور اینه که از domain بفهمیم. در این مورد اگر مربوط به ترم نباشه اصلا حساب نمی‌شه. پس اگه ترم ۱ سره بتونه جواب بده خیلی خوبه.
\subsubsection{مقایسه‌ی دو رویکرد}
در بخش‌های قبلی ۲ رویکرد مختلف برای طراحی اکتورها در ارتباط با مورد کاربرد محاسبه‌ی معدل معرفی شده و مراحل انجام طراحی در آنها شرح داده شد. علیرغم صحت عملکرد هر دو رویکرد، تفاوت‌های کیفی در طراحی به وسیله‌ی این دو رویکرد حائز اهمیت هستند. به همین دلیل در این بخش به مقایسه‌ی این دو رویکرد می‌پردازیم.\\
رویکرد دوم دو تغییر عمده نسبت به رویکرد اول دارد:
\begin{enumerate}
\item قرار دادن مقصد نهایی درخواست در داخل پیغام:\\
در رویکرد اول هر اکتوری که پیغامی را به عنوان درخواست از یک اکتور دیگر دریافت می‌کند، وظیفه‌ی پاسخ به آن را نیز به عهده دارد. در صورتی که برای پاسخ به درخواست نیاز به برقراری ارتباط با اکتورهای دیگر وجود داشته باشد،‌این اکتور اقدام به ارسال پیغام‌های مرتبط به سایر اکتورها می‌کند و در نهایت با جمع‌آوری پاسخ‌ها، درخواست اصلی را پاسخ می‌دهد. با اینکه این رویکرد از دیدگاه طراحی شیءگرا به روش ترتیبی،‌ رویکردی متداول و حتی اجباری است\footnote{در طراحی شیءگرای ترتیبی، مکانیزم کنترل برنامه فراخوانی متد است. با هر فراخوانی متد، منطق پیاده شده در متد اجرا می‌شود و پس از بازگشت از متد، اجبارا کنترل برنامه به همان قسمتی که متد فراخوانی شده بود برمی‌گردد.}، در مدل تبادل پیغام این امکان وجود دارد که پاسخ درخواست را اکتوری غیر از دریافت کننده‌ی درخواست ارسال کند. لازم به ذکر است که در مدل اکتور هیچ فرضی در مورد مشخصات فرستنده‌ی پیغام صورت نمی‌گیرد. بنابراین یک اکتور می‌تواند به جای اینکه پس از ارسال پیغام‌های مربوط به یک درخواست، منتظر دریافت جواب برای فرستادن به درخواست کننده بماند،‌ آدرس (نام) مقصد نهایی را در داخل پیغام برای اکتور ها ارسال کند تا در صورت لزوم از آن برای فرستادن نتیجه استفاده کنند. رویکرد دوم در واقع از این امتیاز استفاده کرده و به این روش از تعدادی از تبادلات پیغام که صرفاً به دلیل ذکر شده صورت می‌گیرند، جلوگیری می‌کند. با این کار نیازی به برگشت پیغام در همان مسیری که طی شده وجود نخواهد داشت و در هر لحظه که اطلاعات لازم برای تکمیل پاسخ تأمین شود، پاسخ به مقصد ارسال خواهد شد.
\item واگذار کردن پردازش‌های مربوط به یک درخواست به یک اکتور موقت:\\
 در رویکرد اول اکتور دانشجو، پس از ارسال پیغام‌های لازم و دریافت جواب، تمام محاسبات لازم برای تعیین معدل را انجام ‌می‌داد. در اثر استفاده از این رویکرد، اولاً دانشجو باید تعدادی پیغام برای تهیه‌ی اطلاعات لازم جهت محاسبه‌ی معدل به سایر اکتورها ارسال کرده و منتظر جواب بماند، ثانیاً برای محاسبه‌ی معدل اطلاعات موقتی را به عنوان متغیر حالت در خود نگهداری کند. مقدار این متغیر‌ها فقط در زمانی که یک درخواست مشخص در حال پردازش است معتبر است به همین دلیل در صورت شروع به پردازش درخواست‌های دیگر قبل از اتمام عملیات مربوط به درخواست قبلی امکان‌پذیر نمی‌باشد. در نتیجه میزان همروندی در درخواست‌های مشابه پایین می‌آید. از طرف دیگر در صورتی که قرار باشد، اکتور انواع متعددی از درخواست‌هایی را که این خاصیت را دارند پردازش کند، مدیریت پیچیدگی حاصل از اطلاعات حالت مربوط به درخواست‌های مختلف نیز کار آسانی نخواهد بود و منجر به پیچیدگی زیاد  و تغییرپذیری کمتر کلاس خواهد شد. به همین دلایل در رویکرد دوم سیاست جدید اتخاذ شد و آن سپردن کل فعالیت‌های محاسبه‌ی معدل به یک اکتور جدید است. با این کار دو نتیجه‌ی مطلوب حاصل می‌شود. اولاً پیچیدگی‌های مربوط به اجرای یک درخواست به اکتور دیگری منتقل می‌شود که صرفاً برای پاسخ به درخواست مورد نظر طراحی شده است. ثانیا با توجه به اینکه هر نمونه از اکتور جدید صرفاً محدود به یک درخواست بوده و پس از پاسخ به‌ آن به فعالیت خاتمه می‌دهد، امکان پاسخ به درخواست‌های همروند به درخواست‌ها هم به وجود می‌آید.
\end{enumerate}
لازم به ذکر است که هدف از معرفی این دو رویکرد در طراحی منطق مربوط به محاسبه‌ی معدل صرفاً تأکید بر تفاوت‌های آنها و حفظ وضوح روش طراحی دارد. علیرغم صحت رویکرد اول، در ادامه‌ی طراحی از سیاست‌های ذکر شده در رویکرد دوم استفاده خواهد شد.
\subsection{مورد کاربرد اخذ درس}
\label{subsection:take_course_uc_design}
در بخش قبل مراحل طراحی مورد کاربرد محاسبه‌ی معدل با استفاده از دو رویکرد مختلف توضیح داده شد. در این بخش مراحل طراحی مورد کاربرد اخذ درس با توجه به تجربیات حاصل از بخش قبل ارائه می‌گردد. \\
توصیف مورد کاربرد اخذ درس در جدول \ref{table:uc_takecoure} ارائه شد. دانشجو در زمان انتخاب واحد یکی از ارائه‌\LTRfootnote{Offering}های موجود ترم را انتخاب می‌کند. سیستم شرایط لازم برای اخذ این ارائه را بررسی می‌کند. در صورتی که دانشجو مجاز به انتخاب این ارائه باشد، یک سابقه از ارائه‌ی مورد نظر را برای دانشجو ذخیره می‌کند. در صورتی که هر کدام از شرایط لازم برای اخذ محقق نشده باشد سیستم یک پیغام خطا برای کاربر نمایش می‌دهد.
همانند مورد کاربرد قبل،‌ این مورد کاربرد هم با دریافت یک پیغام توسط اکتور دانشجو آغاز می‌شود. تنها اطلاعاتی که در این پیغام باید موجود باشد ارائه‌ی انتخاب شده برای اخذ است. بنابراین فرمت پیغام درخواست اخذ درس به شکل زیر خواهد بود:
\begin{latin}
TakeCourseRequest(offering: Offering)
\end{latin}
پاسخ این درخواست نیز باید حاوی نتیجه‌ی عملیات و نیز احتمالاً یک پیغام برای کاربر خواهد بود. بنابراین پیغام پاسخ اخذ درس به فرمت زیر خواهد بود:
\begin{latin}
TakeCourseResponse(result: Boolean, comment: String)
\end{latin}
مطابق توضیحاتی که در طراحی مورد کاربرد محاسبه‌ی معدل داده ‌شد، اکتور دانشجو در مواجهه با پیغام درخواست اخذ دو راهکار کلی پیش رو دارد. راهکار اول این است که منطق مورد نیاز برای پردازش اخذ درس را خودش پیاده‌سازی کند (مانند رویکرد اول در طراحی مورد کاربرد محاسبه‌ی معدل) و راهکار دوم این است که به یک اکتور دیگر وکالت این محاسبات را بسپارد. همان‌طور که در بخش قبل ذکر شد،‌ تصمیم به سپردن محاسبات به کاربرد دیگر به دو انگیزه‌ی مختلف صورت می‌گیرد. انگیزه‌ی اول جلوگیری از پیچیده و بزرگ شدن یک اکتور در اثر پردازش پیغام‌های مختلف و انگیزه‌ی دوم ایجاد امکان همروندی در پردازش پیغام‌های مشابه.\\
در این مورد کاربرد هر دو انگیزه برای سپردن محاسبات به یک اکتور دیگر معتبر می‌باشند: اکتور دانشجو در مدل دامنه‌ی معرفی شده، مسئولیتِ دریافت اکثر درخواست‌های کاربران را به عهده دارد (به دلیل اینکه کاربر اصلی این سیستم دانشجو است)، درخواست‌های مختلفی را دریافت خواهد کرد. به همین دلیل در صورتی که  پردازش تمام این پیغام‌ها را بر عهده بگیرد، اندازه و پیچیدگی آن زیاد شده و در نتیجه تغییرپذیری آن تنزّل خواهد کرد (انگیزه‌ی اول). علاوه بر این، اکتور دانشجو برای پردازش هر درخواست اخذ درس، باید شروط مختلفی را بررسی کند و برای این کار با اکتورهای دیگر به دفعات تبادل پیغام انجام خواهد داد و برای حفظ نتایج میانی تبادلات پیغام تا پایان پردازش درخواست، مجبور به استفاده از متغیرهای حالت اکتور (فیلدهای داده‌ی محلی) خواهد بود (مشابه متغیرهایی که در محاسبه‌ی معدل استفاده شد). در نتیجه پردازش همروند درخواست‌های اخذ درس بسیار پیچیده و یا نشدنی خواهد بود. بنابراین در این مورد، ایجاد همروندی در پردازش درخواست‌ها نیز انگیزه‌ی معتبری برای سپردن محاسبات به یک اکتور دیگر است (انگیزه‌ی دوم). \\
\subsubsection{ اکتور اخذ درس}
\label{section:takeCourse}
با توجه به توضیحات ذکر شده اکتور دانشجو با گرفتن درخواست اخذ درس، کلیه‌ی محاسبات لازم و ارسال پاسخ را به اکتور اخذ درس منتقل می‌کند. وظیفه‌ی اکتور اخذ درس بررسی شرایط دانشجو برای اخذ درس و ارسال پاسخ درخواست است. طبق توصیف مورد کاربرد اخذ درس (جدول \ref{table:uc_takecoure})، شروطی که باید قبل از قبول اخذ درس بررسی شوند عبارتند از:
\begin{enumerate}
\item دانشجو در ترم‌های قبل درس مربوط به ارائه‌ی انتخاب شده را  نگذرانده باشد.
\item دانشجو در ترم‌ جاری این درس را اخذ نکرده باشد.
\item دانشجو تمام پیش‌نیاز‌های این درس را با موفقیت گذرانده باشد.
\end{enumerate}
در این مرحله، اکتور اخذ درس باید برای هر یک از شروط ذکر شده، اولاً قالب پیغام مناسب را طراحی کند، ثانیاً مقصد پیغام را مشخص کند (تشخیص اکتور مسئول). این دو مورد باید برای هریک از شرط‌های فوق بررسی شوند. در ادامه بررسی این موارد برای شرط اول به صورت مبسوط بررسی می‌شود و برای سایر شروط با توجه به شباهت به شرط اول صرفاً نتیجه‌ی بررسی ارائه می‌گردد:
\begin{itemize}
\item شرط ۱:\\
 این شرط باید تعیین کند که دانشجو قبلاً سابقه‌ای از گذراندن این درس را دارد یا خیر. قبل از انتخاب قالب پیغام، بحثی در مورد پذیرنده‌ی پیغام (اکتور مسئول) می‌کنیم. گزینه‌های موجود برای اکتور مسئول بررسی شرط گذراندن درس باشد اینها هستند:
 \begin{enumerate}
 \item خود اکتور اخذ درس:\\
  انتخاب اول در واقع به این معنی است که اکتور اخذ درس به جای اینکه درخواستی برای بررسی گذرانده شدن درس ارسال کند،‌ خود این بررسی را به عهده بگیرد. البته این به این معنی نیست که برای انجام این بررسی هیچ پیغامی به اکتورهای دیگر ارسال نکند، بلکه به این معنی است که وظیفه‌ی پیاده‌سازی منطق لازم برای رسیدن به پاسخ این پرسش (آیا این دانشجو قبلاً این درس را گذرانده است؟) بر عهده‌ی اکتور اخذ درس باشد. این حالت به دو دلیل مناسب نیست: اولاً در این حالت اکتور اخذ درس به صورت ابتدا به ساکن (بدون دریافت درخواستی برای این کار) اقدام به پیاده‌سازی یک منطق کرده است. در نتیجه این پیاده‌سازی به جز این اکتور برای اکتور دیگری قابل استفاده‌ی مجدد نیست.
 \footnote{  البته یک راهکار ممکن برای برطرف کردن این مشکل این است که به اکتور اخذ درس، قابلیت دریافت پیغامی از نوع بررسی شرط مذکور اضافه شود و این اکتور برای بررسی این شرط، یک پیغام به خودش بفرستد تا به این صورت قابلیت استفاده‌ی مجدد داشته باشد. اما ایراد این رویکرد این است که از نظر منطقی اضافه کردن این رفتار به اکتوری که صرفاً وظیفه‌ی پاسخ به یک درخواست اخذ درس را دارد، از نظر تقسیم مسئولیت عمل درستی نیست.}
  ثانیاً با توجه به اینکه این اکتور شروط متعددی را بررسی می‌کند، پیاده کردن منطق بررسی این شروط خوانایی کلاس را کاهش می‌دهد. 
 
  البته یک راهکار ممکن برای برطرف کردن این مشکل این است که به اکتور اخذ درس، قابلیت دریافت پیغامی از نوع بررسی شرط مذکور اضافه شود و این اکتور برای بررسی این شرط، یک پیغام به خودش بفرستد تا به این صورت قابلیت استفاده‌ی مجدد داشته باشد. اما ایراد این رویکرد این است که از نظر منطقی اضافه کردن این رفتار به اکتوری که صرفاً وظیفه‌ی پاسخ به یک درخواست اخذ درس را دارد، از نظر تقسیم مسئولیت عمل درستی نیست. 
 \item اکتور جدیدی که به این منظور تولید می‌شود:\\
 این رویکرد ایرادهای شمرده شده برای انتخاب اول را ندارد. اما با فرض این که درخواست بررسی گذرانده شدن درس یک درخواست قابل استفاده‌ی مجدد در منطق دامنه‌ی سیستم باشد، با این رویکرد در هر قسمتی از برنامه که نیاز به بررسی این درخواست وجود داشته باشد، باید اکتوری به این منظور ایجاد شود و اطلاعات لازم به آن داده شود و سپس درخواست برای آن ارسال شود. از نظر طراحی شیءگرا، تکرار این عملیات در هر بار نیاز به این درخواست پدیده‌ی مطلوبی نمی‌باشد.
 \item اکتور دانشجو:\\
 انتخاب اکتور دانشجو برای ارسال درخواست بررسی گذرانده شدن درس علاوه بر اینکه ایرادهای مطرح شده در گزینه‌ی اول را ندارد، مشکل تکرار عملیات (گزینه‌ی دوم) را نیز ندارد. در این حالت، هر اکتوری که نیاز به بررسی درخواست گذرانده شدن درس را داشته باشد، پیغام مربوطه را برای اکتور دانشجو ارسال می‌کند و تنها جایی که عملیات ایجاد اکتور جدید برای پردازش این درخواست انجام می‌شود اکتور دانشجو است. از نظر منطق دامنه نیز بررسی گذرانده شدن درس توسط اکتور دانشجو انتخاب مطلوبی به نظر می‌رسد.
 \end{enumerate}
 با توجه به استدلال فوق، اکتور اخذ درس، اکتور دانشجو را به عنوان مسئول بررسی گذرانده شدن درس انتخاب می‌کند.\\
 با انتخاب مقصد پیغام درخواست بررسی گذرانده شدن درس، طراحی قالب پیغام آن به آسانی انجام می‌شود. با توجه به اینکه این پیغام به مقصد اکتور دانشجو ارسال می‌شود، تنها داده‌ای که لازم است در آن قرار داده شود درس مربوطه است. بنابراین قالب پیغام درخواست به صورت زیر می‌باشد:
 \begin{latin}
 PassedRequest(course:Course)
 \end{latin}
 پیغام پاسخ کافی‌ است که اطلاع دهد که درس مورد نظر گذرانده شده است یا خیر. بنابراین قالب پیغام پاسخ به صورت زیر می‌باشد:
 \begin{latin}
PassedResponse(result:Boolean)
 \end{latin}
% با توجه به توضیحات داده‌ شده، طراحی اکتور اخذ درس تا این مرحله از طراحی به صورت شبه‌کد شکل بلاه خواهد بود.

\item شرط ۲:\\
 این شرط باید تعیین کند که دانشجو قبلاً در همین ترم این درس را اخذ کرده است یا خیر. با استدلال مشابه شرط ۱ به این نتیجه می‌رسیم که مقصد پیغام درخواست بررسی اخذ تکراری اکتور دانشجو است و قالب پیغام‌های درخواست و پاسخ برای این شرط به صورت زیر می‌باشد:
 \begin{latin}
 TakenRequest(course:Course)
 TakenResponse(result:Boolean)
 \end{latin}

\item شرط ۳:\\
 این شرط باید تعیین کند که دانشجو تمام پیش‌نیازهای درس را با موفقیت گذرانده است یا خیر. با استدلال مشابه شرط ۱ به این نتیجه می‌رسیم که مقصد پیغام درخواست بررسی اخذ تکراری اکتور دانشجو است و قالب پیغام‌های درخواست و پاسخ برای این شرط به صورت زیر می‌باشد:
 \begin{latin}
 PassedPresRequest(course:Course)
 PassedPresResponse(result:Boolean)
 \end{latin}
 
%\item شرط ۴:\\
% این شرط کنترل می‌کند که با اخذ این درس آیا تعداد واحدهای دانشجو در ترم جاری بیشتر از ۲۰ می‌شود یا خیر. گذراندن بیش از تعدادی واحد به احتمال زیاد در چنین سیستمی به جز در بررسی شرایط کاربرد دیگری ندارد (بر خلاف موردی مثل بررسی گذرانده شدن درس که در موارد متعددی می‌تواند کاربرد داشته باشد) به همین دلیل پیغام مربوط به این مورد بهتر است به جای دانشجو به اکتور دیگری که مختص این کاربرد طراحی می‌شود سپرده شود. گیرنده‌ی پیغام مربوط به این شرط اکتور تأیید تعداد واحد (UnitsValidatorActor)  خواهد بود. با توجه به این که اکتور مذکور نیاز به دسترسی به سوابق دانشجو و نیز تعداد واحد درس انتخاب شده دارد، در هنگام ایجاد این اکتور، باید فیلد‌های دانشجو و درس را در اختیار اکتور قرار دهیم. به این ترتیب، اکتور تأیید تعداد واحد به محض ایجاد می‌تواند کار خود را شروع کند و  اکتور اخذ درس نیازی به ارسال پیغام به آن ندارد. با توجه به این توضیحات پیغام‌ پاسخ برای این شرط به صورت زیر می‌باشد:
% \begin{latin}
%  UnitsValidationResponse(result:Boolean)
% \end{latin}
\end{itemize}
در این مرحله باید تعیین کنیم که اکتور بررسی اخذ درس با دریافت پاسخ هر پیغام چه عملی را باید انجام دهد:\\
هر یک از پاسخ‌هایی که اکتور بررسی اخذ درس دریافت می‌کند در واقع نتیجه‌ی بررسی یکی از شروط لازم برای اخذ درس است. برای موافقت با اخذ درس توسط دانشجو، تمام شروط باید بررسی شوند. بنابراین پاسخ موافقت با اخذ درس فقط زمانی می‌تواند ارسال شود که تمام پاسخ‌ها دریافت شوند. برای اینکه اکتور اخذ درس از اتمام دریافت دروس مطلع شود، لازم است که متغیری که به منظور نگهداری تعداد پاسخ‌های دریافت شده استفاده می‌شود، بروزرسانی گردد. با این کار اکتور اخذ درس می‌داند که چه زمانی کار به اتمام رسیده است. اما در این مورد کاربرد، در همه‌ی حالت‌ها لازم نیست اکتور منتظر تمام پاسخ‌ها بماند. دلیل این امر این است که در صورتی که هر یک از شروط اخذ درس نقض شود، نیازی به بررسی سایر شروط نیست. مثلاً اگر دانشجو قبلاً درس را گذرانده باشد نیازی به دریافت سایر پاسخ‌ها وجود ندارد و می‌توانیم پاسخ درخواست را ارسال کنیم (خطای گذرانده شدن درس). بنابراین در این مورد کاربرد با گرفتن هر پاسخ به این ترتیب عمل می‌کنیم که اگر شرط برقرار باشد، مقدار متغیر تعداد پاسخ‌های دریافت شده را یکی زیاد می‌کنیم، اگر مقدار جدید برابر با تعداد پاسخ مورد انتظار بود (این یعنی تمام پاسخ‌ها دریافت شده‌اند)، پاسخ نهایی درخواست را ارسال می‌کنیم. و اگر شرط نقض شده باشد پاسخ درخواست را که عدم موفقیت اخذ به دلیل نقض شرایط است ارسال می‌کنیم.
نمودار شکل \ref{fig:take_course_sequence_1} تصمیمات اتخاذ شده تا این مرحله از طراحی را به صورت شماتیک نشان می‌دهد. در این نمودار حالتی بررسی شده که تمام شرایط اخذ درس برقرار شده و اخذ با موفقیت انجام می‌شود. حالت دیگری که یکی از شروط (تعداد واحد) برقرار نشده است در شکل \ref{fig:take_course_sequence_2} نشان داده شده است. در این حالت با توجه به اینکه یکی از پاسخ‌ها نشان‌دهنده‌ی این است که یکی از شروط برقرار نشده،‌ به محض دریافت این پیغام، اکتور اخذ درس نتیجه‌ی درخواست را ارسال می‌کند و به کار خود پایان می‌دهد. طبیعتا پیغام‌های دیگری که برای این اکتور ارسال شده‌اند پردازش نخواهند شد.
لازم به تأکید است که در هر دو شکل ترتیب پیغام‌ها فقط نشان دهنده‌ی یک حالت فرضی هستند. در عمل در هر بار اجرای برنامه، ترتیب گرفتن پاسخ‌ها ممکن است عوض شود.

\begin{figure*}
    \begin{center}
	\includegraphics[width=10cm]{4-ProposedFramework/Figures/take_course_seq1.pdf}
    \end{center}
    \caption{\label{fig:take_course_sequence_1} نمودار ترتیب تبادل پیغام‌ برای اخذ درس- حالتی که تمام شروط برای اخذ برقرار است }
\end{figure*}
%\FloatBarrier

\begin{figure*}
    \begin{center}
	\includegraphics[width=10cm]{4-ProposedFramework/Figures/take_course_seq2.pdf}
    \end{center}
    \caption{\label{fig:take_course_sequence_2} نمودار ترتیب تبادل پیغام‌ برای اخذ درس- حالتی که یکی از شروط برقرار نیست }
\end{figure*}
%\FloatBarrier


 در این مرحله، طراحی اکتور اخذ درس به پایان رسیده است. شبه‌کد \ref{fig:usecases:take_course:take_course} ساختار کلاس اکتور اخذ درس را نشان می‌دهد.
 \codelisting[language=scala]{4-ProposedFramework/src/usecases/take_course/TakeCourseActor.scala}{شبه‌کد طراحی اکتور اخذ دانشجو.}{fig:usecases:take_course:take_course} 
%\FloatBarrier
  در ادامه باید تغییرات سایر اکتورها در اثر دریافت پیغام‌های ارسال شده از اکتور اخذ درس اعمال شود و نیز اکتور جدیدی که ایجاد شده (اکتور تایید تعداد واحد) نیز طراحی گردد.
%   برای رعایت اختصار و اجتناب از طرح نکات تکراری، جزئیات طراحی بررسی شرط گذرانده شدن درس‌ ارائه می‌گردد.
\subsubsection{بررسی گذرانده شدن درس}
\label{subsection:passCourse}
  برای بررسی گذرانده شدن درس، اکتور اخذ درس یک پیغام CoursePassRequest به اکتور دانشجو ارسال می‌کند. اکتور دانشجو بررسی این شرط را به اکتور جدید گذراندن درس\LTRfootnote{CoursePassActor} می‌سپارد. این اکتور برای بررسی گذرانده شدن درس، نیاز به برقراری ارتباط با اکتورهای سابقه\LTRfootnote{StudyRecord} دارد. بنابراین اکتور دانشجو لیست سابقه‌ی دانشجو و نیز درسی که باید گذرانده شدن آن بررسی شود را در اختیار اکتور بررسی گذراندن درس قرار می‌دهد. اکتور گذراندن درس از تمام اکتورهای سابقه سؤال می‌کند که آیا سابقه‌ی مربوطه یک گذراندن موفق از درس مذکور است یا خیر. این کار با ارسال یک پیغام با قالب زیر صورت می‌پذیرد:
  \begin{latin}
  AreYouPassCourseRequest(course)
  \end{latin}
هر اکتور سابقه‌ با دریافت این پیغام باید اولاً بررسی کند که آیا سابقه‌ای مربوط به درس مذکور است یا خیر، و ثانیاً سابقه، دارای نمره‌ی قبولی است یا خیر. در اینجا با توجه به اینکه نمره‌ی مربوطه در اختیار خود اکتور سابقه است، بررسی آن ساده‌تر است. در صورتی که نمره کمتر از ۱۰ باشد، این اکتور بلافاصله پاسخ پیغام (منفی) را می‌دهد، در غیر این صورت برای بررسی این که این سابقه مربوط به درس مذکور است یا خیر، یک پیغام برای اکتور ارائه ارسال می‌کند. اکتور ارائه با گرفتن این پیغام آن را برای اکتور درس ارسال می‌کند تا این اکتور بررسی کند که آیا با درسی که در قالب پیغام دریافت کرده برابر است یا خیر. این اکتور پاسخ نهایی را مستقیماً برای اکتور بررسی گذرانده شدن درس ارسال می‌کند.  
\begin{figure}[ht]
    \begin{center}
	\includegraphics[width=14cm]{4-ProposedFramework/Figures/HasPassed.pdf}
    \end{center}
    \caption{\label{fig:take_course_haspassed}نمایش شماتیک تبادل پیغام بین اکتورهای مختلف برای بررسی گذرانده شدن یک درس }
\end{figure}

شکل \ref{fig:take_course_haspassed} تبادل پیغام‌های مربوط به بررسی گذرانده شدن درس را به صورت شماتیک نشان می‌دهد. در این شکل خط عمودی در حالتی به کار رفته‌ است که یک اکتور در زمان‌های مختلف پیغام دریافت کرده باشد. در مثال بررسی شده در شکل، اکتور اخذ درس یک درخواست بررسی گذرانده شدن درس (درس c1 ( را برای اکتور دانشجو ارسال می‌کند. اکتور دانشجو یک اکتور بررسی گذرانده شدن درس (HasPassedActor) ایجاد می‌کند و کار بررسی را به آن واگذار می‌کند. این اکتور پیغام‌های مناسب را برای دو اکتور سابقه‌ی دانشجو ارسال می‌کند. یکی از اکتورهای سابقه به این دلیل که نمره‌ی کمتر از ۱۰ (۷) دارد، بلافاصله پاسخ را برای اکتور مقصد ارسال می‌کند. اکتور سابقه‌ی دیگر با توجه به اینکه نمره‌ی قبولی دارد،‌ برای اطمینان از اینکه مربوط به همان درسی است که گذرانده شدن آن بررسی می‌شود، یک پیغام به اکتور ارائه ارسال می‌کند. اکتور ارائه پیغام را به درس منتقل می‌کند و اکتور درس با مقایسه‌ی درس موجود در پیغام با خودش، جواب را برای مقصد می‌فرستد.
\FloatBarrier
\subsubsection{بررسی گذرانده شدن پیش‌نیازهای درس}
اکتور دانشجو با دریافت پیغام بررسی گذرانده شدن پیش‌نیازهای درس، محاسبات مربوطه را به اکتوری که به این منظور طراحی شده ارسال می‌کند. با توجه به اینکه پیش‌نیازهای هر درس نیز خود از نوع درس هستند، در طراحی این بخش می‌توان از اکتور بررسی گذرانده شدن درس استفاده کرد. بنابراین اکتور مذکور به ازای هر کدام از پیش‌نیازهای درس، یک پیغام بررسی گذرانده شدن درس به دانشجو ارسال می‌کند. با دریافت هر پاسخ اگر مشخص شود که درسی از میان پیش‌نیازها گذرانده نشده است، بلافاصله پاسخ درخواست به مقصد (اکتور اخذ درس) ارسال می‌شود. در غیر این صورت پس از گرفتن تمام پاسخ‌ها، یک پیغام به اکتور اخذ درس ارسال می‌کند و به وسیله‌ی آن اعلام می‌کند که تمام پیش‌نیازها گذرانده شده است.
\begin{figure}[ht]
    \begin{center}
	\includegraphics[width=14cm]{4-ProposedFramework/Figures/Prerequisites.pdf}
    \end{center}
    \caption{\label{fig:take_course_pres}نمایش شماتیک تبادل پیغام بین اکتورهای مختلف برای بررسی گذرانده شدن پیش‌نیازها‌ی یک درس }
\end{figure}
شکل \ref{fig:take_course_pres} ارتباط اکتورها برای بررسی گذرانده شدن درس را نشان می‌دهد. در این شکل، ابتدا اکتور اخذ درس پیغام بررسی گذرانده شدن درس c1 را به اکتور دانشجو ارسال می‌کند. اکتور دانشجو بررسی این مورد را به اکتور بررسی پیش‌نیاز\LTRfootnote{PassPresActor} واگذار می‌کند. این اکتور به ازای هر کدام از پیش‌نیاز‌های  درس، یک پیغام بررسی گذرانده شدن درس برای خود دانشجو ارسال می‌کند. طراحی مورد بررسی گذراندن درس در بخش \ref{subsection:passCourse} توضیح داده شد. در این شکل برای جلوگیری از پیچیدگی طراحی، از نمایش نحوه‌ی بررسی گذرانده شدن درس صرف نظر شده است و اکتورها و پیغام‌های مربوط به آن به صورت شکل ابر نمایش داده شده است.

\FloatBarrier
\subsubsection{بررسی عدم اخذ مجدد درس}
همان‌طور که در بخش \ref{section:takeCourse} توضیح داده شد، اکتور اخذ درس یک پیغام برای بررسی عدم اخذ مجدد درس برای اکتور دانشجو ارسال می‌کند. اکتور دانشجو مطابق حالت‌های قبل بررسی این مورد را به اکتور بررسی اخذ درس\LTRfootnote{CourseTakenCheckActor} واگذار می‌کند. بررسی  اخذ شدن درس کاملاً مشابه بررسی گذرانده شدن درس است. در بررسی گذرانده شدن درس، اکتور سابقه نمره را بررسی می‌کند، در صورتی که نمره قبولی نباشد جواب را ارسال می‌کند و در صورتی که نمره قبولی باشد برای بررسی اینکه درس مربوط به سابقه همان درس مورد سؤال است یا خیر، با اکتور ارائه تبادل پیغام انجام می‌دهد. در بررسی عدم اخذ مجدد درس، از هر اکتور سابقه سؤال می‌شود که آیا سابقه مربوط به ترم جاری است یا خیر. برای اینکه  یک سابقه مربوط به ترم جاری باشد، کافی است نمره‌ای برای آن اعلام ثبت نشده باشد. بنابراین اکتور سابقه بررسی می‌کند که نمره‌ای برایش ثبت شده یا خیر اگر مقدار فیلد نمره null باشد یعنی مربوط به ترم جاری است و برای بررسی اینکه مربوط به همان درس مورد سؤال است مانند حالت بررسی گذرانده شدن درس، یک پیغام به ارائه ارسال می‌کند. در غیر این صورت حتماً جواب منفی است و بلافاصله یک پیغام برای اکتور بررسی عدم اخذ مجدد ارسال می‌شود. شکل  \ref{fig:take_course_taken} تبادل پیغام بین اکتورها برای بررسی این شرط را نشان می‌دهد. همان‌طور که مشاهده می‌شود این شکل بسیار شبیه به شکل \ref{fig:take_course_haspassed} است که بررسی گذرانده شدن درس را نشان می‌دهد.

\begin{figure}[ht]
    \begin{center}
	\includegraphics[width=14cm]{4-ProposedFramework/Figures/HasTaken.pdf}
    \end{center}
    \caption{\label{fig:take_course_taken}نمایش شماتیک تبادل پیغام بین اکتورهای مختلف برای بررسی عدم اخذ مجدد درس }
\end{figure}




%
%\FloatBarrier
%\subsubsection{بررسی عدم اخذ بیش از ۲۰ واحد}
%در بخش طراحی اکتور اخذ درس (بخش \ref{section:takeCourse}) دیدیم که اکتور اخذ درس برای بررسی این شرط که تعداد واحدهای اخذ شده بیشتر از ۲۰ نشود، یک اکتور به این منظور ایجاد می‌کند. این اکتور با بررسی این شرط نتیجه را به صورت پیغام UnitsValidationResponse برای اکتور اخذ درس ارسال می‌کند. طراحی این کارکرد به این صورت است که اکتور مورد نظر از تمام سابقه‌های ترم درخواست می‌کند تا در صورتی که مربوط به ترم جاری هستند، تعداد واحدهای درس مربوط به خود را ارسال کنند. همان‌طور که در بخش قبل توضیح داده شد، اینکه سابقه مربوط به ترم جاری است از null بودن فیلد نمره مشخص می‌شود. بنابراین اگر فیلد نمره null نباشد اکتور سابقه عدد صفر را به عنوان تعداد واحد ارسال می‌کند. در غیر این صورت مشابه‌ حالت‌های قبل یک پیغام برای اکتور درس (از طریق اکتور ارائه) ارسال می‌کند تا تعداد واحدها را به اکتور مقصد (اکتور بررسی عدم اخذ بیش از ۲۰ واحد) ارسال کند. اکتور مذکور با گرفتن هر پیغام تعداد واحدها را بروزرسانی می‌کند و با اتمام پیغام‌ها بررسی می‌کند که آیا جمع واحدها بیش از ۲۰ است یا خیر. در نهایت پاسخ را برای اکتور اخذ درس ارسال می‌کند. شکل \ref{fig:take_course_units} همکاری اکتورها برای بررسی این  شرط را به صورت شماتیک نشان می‌دهد.
%
%\begin{figure*}
%    \begin{center}
%	\includegraphics[width=14cm]{4-ProposedFramework/Figures/NumOfUnits.pdf}
%    \end{center}
%    \caption{\label{fig:take_course_units}نمایش شماتیک تبادل پیغام بین اکتورهای مختلف برای بررسی عدم اخذ بیش از ۲۰ واحد}
%\end{figure*}
%


\chapter{روش طراحی و الگوها}
\label{chapter:RelatedWork}
%\section{روش طراحی و الگوها}
%TODO fix references to chapters
در بخش‌های پیشین  یک سیستم نمونه معرفی شد و پس از توصیف موارد کاربرد آن، روش طراحی آن با استفاده از مدل تبادل ناهمگام پیغام بررسی شد. در ادامه‌ی این فصل تلاش می‌شود با توجه به تجربیات حاصل از انجام این طراحی، روش معرفی شده به صورت نظام‌مند معرفی شود. در قسمت اول از این بخش، قدم‌های لازم برای طراحی یک سیستم به روش تبادل ناهمگام پیغام ذکر شده و در موارد ممکن، از قسمت‌هایی از سیستم طراحی شده به عنوان نمونه بهره گرفته شده است. در قسمت بعد تلاش شده الگوهای کلی هماهنگی اکتورها با تمرکز بر خواص منطق دامنه بررسی شود. در بخش بعد قسمتی از تجربیات حاصل از بررسی رویکردهای متعدد برای طراحی سیستم نمونه (سیستم آموزش ساده) ارائه شده است. نهایتاً در بخش پایانی بحث مختصری در مورد نکات برنامه‌نویسی در هنگام پیاده‌سازی سیستم مطرح شده است.


%\subsection{ارتباط طراحی شیءگرا و طراحی به روش تبادل ناهمگام پیغام}

\section{گام‌های طراحی به روش تبادل ناهمگام پیغام }
\label{section:design_steps}
روش بررسی شده در این پژوهش ارتباط تنگاتنگی با مبحث طراحی شیءگرا دارد. طراحی شیءگرا با استفاده از لفافه‌بندی\LTRfootnote{encapsulation} اشیاء منجر به تفکیک واسط کارکردی یک شیء از حالت محلی آن می‌شود و جزئیات پیاده‌سازی رفتار را مخفی ‌می‌کند. این خاصیت منجر به افزایش امکان استدلال در مورد نحوه‌ی طراحی اشیاء می‌شود. در این روش، مکانیزم کنترل اجرای برنامه‌ها فراخوانی متد است. روش تبادل ناهمگام به تفکیک کنترل اجرای منطق برنامه از زمان اجرای آن می‌پردازد. به این ترتیب قابلیت افزودن همروندی در طراحی را اضافه می‌کند. آلن کِی در \cite{Kay_messaging} اظهار داشته است که ایده‌ی اصلی در طراحی شیءگرا، ارسال پیغام بوده است. و این مسئله ارتباط تنگاتنگ طراحی شیءگرا و طراحی مبتنی بر تبادل ناهمگام پیغام را نشان می‌دهد.\\
بنابراین بسیاری از ایده‌های طراحی و تحلیل شیءگرا عیناً در این روش نیز کاربرد دارند. به همین دلیل در ارائه‌ی روش طراحی به بررسی جزئیات مواردی که دقیقاً مشابه طراحی شیءگرا هستند پرداخته نشده است. علاوه بر این، در ارائه‌ی روش فرض شده که خروجی‌های تحلیل سیستم موجود هستند. طبیعتاً روش‌های تحلیل شیءگرا و کسب شناخت از سیستم تحت طراحی، عیناً قابل اعمال در این نوع طراحی هستند. در گام‌های ذکر شده برای طراحی به روش تبادل ناهمگام، بعضی از گام‌ها مربوط به خروجی‌های تحلیل سیستم هستند که برای حفظ انسجام، توضیح داده شده‌اند. با توجه به این موارد، در این بخش گام‌های طراحی به روش تبادل پیغام را ارائه می‌کنیم:

\subsection{شناخت سیستم و تشخیص اکتورهای دامنه}
شناخت سیستمی که باید طراحی شود پیش از شروع به طراحی لازم است. فعالیت‌های مربوط به این بخش مشابه همین فعالیت‌ها در روش‌های تحلیل نیازمندی‌ها و کسب شناخت\LTRfootnote{Inception} در متدولوژی‌های طراحی شیءگرا است و جزئیات آنها در حوزه‌ی این پژوهش نمی‌باشد. تعدادی از خروجی‌های این فعالیت‌ها از جمله توصیف موارد کاربرد سیستم و استخراج اشیاء دامنه به طور گسترده در طراحی مورد استفاده قرار می‌گیرند.
در مدل اکتور، همه‌ی موجودیت‌های سیستم اکتور هستند. بنابراین تمام اشیاء مدل دامنه‌ی سیستم که در مراحل ابتدایی طراحی و تحلیل شناسایی می‌شوند، به صورت اکتور طراحی می‌شوند. در منابع تحلیل و طراحی شیءگرا، روش‌هایی برای تشخیص اشیاء دامنه و نمایش مناسب آنها بیان شده است که طبیعتاً قابل اعمال در این روش نیز می‌باشند\cite{Larman_2004}. در سیستم آموزش معرفی شده، مدل دامنه در قالب نمودار کلاس در بخش \ref{subsec:mainEntities} نمایش داده شده است.
\subsection{انتخاب مورد کاربرد برای طراحی جزئیات}
با در دست داشتن موارد کاربرد و اشیاء دامنه، فعالیت‌های مربوط به طراحی اکتورهای سیستم آغاز می‌گردد. در گام اول نیاز داریم یکی از موارد کاربرد را برای طراحی انتخاب کنیم. معمولاً انتخاب مورد کاربرد با توجه به اولویت و اهمیت‌ آن صورت می‌پذیرد. پس از انتخاب مورد کابرد باید رخداد‌های سیستمی آن شناسایی شوند. این رخدادها نتیجه‌ی تعامل بازیگران خارجی با سیستم هستند. استخراج رخداد‌های سیستمی با توجه به موارد کاربرد صورت می‌گیرد. این رخدادها را می‌توان با استفاده از نمودارهای ترتیب سیستمی\LTRfootnote{system sequence diagram (SSD)} نمایش داد\cite{Larman_2004}. در نمودار ترتیب سیستمی، سیستم به صورت جعبه‌ی سیاه\LTRfootnote{black box} درنظر گرفته می‌شود و تعامل بازیگر خارجی با سیستم به صورت فرستادن درخواست و دریافت پاسخ نمایش داده می‌شود. 
به عنوان مثال شکل \ref{fig:ssd} نمودار ترتیب سیستمی را برای سناریوی اصلی مورد کاربرد محاسبه‌ی معدل نشان می‌دهد. رخدادهای سیستمی نقطه‌ی مناسبی برای شروع به طراحی اکتورها و ارتباطات آنها هستند. در طراحی شیءگرای ترتیبی، رخدادهای سیستمی در ارتباطی تنگاتنگ با متدهای یک شیء قرار دارند. در واقع نقطه‌ی آغاز اجرای محاسبات مربوط به یک رخداد سیستمی یک متد است. دلیل این پیش‌فرض این است که مکانیزم کنترل برنامه در طراح شیءگرای ترتیبی (و هر روش ترتیبی دیگر) فراخوانی متد است. در حالی که در روش مبتنی بر اکتور، مکانیزم ارتباطی تبادل پیغام است. بنابراین در این روش هر رخداد سیسستمی به یک پیغام نگاشت می‌شود که به دست یکی از اکتورها سیستم می‌رسد. 
\begin{figure*}[bh]
    \begin{center}
	\includegraphics[width=6cm]{4-ProposedFramework/Figures/ssd.pdf}
    \end{center}
    \caption{\label{fig:ssd}نمودار ترتیب سیستمی برای یک سناریو از مورد کاربرد محاسبه‌ی معدل}
\end{figure*}

\subsection{طراحی اکتور اول}
همان‌طور که در مورد قبل توضیح داده شد، در مدل طراحی اکتور، وقوع یک رخداد سیستمی، به وسیله‌ی ارسال پیغام صورت می‌گیرد. گام اول در طراحی سیستم به هدف پاسخگویی به این پیغام این است که مشخص شود کدام اکتور باید اولین پیغام را دریافت کند. این مورد در طراحی شیءگرا در قالب مفهوم \textbf{مسئولیت شیء} بیان می‌شود. در طراحی شیءگرا شیءای موظف به دریافت درخواست است که مسئولیت درخواست با آن باشد. تشخیص مسئولیت با توجه به منطق دامنه صورت می‌گیرد و بدون در نظر گرفتن منطق دامنه، قاعده‌ای برای انتخاب شیء مسئول وجود ندارد. مسئولیت اشیاء از نظر نوع به دو دسته‌ی کلی مسئولیت \textit{انجام}\LTRfootnote{Doing Responsibilities} (مانند مسئولیت ایجاد یک شیء و آغاز یک عملیات) و مسئولیت \textit{اطلاع}\LTRfootnote{Knowing Responsibilities} (مانند اطلاع از اشیاء مرتبط یا اطلاع از داده‌های محلی لفافه‌بندی شده) تقسیم می‌شود\cite{Larman_2004,rdd}.
معمولاً  مسئولیت پاسخگویی به درخواست‌های سیستمی بعد از  تهیه‌ی مدل دامنه آسان‌تر می‌شود. در سیستم بررسی شده در این پژوهش مسئولیت پاسخ‌گویی به درخواست محاسبه‌ی 
معدل اکتور دانشجو است. با مشخص شدن اکتور مسئول برای دریافت پیغام، در ادامه‌ی طراحی باید روش پردازش پیغام در اکتور مورد نظر بررسی گردد.
\subsection{منطق پردازش درخواست}
تا این مرحله از طراحی، مشخص شده است که اکتور مسئول برای دریافت پیغام درخواست کدام است. در این مرحله باید تصمیم گرفته شود که نحوه‌ی پردازش پیغام درخواست به چه صورتی خواهد بود.
 \subsubsection{تصمیم‌گیری برای انتقال پردازش درخواست به اکتور دیگر}
 \label{design:delegate}
پردازش پیغام به دو صورت کلی انجام می‌پذیرد. حالت اول این است که خود اکتور مسئولیت پردازش پیغام را بر عهده بگیرد. در این حالت اکتور مذکور یا به تنهایی قادر به انجام تمام عملیات مرتبط با درخواست دریافت شده است و یا با همکاری اکتورهای دیگر می‌تواند منطق مربوط به درخواست را اجرا کند. 

حالت دوم  به این صورت است که اکتور تصمیم بگیرد که اکتور جدیدی را به منظور پردازش این درخواست ایجاد کند و تمام عملیات مربوط به درخواست را به این اکتور واگذار کند. حالت مشابه‌ این مورد در طراحی شیءگرای ترتیبی نیز رخ می‌دهد. در طراحی شیءگرا ممکن است به دلیل جلوگیری از افزایش پیچیدگی کلاس و  حفظ قابلیت تغییر، تمام کار پردازش یک درخواست را به کلاس دیگری که به همین منظور ایجاد می‌شود منتقل کند. در روش طراحی مبتنی بر تبادل ناهمگام، علاوه بر این مورد به دلیل دیگری نیز این تصمیم اتخاذ می‌شود. این مسئله در ادامه در قالب یک مثال توضیح داده می‌شود:\\
فرض کنید یک مدل دامنه از ۳ اکتور تشکیل شده باشد. اکتور A که یک متغیر محلی عددی به نام a دارد. این اکتور یک نوع پیغام دریافت می‌کند: پیغام getA که در پاسخ آن مقدار a را ارسال می‌کند. اکتور B به طور مشابه یک متغیر محلی عددی به نام b دارد و با دریافت پیغام getB مقدار b را ارسال می‌کند. اکتور سوم Sum نام دارد که با دریافت پیغام sum باید مجموع مقادیر a و b را ارسال کند. اکتور Sum چون از مجموع a و b اطلاع ندارد برای پاسخ به پیغام sum نیاز به همکاری A و B دارد. فرض کنیم اکتور Sum به این شکل طراحی می‌شود که با دریافت پیغام sum ابتدا متغیرهای محلی s و count را صفر می‌کند و سپس پیغام‌های getA و getB را برای اکتورهای A و B ارسال می‌کند با دریافت هر پاسخ مقدار count را یکی زیاد می‌کند و متغیر s را با عدد دریافت شده جمع می‌کند. بعد از دریافت هر پاسخ و بروزرسانی متغیرهای داخلی، اگر مقدار count برابر با عدد ۲ شد (یعنی هر دو پاسخ دریافت شده است) مقدار متغیر s (حاصل‌جمع) را به عنوان پاسخ درخواست ارسال می‌کند. شکل \ref{fig:coord1} همکاری این ۳ اکتور برای پاسخ به درخواست sum را نشان می‌دهد.
\begin{figure*}[h]
    \begin{center}
	\includegraphics[width=10cm]{4-ProposedFramework/Figures/ExampleCoord1.pdf}
    \end{center}
    \caption{\label{fig:coord1} همکاری موفق اکتورها برای پاسخ به درخواست مجموع a و b}
\end{figure*}
مشکل این طراحی زمانی مشخص می‌شود که اکتور Sum بعد از دریافت پاسخ‌ A و قبل از دریافت پاسخ B یک درخواست sum دیگر دریافت می‌کند. اکتور Sum برای پاسخ به این درخواست مقدار متغیرهای s و count را صفر می‌کند و دو پیغام جدید برای A و B ارسال می‌کند. در این هنگام اکتور Sum پاسخ B برای درخواست اول را دریافت می‌کند اما چون مقدار متغیر count صفر است، متوجه اتمام عملیات درخواست اول نمی‌شود. شکل \ref{fig:coord2} این حالت را نمایش می‌دهد.
\begin{figure*}[h]
    \begin{center}
	\includegraphics[width=8cm]{4-ProposedFramework/Figures/ExampleCoord2.pdf}
    \end{center}
    \caption{\label{fig:coord2} مشکل پیغام‌های همروند در همکاری اکتورها برای پاسخ به درخواست مجموع a و b}
\end{figure*}
مثال شکل \ref{fig:coord2} نشان می‌دهد که در طراحی به روش تبادل ناهمگام پیغام، در صورتی که نیاز به همکاری بین اکتورها وجود داشته باشد، ممکن است درخواست‌های همروند موجب تداخل در محاسبات همدیگر بشوند. این مشکل زمانی پیش می‌آید که شرایط زیر برقرار باشند:\\
 \begin{enumerate}
 \item برای پاسخ به یک درخواست، اکتور مجبور به همکاری با سایر اکتورها باشد.
 \item همکاری به ارسال پیغام به سایر اکتورها ختم نشود و در ادامه لازم باشد پاسخ آنها دریافت شود. 
 \item ارسال پیغام‌ها به صورت ناهمگام انجام شود. به این معنی که اکتور مورد نظر پس از ارسال پیغامهای مربوطه بتواند بدون توقف برای دریافت پاسخ‌ها به پردازش سایر پیغام‌ها بپردازد.
 \item اکتور با دریافت هر کدام از پاسخ‌ها متغیر(های) محلی خود را بروزرسانی کند.
 \end{enumerate}
راه حل مشکل:\\
برای حل این مشکل در زمان طراحی چند گزینه پیش رو داریم:
\begin{itemize}
\item گزینه‌ی اول این است که به جای ارسال ناهمگام پیغام‌های مربوط به یک درخواست، عمل تبادل پیغام را به صورت همگام انجام دهیم. در این حالت اطمینان حاصل می‌شود که درخواست جدید قبل از اتمام عملیات درخواست قبلی پردازش نمی‌شود. ایراد این روش این است که باعث محدودیت در همروندی سیستم می‌گردد.
\item راه دوم این است که به گونه‌ای متغیرهای حالت را نگهداری کنیم که با پردازش درخواست‌های همروند دچار مشکل نشوند. برای این کار نیاز داریم تا متغیرهای حالت را برای درخواست‌های پردازش شده اختصاصی کنیم. در مثال معرفی شده در  شکل \ref{fig:coord1} این کار به این صورت انجام می‌شود که به جای متغیر‌های s و count برای هر درخواست متغیر جدیدی در نظر بگیریم. طبیعتاً این روش منجر به ایجاد پیچیدگی در زمان پیاده‌سازی می‌شود و همچنین تضمین محافظت از متغیرها کار دشواری خواهد بود.
\item
 راه مناسب برای حل این مشکل این است که تمام عملیات مربوط به درخواست دریافت شده، به یک اکتور دیگر که فقط وظیفه‌ی پاسخ به این درخواست را دارد منتقل شود. به این روش هم مشکل متغیر‌های حالت محلی به وجود نمی‌آید و هم همروندی سیستم محدود نمی‌شود. طبیعتاً برای جلوگیری از تکرار همین مشکل برای اکتور جدید باید به ازای هر درخواست مشابه یک نمونه‌ی جدید از اکتور مذکور ایجاد کنیم.\\
بنابراین در طراحی به روش تبادل ناهمگام پیغام علاوه‌ بر جلوگیری از پیچیدگی و بزرگ شدن بیش از حد کلاس، ممکن است به دلیل ایجاد امکان پردازش درخواست‌های همروند نیز تصمیم به واگذاری درخواست به اکتوری جدید نماییم.
 در طراحی سیستم آموزش که در بخش‌های قبل توضیح داده شد، در موارد متعددی از جمله در مورد کاربرد محاسبه‌ی معدل (بخش \ref{gpa_approch2}) این الگو مشاهده شد.

\end{itemize}
\subsubsection{پردازش پیغام بدون همکاری با سایر اکتورها}
 مستقل از این موضوع که پردازش یک درخواست توسط خود اکتور انجام می‌شود یا به اکتور جدیدی منتقل می‌شود، در طراحی سیستم باید مشخص شود که منطق مربوط به یک درخواست چگونه پیاده‌سازی خواهد شد. ساده‌ترین حالت برای اجرای منطق مربوط به یک درخواست این است که اکتور دریافت کننده، بتواند بدون همکاری با سایر اکتورها عملیات لازم را انجام دهد و در صورت لزوم پاسخ درخواست را ارسال کند. این حالت زمانی رخ می‌دهد که اکتور تمام اطلاعات لازم برای اجرای منطق مربوطه را در حالت خود داشته باشد.
 در این حالت اکتور پس از دریافت پیغام، منطق مربوط به آن را انجام می‌دهد و در صورت لزوم پاسخ مناسب را برای مقصد ارسال می‌کند. ممکن است حالت اکتور پس از  پردازش این پیغام تغییر کند. شکل \ref{fig:no_collaboration} این حالت را نشان می‌دهد.
 \begin{figure*}[h]
    \begin{center}
	\includegraphics[width=6cm]{4-ProposedFramework/Figures/NoCollaboration.pdf}
    \end{center}
    \caption{\label{fig:no_collaboration} پردازش پیغام بدون همکاری با سایر اکتورها}
\end{figure*}

\subsubsection{پردازش پیغام به وسیله‌ی همکاری با سایر اکتورها}
در بخش قبل ذکر شد که ممکن است یک اکتور با دریافت یک پیغام درخواست، قادر باشد بدون برقراری ارتباط با سایر اکتورها پاسخ درخواست را بدهد. در مواردی که اکتور دریافت کننده، اطلاعات مورد نیاز برای پردازش درخواست را در اختیار نداشته باشد، باید با اکتورهای دیگر ارتباط برقرار کند. برای برقراری ارتباط با سایر اکتورها از تبادل پیغام استفاده می‌شود. در برقراری ارتباط با سایر اکتورها نکات زیر باید در نظر گرفته شوند:\\
\begin{itemize}
\item بررسی اینکه تبادل پیغام به صورت همگام صورت گیرد یا ناهمگام:\\
یک عامل مهم در این تصمیم‌گیری منطق مربوط به پردازش پیغام است. در برخی موارد گزینه‌ای جز همگام‌سازی پیغام‌ها وجود ندارد. مثلاً اگر منطق مورد نظر احتیاج به پردازش به ترتیب زمانی داشته، و برای هر بخش آن نیاز به برقراری ارتباط با سایر اکتورها وجود داشته باشد، و یا  اطلاعات مورد نیاز برای یک مرحله از پردازش پیغام، وابسته به نتیجه‌ی مرحله‌ی قبل باشد، ملزم به استفاده از تبادل همگام پیغام هستیم. البته این به این مفهوم نیست که فقط در این حالت می‌توان از پیغام همگام استفاده کرد. در واقع استفاده از ارتباط همگام، هیچ محدودیت ذاتی در مدل اکتور ندارد. حتی در این روش می‌توان یک مدل ترتیبی را با نگاشت هر متد از شیء به یک ارتباط همگام، به صورت مدل اکتور طراحی کرد. در این حالت با اینکه هر اکتور به صورت همروند اجرا می‌شود، در اجرای برنامه همروندی وجود نخواهد داشت.
بنابراین از ارتباط ناهمگام برای ایجاد همروندی در پردازش درخواست‌ها استفاده می‌شود.
\item بررسی اینکه پیغام پاسخ در چه زمانی و توسط چه اکتوری ارسال شود:\\
پردازش یک پیغام ممکن است نیازی به ارسال پاسخ نداشته باشد. این نوع پیغام‌ها ممکن است صرفاً برای ایجاد تغییر در سیستم ارسال شوند و فرستنده نیازی به اطلاع از نتیجه نداشته باشد. در این حالت پس از پردازش پیغام، عملیات مربوط به آن تمام می‌شود. اما در بیشتر موارد ارسال کننده‌ی درخواست نیاز به اطلاع از نتیجه‌ی کار دارد و یا اطلاعاتی را درخواست کرده که باید به صورت پاسخ دریافت کند. در این موارد باید یک پاسخ هم برای فرستنده‌ی درخواست ارسال شود. یک تفاوت مهم مدل اکتور با مدل طراحی شیءگرای ترتیبی،‌ در این است که در مدل ترتیبی، پاسخ یک درخواست الزاماً توسط همان شیءای داده می‌شود که درخواست به آن داده شده است. البته باید دقت شود که در اینجا منظور این نیست که کل پردازش درخواست را شیء مذکور انجام می‌دهد. بلکه منظور این است که نهایتاً نتیجه‌ی کار از همان متدی بازگشت داده می‌شود که فراخوانی شده است. اما در مدل اکتور به دلیل همروندی سیستم،‌ پیغام پاسخ می‌تواند توسط هر کدام از اکتورهای همکاری کننده ارسال شود. بنابراین در طراحی به این روش باید دقت کرد که طراحی را مقید به این نکنیم که دریافت کننده‌ی یک پیغام حتماً پاسخ‌ آن را بدهد. در رویکرد دوم طراحی مورد کاربرد معدل (بخش \ref{gpa_approch2}) به طور مفصل به این مورد پرداخته شده است.
\item استفاده از الگوهای همکاری اکتورها:\\
برای اینکه چند اکتور بتوانند باهم همکاری کرده و پاسخ یک درخواست را ارسال کنند راهکارهای طراحی متعددی وجود دارد که برخی از آنها در طراحی سیستم آموزش در بخش‌های قبل ذکر شده است. برخی از این روش‌ها به دلیل تکرار در حالت‌های زیاد و قابلیت استفاده‌ی مجدد، حالت الگو به خود می‌گیرند. در بخش‌های بعد تعدادی از این الگوها معرفی شده است.
\item انتخاب اکتورهای مقصد برای پیغام‌های مربوط به درخواست\\
 پس از طراحی مدل همکاری (با استفاده از الگوهای همکاری اکتورها)، باید تبادل پیغام بین اکتورهایی که همکاری می‌کنند، طراحی شود. گام اول در این طراحی انتخاب مقصد پیغام است. این کار با بررسی مسئولیت‌های اکتورها با توجه به منطق دامنه انجام می‌شود. در صورتی که هیچ یک از اکتورهایی که تا این مرحله طراحی شده‌اند مسئول پردازش پیغام تشخیص داده نشوند،‌ باید اکتور جدیدی برای پردازش پیغام طراحی شود.
\item طراحی قالب پیغام‌های مربوط به درخواست\\
در این مرحله از طراحی باید پیغام‌های مربوط به منطق یک درخواست طراحی شده و ارسال شوند. در طراحی یک پیغام نکات زیر باید مورد توجه قرار گیرد:
\begin{itemize}
\item نام پیغام متناسب با عملکرد آن در نظر گرفته می‌شود. 
به طور کلی در طراحی شیءگرا توصیه می‌شود که نام کلاس‌ها و متدها متناسب با عملکرد و مسئولیت کلاس در نظر گرفته شود.
\item اطلاعات مورد نیاز سایر اکتورهایی که پیغام به دست‌ آنها خواهد رسید در پیغام قرار داده شود.
اطلاعات قرار داده شده در پیغام به چند دسته تقسیم می‌شوند:\\
\begin{enumerate}
\item مقدار متغیر‌های محلی اکتور\\
 این اطلاعات زمانی در پیغام قرار داده می‌شوند که اکتور دیگری برای ادامه‌ی محاسبات نیاز به دسترسی به آنها داشته باشد. به عنوان مثال در رویکرد دوم محاسبه‌ی معدل (بخش \ref{gpa_approch2}) اکتور سابقه، با دریافت پیغام GPAInfoRequest مقدار نمره‌ی سابقه را در بخشی از پیغام قرار می‌دهد و برای اکتور درس ارسال می‌کند.
\item نام (آدرس) اکتورهایی که با این اکتور در ارتباط هستند\\
اکتوری که پیغام برای آن ارسال می‌شود ممکن است برای ادامه‌ی پردازش، نیاز به دسترسی به اکتور دیگری داشته باشد. اگر فرستنده‌ی پیغام به این اکتور دسترسی داشته باشد، می‌تواند نام آن را در پیغام قرار دهد تا اکتور دیگر بتواند با آن ارتباط برقرار کند.
\item قرار دادن مقصد نهایی درخواست در پیغام\\
اگر بخواهیم هر کدام از اکتورهای دریافت کننده‌ی پیغام بتوانند پاسخ نهایی درخواست را ارسال کنند، باید نام اکتور گیرنده‌ی پاسخ نهایی در قالب پیغام قرار داده شود.
\end{enumerate}
\end{itemize}
\item منطق پردازش پاسخ(ها)\\
در صورتی که در مدل همکاری انتخاب شده، اکتور فرستنده‌ی پیغام‌های مربوط به درخواست، موظف به گرفتن پاسخ آنها نیز باشد، در این مرحله باید منطق پردازش پاسخ‌ها طراحی گردد. این منطق ممکن است شامل ارسال پیغام‌های جدید، یا بروزرسانی متغیرهای حالت باشد و در ساده‌ترین حالت ممکن است ارسال همان پاسخ به اکتوری دیگر باشد.
\end{itemize}

\subsection{طراحی سایر اکتورها}
در صورتی که در طراحی منطق پردازش درخواست، تصمیم گرفته شود که اکتور مسئول، پیغام پاسخ درخواست را بدون همکاری با سایر اکتورها ارسال کند، در این مرحله طراحی رخداد سیستمی مورد کاربرد انتخاب شده به اتمام می‌رسد و گام‌های طراحی برای رخداد سیستمی بعدی (یا مورد کاربرد بعدی) تکرار می‌شود. در غیر این صورت 
(در طراحی منطق پردازش درخواست، تصمیم به ارسال پیغام به سایر اکتورها گرفته شده باشد) طراحی اکتورهای گیرنده از گام ``منطق پردازش درخواست'' ادامه می‌یابد.

\section{الگوهای طراحی}
در این بخش تعدادی از الگوهایی که می‌توانند در طراحی به روش تبادل ناهمگام پیغام به کار گرفته شوند گردآوری و ارائه شده است. ذکر چند نکته‌ی مقدماتی در این بخش ضروری به نظر می‌رسد:
\begin{enumerate}
\item در ابتدا باید تأکید شود که هر چند نکات این بخش تحت عنوان الگوی طراحی ارائه شده‌اند، اما به معنای دقیق کلمه از دیدگاه مهندسی نرم‌افزار، همردیف الگوهای طراحی (مشابه الگوهای طراحی شیءگرا\cite{GOF})  نیستند. دلیل این امر این است که اولاً الگوهای طراحی، باید دارای نامگذاری دقیق و نظام‌مند باشند تا بتوان از آن‌ها به عنوان زبان مشترکی بین طراحان و برنامه‌نویسان روش مورد بحث استفاده کرد. ثانیاً الگوهای طراحی در اثر تجربیات طراحی و پیاده‌سازی‌های متعدد و  ارزیابی‌های دقیق حاصل می‌شوند. این درحالی‌ است که اولاً این بخش از این پژوهش، اولین تلاش در راستای استخراج الگوهای طراحی در این روش است که در آن بیشتر تجربیات در اثر طراحی و پیاده‌سازی یک سیستم آزمایشی به دست آمده است و به همین دلیل احتمالاً از شمول و پختگی کافی برخوردار نیست و ثانیاً نام‌گذاری این الگوها فرایند حساسی‌ است که از حوزه‌ی این پژوهش خارج است. 
\item در بخش اول این فصل الگوهای طراحی منطق پردازش یک درخواست در اکتورها ارائه می‌شود. در اینجا منظور از درخواست، پیغامی است که آغاز کننده‌ی یک فعالیت در اکتور است.  همان طور که در بخش \ref{section:design_steps} ذکر شد، برای یک اکتور در قبال دریافت یک درخواست دو رویکرد می‌توان متصور بود: حالت اول این است که اکتور مورد نظر به تنهایی بتواند عملیات مربوط به درخواست را اجرا کند، و حالت دوم این است که نیاز به همکاری با سایر اکتورها داشته باشد. طبیعتاً طراحی حالت اول بسیار ساده بوده و نیازی به ارائه‌ی الگو برای آن وجود ندارد. بنابراین در این فصل الگوهایی بررسی می‌شوند که در آنها بیش از یک اکتور در پردازش یک درخواست درگیر باشند.
\item الگوهای ذکر شده ممکن است با الگوهای کلی طراحی همروند (مانند الگوی خط-لوله که در بخش \ref{section:actorPatterns} معرفی شد) در ارتباط باشند اما در این فصل بیشتر تأکید روی ارائه‌ی خواص الگوها و تناسب آنها با منطق دامنه است.
\item تقسیم‌بندی الگوها بر اساس مسئولیت اکتور دریافت کننده‌ی درخواست در پردازش منطق صورت گرفته است. 
%TODO چرا این تقسیم بندی؟ در واقع دسته‌ی اول اونایی هستند که قطعا نیازی به همگام‌سازی و اینا ندارن
\end{enumerate}

\subsection{دسته‌ی اول}
دسته‌ی اول الگوهای طراحی، الگوهایی هستند که در آن اکتور دریافت کننده‌ی درخواست پس از ارسال پیغام‌های لازم مسئولیت دیگری در اجرای درخواست نخواهد داشت. شکل \ref{fig:Patterns_stateless} حالت کلی این الگوها را نشان می‌دهد.

\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=8cm]{4-ProposedFramework/Figures/Patterns_stateless.pdf}
    \end{center}
    \caption{\label{fig:Patterns_stateless}توصیف کلی الگوهایی که در آن اکتور دریافت کننده‌ی درخواست پس از ارسال پیغام(ها) مسئولیتی در پردازش درخواست ندارد.}
\end{figure*}

\subsubsection{الگوی ۱ (انتقال یا تحویل)}
در این حالت درخواست مربوطه صرفاً پیغامی‌ است که باید تحویل یکی از اکتورهایی شود که اکتور دریافت کننده‌ی درخواست به آن دسترسی دارد. این درخواست حالت اکتور دریافت کننده‌ی درخواست را عوض نمی‌کند ولی ممکن است حالت اکتور بعدی را عوض کند. شکل \ref{fig:Patterns_stateless_forward} این الگو را نمایش می‌دهد.\\

\textbf{نحوه‌ی پیاده‌سازی:}\\
اکتور با دریافت درخواست،‌ همان پیغام درخواست شده را به اکتور مقصد ارسال می‌کند. تنها تغییری که ممکن است در پیغام رخ بدهد، نام پیغام است.\\
\textbf{موارد استفاده:}\\
این الگو در مواردی استفاده می‌شود که اکتور درخواست کننده به اکتور مقصد دسترسی مستقیم ندارد بلکه این دسترسی از طریق یک اکتور واسط فراهم می‌شود.

\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=8cm]{4-ProposedFramework/Figures/Patterns_stateless_forward.pdf}
    \end{center}
    \caption{\label{fig:Patterns_stateless_forward}الگوی ۱ (انتقال یا تحویل)}
\end{figure*}

\subsubsection{الگوی ۲ (انتشار)}
این الگو مشابه الگوی قبل است با این تفاوت که پیغام برای تعداد بیشتری از اکتورهای در ارتباط با اکتور جاری ارسال می‌شود. شکل \ref{fig:Patterns_stateless_broadcast} این الگو را نمایش می‌دهد.\\
\textbf{نحوه‌ی پیاده‌سازی:}\\
اکتور با دریافت پیغام، آن را برای اکتورهای مقصد به طور ناهمگام ارسال می‌کند.\\
\textbf{موارد استفاده:}\\
این الگو در مواردی استفاده می‌شود که اکتور دریافت کننده‌ی درخواست، لیستی از اکتورهای دیگر در اختیار دارد که اکتور درخواست کننده به طور مستقیم دسترسی به آنها ندارد.

\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=8cm]{4-ProposedFramework/Figures/Patterns_stateless_broadcast.pdf}
    \end{center}
    \caption{\label{fig:Patterns_stateless_broadcast}الگوی ۲ (انتشار)}
\end{figure*}




\subsubsection{الگوی ۳ (وکالت)}
\label{pattern:delegate}
همان‌طور که در بخش \ref{design:delegate} توضیح داده شد، در کاربردهای زیادی اکتور دریافت کننده‌ی درخواست تصمیم می‌گیرد کل عملیات مربوط به اجرای یک درخواست را به اکتور دیگری منتقل کند. الگوی ۳ این کاربرد را نشان می‌دهد. شکل \ref{fig:Patterns_stateless_delegate} این الگو را نمایش می‌دهد.\\
\textbf{نحوه‌ی پیاده‌سازی:}\\
 اکتور دریافت کننده‌ی درخواست، اکتور جدید را ایجاد می‌کند و اطلاعات لازم از جمله خود پیغام درخواست، فرستنده‌ی درخواست و متغیرهای حالت محلی و نیز دسترسی‌های لازم به سایر اکتورها را در اختیار اکتور جدید قرار می‌دهد. اینکه کدام یک از  این اطلاعات برای انجام کار ضروری است بستگی به منطق دامنه دارد. در اکثر موارد عمر اکتور جدید محدود به پردازش درخواست است.\\
 \textbf{موارد استفاده:}\\
این الگو زمانی استفاده می‌شود که اکتور اصلی دریافت کننده‌ی درخواست، به دلایلی از جمله کاهش پیچیدگی و یا حفظ قابلیت پردازش درخواست‌های همروند کل پردازش درخواست را به اکتور دیگری منتقل کند. در طراحی مورد کاربرد اخذ درس، پردازش پیغام درخواست اخذ درس مثالی از این الگو است (مراجعه کنید به بخش \ref{subsection:take_course_uc_design}).
\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=10cm]{4-ProposedFramework/Figures/Patterns_stateless_Delegate.pdf}
    \end{center}
    \caption{\label{fig:Patterns_stateless_delegate}الگوی ۳ (وکالت)}
\end{figure*}

\subsubsection{الگوی ۴}
در این الگو اکتور برای پردازش درخواست، نیازمند به ارسال پیغامی دیگر به یکی از اکتورهای مرتبط است. تفاوت این نوع درخواست با درخواستی که در الگوی ۱ معرفی شد این است که در الگوی ۱ درخواست متعلق به اکتوری بود که اکتور دریافت کننده‌ی درخواست به آن دسترسی داشت. بر خلاف الگوی ۱، در این الگو درخواست به اکتور دریافت کننده مربوط است اما این اکتور تمام اطلاعات لازم برای پردازش پیغام را در اختیار ندارد (یا پردازش فقط مربوط به اکتور اول نیست). شکل \ref{fig:Patterns_stateless_4} این الگو را نمایش می‌دهد.\\
\textbf{نحوه‌ی پیاده‌سازی:}\\
 در این الگو، دریافت کننده‌ی پیغام، محاسبات مربوط به خود را انجام می‌دهد و اطلاعات لازم را در اختیار اکتور بعدی قرار می‌دهد. \\
 \textbf{موارد استفاده:}\\
این الگو در مواردی که درخواست حالت مرحله‌ای دارد (مانند الگوی خط-لوله) مفید واقع می‌شود. مثالی از این الگو، درخواست بررسی قبولی درس، در مورد کاربرد اخذ درس (بخش \ref{section:takeCourse}) است.
\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=10cm]{4-ProposedFramework/Figures/Patterns_stateless_4.pdf}
    \end{center}
    \caption{\label{fig:Patterns_stateless_4}الگوی ۴}
\end{figure*}

\subsubsection{الگوی ۵ (انشعاب)}
در این الگو اکتور برای پردازش درخواست، نیازمند به ارسال پیغام به اکتورهای دیگر است ولی تصمیم گرفته می‌شود که پاسخ‌های اکتورهای مذکور به اکتور دیگری فرستاده شود. در واقع به جای اینکه انشعاب و الحاق در یک اکتور صورت بگیرد، این دو مرحله از هم جدا شده‌اند. شکل \ref{fig:Patterns_stateless_fj} این الگو را نمایش می‌دهد.\\
\textbf{نحوه‌ی پیاده‌سازی:}\\
عمل انشعاب به وسیله‌ی ارسال پیغام (ناهمگام) به تمام اکتورهای مربوطه انجام می‌پذیرد. در صورتی که نیاز به ایجاد اکتور الحاق وجود داشته باشد، اکتور دریافت کننده وظیفه دارد این کار را انجام دهد. اکتور دریافت کننده‌ی درخواست اطلاعاتی از قبیل آدرس اکتور الحاق و آدرس گیرنده‌ی نهایی پاسخ را به همراه پیغام‌ها به اکتورهای منشعب شده می‌فرستد.\\
\textbf{موارد استفاده:}\\
موارد استفاده‌ی این الگو به نوعی شبیه به الگوی ۳ (وکالت) است. یک انگیزه برای جدا کردن انشعاب و الحاق کم کردن پیچیدگی اکتور مربوطه است. این عمل با تقسیم وظیفه‌ی انشعاب و الحاق بین دو اکتور مختلف صورت می‌پذیرد. انگیزه‌ی دوم امکان پردازش درخواست همروند برای اکتور انشعاب است. همان‌طور که توضیح داده شد، در این الگو مسئولیتی در قبال پاسخ اکتورهای منشعب شده ندارد. بنابراین می‌تواند با دریافت هر درخواست این عمل را تکرار کند و لزومی ندارد که منتظر پایان پردازش درخواست شود. در این الگو اکتوری که عمل الحاق را انجام می‌دهد اطلاعی از ترتیب ارسال درخواست‌ها ندارد، نمی‌تواند پاسخ‌ها را به ترتیب خاصی دریافت کند. به همین دلیل، موارد استفاده‌ی این الگو محدود به کاربردهایی است که ترتیب پیغام‌های یک درخواست اهمیتی نداشته باشد.
\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=10cm]{4-ProposedFramework/Figures/Patterns_stateless_fj.pdf}
    \end{center}
    \caption{\label{fig:Patterns_stateless_fj}الگوی ۵}
\end{figure*}

\subsection{دسته‌ی دوم}
دسته‌ی دوم الگوهای طراحی، الگوهایی هستند که در آن مسئولیت اکتور دریافت کننده‌ی درخواست، با ارسال‌ پیغام به سایر اکتورها پایان نمی‌پذیرد.

\subsubsection{الگوی ۶ (انشعاب و الحاق بدون ترتیب)}

در این الگو اکتور برای پردازش درخواست، نیاز به ارسال پیغام به چند اکتور دیگر دارد و بعد از دریافت پاسخ از این اکتورها می‌تواند پاسخ درخواست را ارسال کند. فرض بر این است که ترتیب فرستادن پیغام‌ها و ترتیب دریافت پاسخ‌ آنها اهمیت ندارد. شکل \ref{fig:Patterns_statefull_6} این الگو را نمایش می‌دهد.\\
\textbf{نحوه‌ی پیاده‌سازی:}\\
اکتور با دریافت درخواست، پیغام‌هایی به همراه اطلاعات لازم برای اکتورهای مرتبط ارسال می‌کند. با توجه به اینکه ترتیب پاسخ‌ها اهمیتی ندارد، اکتور می‌تواند پاسخ‌ها را به هر ترتیبی پردازش کند. تعداد پاسخ‌های دریافت شده با یک متغیر محلی نگهداری می‌شود و با دریافت هر پاسخ، مقدار آن بروزرسانی می‌شود. علاوه بر این متغیر، سایر متغیرهای حالت سیستم نیز می‌توانند بروزرسانی شوند. با دریافت آخرین پیغام، منطق مربوط به پاسخ درخواست اجرا می‌شود و پاسخ ارسال می‌گردد.\\
\textbf{موارد استفاده:}\\
این الگو در حالاتی از منطق برنامه به کار می‌رود که درخواست مربوط به چندین اکتور است و یا پردازش آن منوط به کسب اطلاعات از چند اکتور است. علاوه بر آن، منطق دامنه باید این خاصیت را داشته باشد که ترتیب پاسخ‌های اکتورها مهم نباشد. مثالی از این الگو، طراحی اکتور محاسبه‌ی معدل در بخش \ref{gpa_approch2} است.
\begin{figure*}[ht]
    \begin{center}
	\includegraphics[width=7cm]{4-ProposedFramework/Figures/Patterns_statelfull_fj.pdf}
    \end{center}
    \caption{\label{fig:Patterns_statefull_6}الگوی ۶}
\end{figure*}
\FloatBarrier
\subsubsection{الگوی ۷ (انشعاب و الحاق با ترتیب)}
در این الگو، اکتور برای پردازش درخواست، نیاز به ارسال پیغام به چند اکتور دیگر دارد و بعد از دریافت پاسخ از این اکتورها می‌تواند پاسخ درخواست را ارسال کند. فرض بر این است که ترتیب فرستادن پیغام‌ها‌‌ اهمیت ندارد ولی ترتیب دریافت پاسخ‌‌ها باید به ترتیب ارسال آنها باشد. شکل \ref{fig:Patterns_statefull_7} این الگو را نمایش می‌دهد.\\
\textbf{نحوه‌ی پیاده‌سازی:}\\

با دریافت درخواست، پیغام‌هایی به همراه اطلاعات لازم برای اکتورهای مرتبط ارسال می‌کند. برای ایجاد قابلیت دریافت به ترتیب، می‌توان از قیود‌ همگام‌سازی محلی (مراجعه کنید به \ref{subsec:local_sync_constraints}) استفاده کرد. به عنوان مثال، در کتابخانه‌ی اکتور اسکالا، این امکان وجود دارد که نتیجه‌ی ارسال هر پیغام را به صورت یک تابع ذخیره کنیم که با فراخوانی آن، اکتور برای دریافت پاسخ مربوطه متوقف شود. \footnote{به این امکان، \textit{آینده} \lr{(Future)}
 گفته می‌شود. (مراجعه کنید به بخش \ref{subsec:scala_message_passing}) }\\
 
\textbf{موارد استفاده:}\\
این الگو در مواردی به کار گرفته می‌شود که ترتیب اجرای مراحل مهم باشند ولی اجرای هر مرحله به مرحله‌ی قبل وابسته نباشد. به عنوان مثال فرض کنید درخواست مورد نظر این باشد که به ترتیب برای چند نفر خرید سهام (انواع مختلف) انجام شود. قبل از انجام خرید هر نوع سهم  لازم است قیمت آن در دست باشد. اکتور مورد نظر می‌تواند اطلاعات انواع سهام را به صورت ناهمگام از اکتورهای دیگر درخواست کند (انشعاب) اما با توجه به اینکه ترتیب خرید سهام مهم است، ترتیب پاسخ‌ها برایش اهمیت دارد. به همین دلیل در هر نوبت خرید، اطلاعات مربوط به سهام مربوطه را دریافت می‌کند.
\begin{figure*}[ht]
    \begin{center}
	\includegraphics[width=7cm]{4-ProposedFramework/Figures/Patterns_statelfull_fj_sequenced_receive.pdf}
    \end{center}
    \caption{\label{fig:Patterns_statefull_7}الگوی ۷}
\end{figure*}
\FloatBarrier

\subsubsection{الگوی ۸ (فراخوانی مرتب)}
در این الگو اکتور برای پردازش درخواست، نیاز به ارسال پیغام به چند اکتور دیگر دارد و بعد از دریافت پاسخ از این اکتورها می‌تواند پاسخ درخواست را ارسال کند. در این الگو فرض بر این است که قبل از دریافت پاسخ هر پیغام، پیغام بعدی را نمی‌توان ارسال کرد.\\
\textbf{نحوه‌ی پیاده‌سازی:}\\
با توجه به اینکه هر تبادل پیغام با اکتورهای دیگر باید به صورت مجزا انجام گیرد، مجبور به استفاده از تبادل همگام هستیم. بنابراین اکتور مورد نظر با ارسال هر پیغام، منتظر پیغام پاسخ می‌ماند و پس از اجرای منطق مربوط به آن می‌تواند پیغام بعدی را ارسال کند.
\textbf{موارد استفاده:}\\
 کاربرد این الگو در مواردی است که درخواست مربوط به یک کار مرحله‌ای باشد و هر مرحله از نظر منطق اجرا، به نتیجه‌ی مرحله‌ی قبل وابسته باشد. مانند اجرای مراحل یک الگوریتم که به صورت همروند نتوان آن را اجرا کرد. البته ممکن است هر پاسخی که اکتور منتظر آن می‌ماند صرفاً اعلام موفقیت یا شکست مرحله‌ی قبل باشد و در صورت شکست بخواهیم عملیات را متوقف کنیم (مانند فعالیت‌هایی که حالت تراکنشی دارند).
\begin{figure*}[ht]
    \begin{center}
	\includegraphics[width=7cm]{4-ProposedFramework/Figures/Patterns_statelfull_rpc.pdf}
    \end{center}
    \caption{\label{fig:Patterns_statefull_8}الگوی ۸}
\end{figure*}

\section{ تجربیات و توصیه‌های طراحی و برنامه‌نویسی به روش تبادل ناهمگام پیغام}
در انجام این پژوهش، رویکردهای مختلف طراحی به روش تبادل ناهمگام آزموده شده است. با توجه به نیاز به بررسی عملکرد صحیح طراحی و نیز ارزیابی کارایی و تغییرپذیری سیستم در این روش(فصل ۷)، پیاده‌سازی‌های متعددی نیز انجام شده است. در انجام این پیاده‌سازی‌ها نکات جالب توجه و مهمی مشاهده گردید که می‌توانند در پژوهش‌های مرتبط و نیز در استفاده از روش مطرح شده برای پیاده‌سازی‌های دیگر مورد استفاده قرار گیرند. در این بخش تعدادی از این تجربیات ارائه می‌گردد.
\subsection{طراحی قالب پیغام‌ها}
در روش طراحی مبتنی بر تبادل ناهمگام پیغام، ارسال و دریافت تنها روش تبادل اطلاعات بین اکتورها است. اطلاعاتی که در قالب پیغام‌ها گذاشته می‌شود می‌توانند باعث ایجاد تغییرات عمده‌ای در روش طراحی بشوند. در این بخش چند نکته‌ی مفید برای طراحی قالب پیغام‌ها ذکر می‌شود:\\
\begin{enumerate}
\item اغلب وقتی یک اکتور درخواستی را برای اکتور دیگر ارسال می‌کند انتظار دریافت پاسخی نیز دارد. در زبان‌های مبتنی بر مدل اکتور، امکان پاسخ‌گویی به پیغام به صورت دستور به صورت دستور وجود دارد.\footnote{مانند دستور reply در کتابخانه‌ی اکتور اسکالا}  علاوه بر این دستور، معمولا فرستنده‌ی یک پیغام از طریق کلمات کلیدی زبان قابل دسترسی هستند.\footnote{ در کتابخانه‌ی اکتور اسکالا دسترسی به فرستنده‌ی پیغامی که در حال پردازش است از طریق کلمه‌ی کلیدی sender میسر می‌شود} به همین دلیل در حالت عادی نیازی به این حس نمی‌شود که وقتی پیغامی ارسال می‌شود،‌ دسترسی به فرستنده در داخل پیغام قرار گیرد. اما \textbf{قرار دادن دسترسی به فرستنده در قالب پیغام} می‌تواند بسیار مفید باشد. این کار به این صورت انجام می‌شود که گیرنده‌ی پاسخ به جای آنکه همان فرستنده‌ی درخواست باشد، آرگومانی از پیغام دریافت شده باشد.
\begin{figure*}
    \begin{center}
    \begin{tabular}{|m{6cm}|m{6cm}|}
      	\hline
	 & \\
	\begin{latin}
\linespread{1.1}
\lstinputlisting[language=scala,xleftmargin=10pt]{4-ProposedFramework/src/bestPractice/1_1.scala}
\end{latin} & 
 \begin{latin}
	\linespread{1.1}
	\lstinputlisting[language=scala,xleftmargin=10pt]{4-ProposedFramework/src/bestPractice/1_2.scala}	
\end{latin}
 	\\
	\begin{center}(الف)\end{center}       &  \begin{center} (ب)\end{center}            \\
	\hline
    \end{tabular}
    \end{center}
    \caption{\label{fig:target_in_message}  پاسخ به درخواست از طریق الف) اشاره‌گر به فرستنده و ب)مقصد قرار داده شده در پیغام}
\end{figure*}

این رویکرد زمانی به کمک برنامه نویس می‌آید که در اثر تغییر طراحی، تصمیم گرفته می‌شود که گیرنده‌ی پاسخ پیغام عوض شود. در این صورت اگر پاسخ پیغام‌ها به اکتوری ارسال شده باشد که در قالب پیغام تعیین شده است، تغییر طراحی صرفاً در کلاس ارسال کننده‌ی درخواست صورت می‌گیرد (عوض کردن گیرنده‌ی پاسخ در قالب پیغام)، اما در صورتی که پاسخ پیغام‌ها به فرستنده‌ی پیغام صورت گرفته باشد این تغییر به تمام کلاس‌هایی که پیغام دریافت می‌کنند سرایت خواهد کرد.
\item در حالتهایی که برای پاسخ به یک درخواست نیاز به برقراری ارتباط بین چند اکتور وجود دارد (مانند الگوی خط لوله) امکان دارد در طول مراحل پردازش پیغام‌ها بتوان پاسخ درخواست را قبل از اتمام کار تمام اکتورها ارسال کرد. به عنوان مثال فرض کنید مراحل پردازش یک درخواست شامل بررسی شروطی باشند که در صورت برقرار نبودن هر شرط کل عملیات درخواست باید لغو شود. در چنین حالت‌هایی مطلوب است که اکتورهای میانی پایان بتوانند مستقیماً پاسخ درخواست را اجرا کنند و گیرنده را تا پایان پردازش درخواست منتظر نگذارند. برای عملی کردن این رویکرد باید اطلاعات گیرنده‌ی نهایی پاسخ درخواست در پیغام‌هایی که اکتورها ردوبدل می‌کنند موجود باشد. به همین دلیل \textbf{قرار دادن گیرنده‌ی نهایی پاسخ درخواست در پیغام‌های ردوبدل شده} می‌تواند مفید واقع شود.
\item با اینکه پیغام در مدل تبادل پیغام به نوعی معادل متد در مدل طراحی شیءگرا است (از نظر تعریف واسط رفتاری شیء)، اما بین این دو تفاوت‌های زیادی وجود دارد.
\end{enumerate}

\subsection{خودداری از تفکر ترتیبی در طراحی}
علیرغم شباهت‌ها و اشتراکات فراوان مدل شیءگرای ترتیبی با مدل تبادل ناهمگام پیغام، نحوه‌ی تفکر در طراحی این دو بسیار متفاوت است. به همین دلیل آغاز به طراحی در این روش برای کسی که سابقه‌ی طراحی شیءگرای ترتیبی را دارد قدری سخت است. از طرف دیگر بسیاری از پیاده‌سازی‌های مدل اکتور تمام مشخصه‌های معنایی اکتور را به طور کامل پیاده‌سازی نمی‌کنند\cite{ActorsJVM2009}. از جمله در کتابخانه‌ی اکتور اسکالا، این امکان وجود دارد که از یک اکتور به صورت یک شیء عادی استفاده کرد و متدهای آن را فراخوانی کرد. مجموع این عوامل باعث می‌شوند که طراح کم تجربه به طور ناخودآگاه به سمت طراحی ترتیبی سوق پیدا کند. طبیعتاً
حل این مسئله نیازمند کسب تجربه و مهارت در طراحی همروند است. در این بخش نمونه‌هایی از مشکلاتی که در اثر تفاوت طراحی با استفاده از این دو دیدگاه به وجود می‌آیند معرفی می‌شود.
\begin{enumerate}
\item همگام‌سازی بی‌مورد:\\
معمولاً در برخورد با مسائل طراحی اولین گزینه‌ای که به ذهن یک طراح کم تجربه می‌رسد استفاده از تبادل همگام پیغام است که شبیه به استفاده از فراخوانی متد در مدل شیءگرا است. این تفکر باعث می‌شود که در بسیاری از مراحل طراحی، بدون آنکه ذات مسئله نیازمند همگام سازی باشد از ارسال‌های همگام استفاده کنیم. برای جلوگیری از این مورد، در بررسی هر مسئله بهتر است طراح به این پرسش پاسخ دهد که آیا منطق مسئله نیازمند همگام‌سازی است یا خیر؟ در صورتی که منطق مسئله نیاز به همگام‌سازی نباشد، به احتمال زیاد لزومی به استفاده از تبادل همگام در برنامه وجود ندارد.

\item تبادل پیغام‌های بی‌مورد:\\
 با اینکه پیغام در مدل تبادل پیغام به نوعی معادل متد در مدل طراحی شیءگرا است (از نظر تعریف واسط رفتاری شیء)، اما بین این دو تفاوت‌های زیادی وجود دارد. یکی از تفاوت‌های مهم این دو در این است که اگر متد، یک خروجی‌ را برگرداند و از آن خروجی در پیاده‌سازی قسمتی از منطق مورد استفاده شود، محل برگشت خروجی، همان شی‌ءای است که متد را فراخوانی کرده است. اما در تبادل پیغام،‌ می‌توانیم خروجی را به اکتور دیگری ارسال کنیم. انتقال این تفکر ترتیبی به طراحی به روش تبادل پیغام می‌تواند باعث به وجود آمدن تبادل پیغام‌های بی‌مورد گردد. این مورد به طور کامل در رویکرد اول طراحی منطق مربوط به محاسبه‌ی معدل دیده می‌شود (بخش \ref{gpa_approach1}). 
 
 \item تبادل پیغام منجر به بن‌بست:\\
  اینکه مدل اکتور با توجه به عدم استفاده از به اشتراک گذاری حالت در حافظه، مشکلات همروندی کمتری نسبت به استفاده از ریسمان‌ها و حافظه‌ی مشترک دارد(\cite{WhyThreadsAreABadIdea})، ممکن است باعث این تفکر اشتباه بشود که در مدل اکتور نباید نگران مشکلات ناشی از کنترل همروندی باشیم. شکل \ref{fig:deadlock1} مثالی را نشان می‌دهد که دو اکتور در تبادل پیغام با یکدیگر دچار بن‌بست شده‌اند.
\begin{figure*}
    \begin{center}
    \begin{tabular}{|m{6cm}|m{6cm}|}
      	\hline
	 & \\
	\begin{latin}
\linespread{1.1}
\lstinputlisting[language=scala,xleftmargin=10pt]{4-ProposedFramework/src/bestPractice/DeadlockA.scala}
\end{latin} & 
 \begin{latin}
	\linespread{1.1}
	\lstinputlisting[language=scala,xleftmargin=10pt]{4-ProposedFramework/src/bestPractice/DeadlockB.scala}	
\end{latin}
 	\\
	\begin{center}اکتور A\end{center}       &  \begin{center} اکتور B\end{center}            \\
	\hline
    \end{tabular}
    \end{center}
    \caption{\label{fig:deadlock1}  وقوع بن‌بست در تبادل پیغام بین دو اکتور}
\end{figure*}

نکته‌ای که باید به آن دقت کرد، این است که در این مثال در صورتی که تبادل پیغام به صورت ناهمگام انجام شود، مشکل بن‌بست رخ نمی‌دهد. بنابراین اجتناب از تبادل همگام در کاهش حالات بن‌بست مفید می‌باشد. اما در تمام حالات امکان اجتناب از تبادل همگام وجود ندارد. به همین دلیل باید در هنگام طراحی و پیاده سازی به عدم وجود چرخه‌های وابستگی بین درخواست‌های همگام دقت کرد. \\
علاوه بر مورد قبلی که مربوط به وجود چرخه در درخواست‌های همگام بود، یک نکته‌ی مهم دیگر در برنامه‌نویسی به روش تبادل پیغام وجود دارد. همان‌طور که در بخش قبل ذکر شد، تبادل پیغام در مدل اکتور، واسط رفتار اشیاء، معادل فراخوانی متد در مدل ترتیبی است. با همین تفکر ممکن است در قسمتی از طراحی یا پیاده‌سازی برنامه به روش تبادل پیغام، یک اکتور یک پیغام برای خودش ارسال کند. مثالی از این مورد در شبه‌کد شکل \ref{fig:bestPractice:deadlock2} نشان داده شده است.
\codelisting[language=scala]{4-ProposedFramework/src/bestPractice/DeadlockSelfMsg.scala}{شبه‌کد اسکالا برای حالت وقوع بن‌بست به دلیل ارسال پیغام اکتور به خودش}{fig:bestPractice:deadlock2} 
این مثال بخشی از کد یک اکتور در یک طراحی فرضی را نشان می‌دهد. این اکتور ۲ نوع پیغام دریافت می‌کند. اولین پیغام درخواست بررسی گذرانده شدن یک درس است که در جواب آن پاسخ مناسب داده می‌شود. منطق مربوط به طریقه‌ی فهمیدن اینکه درس گذرانده شده است یا خیر، در این شکل نشان داده نشده است. درخواست دوم بررسی گذرانده شدن پیش‌نیازهای یک درس است. با توجه به اینکه این اکتور به پیش‌نیازهای درس دسترسی دارد و قادر به پاسخگویی به درخواست بررسی گذرانده شدن درس نیز است، ممکن است برای بررسی گذراندن پیش‌نیازها این راهکار به ذهن برسد که اکتور به ازای هر درس پیش‌نیاز، یک درخواست بررسی گذرانده شدن درس برای خودش ارسال کند و پاسخ آنها را دریافت کند. این منطق در قالب متد hasPassedPreReqs نشان داده شده است. معادل این طراحی در مدل شیءگرای ترتیبی در شکل \ref{fig:bestPractice:deadlock3} نشان داده شده است.
\codelisting[language=scala]{4-ProposedFramework/src/bestPractice/DeadlockSelfMsg2.scala}{شبه‌کد جاوا برای حالت شیءگرای ترتیبی در شکل \ref{fig:bestPractice:deadlock2}}{fig:bestPractice:deadlock3} 
\end{enumerate}
با اینکه این دو شبه‌کد دقیقاً یک منطق را مدل می‌کنند، طراحی حالت تبادل پیغام در این وضعیت منجر به بن‌بست اکتور می‌شود. دلیل این امر این است که با توقف یک اکتور برای دریافت یک پیغام، ریسمان اجرای آن متوقف می‌شود و تا وقتی که پیغامی را که درخواست شده دریافت نکند، ادامه‌ی اجرای آن از سر گرفته نمی‌شود. در شکل \ref{fig:bestPractice:deadlock2} اکتور در خط ۱۳ تعدادی پیغام برای خودش ارسال می‌کند، در ادامه در خط ۱۷ با استفاده از دستور receive منتظر دریافت پاسخ می‌ماند. در این لحظه اجرای این اکتور تا دریافت پاسخ متوقف می‌شود. با وارد شدن هر پیغام در صندوق پیغام اکتور، پیغام جدید با پیغامی که در بلوک receive درخواست شده مقایسه می‌شود و اگر پیغام مورد نظر نبود منتظر دریافت پیغام‌های دیگر می‌شود.
 این در حالی‌است که دریافت پیغام‌هایی که در خط ۱۳ فرستاده شده، در بلوک دیگری از اکتور در خط ۲ دریافت می‌شود. با توجه به اینکه اجرای برنامه در بلوک خط ۱۷ متوقف شده،‌ پس از آن نوبت اجرا هیچ‌گاه به بلوک خط ۱ نمی‌رسد و در نتیجه پیغام‌های مربوطه هیچگاه پاسخ‌داده نمی‌شوند. به این ترتیب اکتور در وضعیت بن‌بست قرار می‌گیرد.\\
  بنابراین علاوه بر توجه به حالت‌های بن‌بست ایجاد شده در اثر وابستگی چرخشی اکتورها به همدیگر، ممکن است ارسال پیغام از یک اکتور به خودش نیز در حالت‌های خاص منجر به بن‌بست شود. البته این موارد به سادگی با عوض کردن رویکرد طراحی (در طراحی مورد کاربرد اخذ درس این مشکل وجود ندارد) و یا با دقت در استفاده از بلوک‌های دریافت پیغام قابل حل هستند.
