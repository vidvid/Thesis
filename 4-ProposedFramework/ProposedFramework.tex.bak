\section{مقدمه}
\label{sectio:design:preface}
در این فصل از پژوهش روش طراحی منطق دامنه بر اساس تبادل ناهمگام پیغام ارائه شده است. تلاش شده است تا تطابق طراحی با مدل بازیگر در حد امکان حفظ شود. با توجه به تمرکز این بخش بر روش طراحی منطق دامنه و به هدف ایجاد شفافیت و افزایش قابلیت فهم نکات و الگوهای مطرح شده در روش، تصمیم به استفاده از یک سیستم نمونه به عنوان مثال گرفته شد. کلیه‌ی نکات مطرح شده در ادامه‌ی این بخش در قالب این مثال ارائه خواهند شد. در انتخاب سیستم نمونه نکات ذیل مورد توجه قرار گرفته‌ است:
\begin{enumerate}
\item \textbf{دامنه‌ی سیستم انتخابی:}
رده‌ی دامنه‌ی سیستم انتخاب شده به طور کلی سیستم‌های اطلاعاتی\LTRfootnote{Information System} است. اولین دلیل انتخاب این رده این است که در این نوع دامنه همروندی به طور ذاتی وجود ندارد و به همین دلیل زمینه‌ی مقایسه‌ی طراحی بر اساس تبادل ناهمگام با  طراحی‌های شیءگرای ترتیبی فراهم می‌شود. با توجه به اینکه یکی از موارد مقایسه‌ی این نوع طراحی با طراحی شیءگرای ترتیبی تفاوت کارایی این دو رویکرد است، دامنه‌ی انتخاب شده باید در حالت ترتیبی هم قابلیت اضافه شدن همروندی را داشته باشد. سیستم‌های اطلاعاتی از این حیث نیز انتخاب مناسبی محسوب می‌شوند چرا که در اکثر پیاده‌سازی‌های عملیاتی، علیرغم داشتن طراحی ترتیبی، به وسیله‌ی ریسمان‌هایی که وب‌سرورها برای پاسخگویی به درخواست‌های همزمان کاربران ایجاد می‌کنند، دارای خاصیت همروندی نیز می‌گردند. به همین دلیل در بخش ارزیابی می‌توانیم با شبیه‌سازی عملیات وب‌سرورها، کارایی و نیز تغییرپذیری دو نوع طراحی مذکور را ارزیابی و مقایسه کنیم.
 دلیل دیگر این انتخاب بالا بودن میزان آشنایی جامعه‌ی طراحی شیءگرا با این نوع سیستم‌ها و استفاده‌ی گسترده از این نوع سیستم‌ها می‌باشد. شایان ذکر است که سعی شده است در ارائه‌ی الگوها و نکات استخراج شده از این طراحی بر دامنه‌ی انتخاب شده تکیه‌ نشود. دامنه‌ی سیستم نمونه نیز یک سیستم آموزشی انتخاب شده است. با توجه به اینکه استفاده کنندگان این پژوهش جامعه‌ی دانشگاهی هستند، آشنایی این جامعه با سیستم آموزشی دلیل اصلی انتخاب آن بوده است. 
\item \textbf{ بزرگی منطق دامنه:}
از نظر میزان بزرگی سیستم (تعداد کلاس‌ها و موارد کاربرد\LTRfootnote{use cases})،‌  سعی شده منطق حداقل بزرگی و پیچیدگی را داشته باشد تا ضمن امکان مشاهده‌ی الگوهای مختلف، نیازی به تکرار نکات طراحی برای مولفه‌های متعدد و مشابه نباشد. 
\end{enumerate} 

\section{معرفی یک سیستم آموزش ساده }
\label{section:eduIntro}
همان‌طور که در بخش \ref{sectio:design:preface} ذکر شد،‌ یک سیستم آموزش کوچک به عنوان مدل طراحی انتخاب شده است. در ادامه‌ی این بخش ابتدا موارد کاربرد\LTRfootnote{use cases} انتخاب شده در این سیستم را توصیف می‌کنیم و سپس با توجه به‌ آنها مدل دامنه\LTRfootnote{Domain Model} سیستم را در قالب نمودار کلاس بیان می‌کنیم.

\subsection{موارد کاربرد}
در این بخش موارد کاربرد انتخاب شده برای سیستم آموزش معرفی می‌شوند. لازم به تأکید است که علیرغم این که این موارد کاربرد، مرتبط و هماهنگ با موارد کاربرد یک سیستم آموزش واقعی هستند، به هیچ عنوان تمام موارد کاربرد مورد نیاز برای ساختن سیستم واقعی را شامل نمی‌شوند و علاوه‌ بر آن، موارد انتخاب شده دارای جزئیات و دقت کافی برای پوشش فرایند‌های واقعی نیستند. در ادامه‌ی این بخش، هر \gls{مورد کاربرد} در قالب یک جدول توصیفی ارائه شده‌ است.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  GPA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}
\begin{center}
\begin{tabular}{|p{5cm}|p{10cm}|}
	\hline
	\textbf{نام مورد کاربرد} &
درخواست محاسبه‌ی معدل ترم دانشجو\\
	\hline
	\textbf{بازیگر(ان)} &
کاربر\\
	\hline
	\textbf{شروع می‌شود زمانی که} &
درخواست محاسبه‌ی معدل ترم وارد سیستم می‌شود.\\
	\hline
	\textbf{پیش‌شرط‌ها} &
دانشجو و ترم در سیستم تعریف شده باشند.\\
	\hline
	\textbf{جریان اصلی} &
۱. درخواست محاسبه‌ی معدل دانشجو در ترم مربوطه وارد سیستم می‌شود.\newline
۲. سیستم سوابق تحصیلی دانشجو در ترم مربوطه را بررسی ‌می‌کند. معدل ترم با توجه به نمرات اخذ شده و تعداد واحد هر درس محاسبه و اعلام می‌شود. در صورتی که نمره‌ی درس سابقه‌ای وارد نشده باشد، درس مربوطه در محاسبه‌ی معدل لحاظ نمی‌گردد.\\
	\hline
\textbf{جریان استثنا ۱} &
۲.الف) در صورتی که دانشجو هیچ واحدی در ترم جاری اخذ نکرده باشد پیغام خطای مناسب صادر می‌شود و جریان اصلی خاتمه می‌یابد.\\
	\hline
%	\textbf{جریان استثنا ۲} &
%۴-ج. رمز وارد شده نامعتبر است، پیام خطای رمز نامعتبر است به کاربر نمایش داده شده و تراکنش متوقف می‌شود\\
%	\hline
	\textbf{تمام می‌شود زمانی که} &
معدل دانشجو اعلام می‌شود یا خطای مناسب صادر می‌گردد.\\
	\hline
%	\textbf{پس شرط‌ها} &
%کاربر موجودی کارت و یا خطای تراکنش را مشاهده کرده است.\\
%	\hline
\end{tabular}
\caption{\label{table:uc_gpa} توصیف مورد کاربرد محاسبه‌ی معدل یک دانشجو در یک ترم}
\end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  Take Course
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}
\begin{center}
\begin{tabular}{|p{4cm}|p{12cm}|}
	\hline
	\textbf{نام مورد کاربرد} &
درخواست اخذ یک ارائه در یک ترم\\
	\hline
	\textbf{بازیگر(ان)} &
کاربر\\
	\hline
	\textbf{شروع می‌شود زمانی که} &
درخواست اخذ ارائه وارد سیستم می‌شود.\\
	\hline
	\textbf{پیش‌شرط‌ها} &
۱. ‌انتخاب واحد در ترم امکانپذیر باشد. (رجوع کنید به جداول \ref{table:uc_enableofferings}و\ref{table:uc_disableofferings})\\
	\hline
	\textbf{جریان اصلی} &
۱. سیستم کنترل می‌کند که دانشجو در ترم‌های قبل این درس را نگذرانده باشد.\newline
۲. سیستم کنترل می‌کند که دانشجو در ترم‌ جاری این درس را اخذ نکرده باشد.\newline
۳. سیستم کنترل می‌کند که دانشجو تمام پیش‌نیاز‌های این درس را با موفقیت گذرانده باشد.\newline
۴. سیستم کنترل می‌کند که تعداد واحد‌های اخذ شده توسط دانشجو در این ترم پس از اخذ این درس بیشتر از ۲۰ نشود.\newline
۵. سیستم یک سابقه از ارائه‌ی انتخاب شده برای دانشجو تشکیل می‌دهد و آن را در سوابق دانشجو ثبت می‌کند.\\
	\hline
\textbf{جریان استثنا ۱} &
۱.الف)در صورتی که دانشجو قبلا این درس را گذرانده باشد، خطای ''درس انتخاب شده قبلاً گذرانده شده است`` صادر می‌شود و جریان اصلی خاتمه می‌یابد.\\
	\hline
\textbf{جریان استثنا ۲} &
۲.الف)در صورتی که دانشجو در ترم جاری این درس را اخذ کرده باشد، خطای ''این درس در ترم جاری قبلاً اخذ شده است`` صادر می‌شود و جریان اصلی خاتمه می‌یابد.\\
	\hline
\textbf{جریان استثنا ۳} &
۳.الف)در صورتی که دانشجو یکی از پیش‌نیاز‌های درس‌ را نگذرانده باشد، خطای ''انتخاب بیشتر از ۲۰ واحد در ترم مجاز نمی‌باشد`` صادر می‌شود و جریان اصلی خاتمه می‌یابد.\\
	\hline
\textbf{جریان استثنا ۴} &
۴.الف)در صورتی که تعداد واحد‌های اخذ شده توسط دانشجو در این ترم پس از اخذ این درس بیشتر از ۲۰ شود، خطای ''انتخاب بیشتر از ۲۰ واحد در ترم مجاز نمی‌باشد`` صادر می‌شود و جریان اصلی خاتمه می‌یابد.\\
	\hline
	\textbf{تمام می‌شود زمانی که} &
سابقه‌ی جدید در سوابق دانشجو ثبت می‌شود و یا خطای مناسب صادر می‌گردد.\\
	\hline
\end{tabular}
\caption{\label{table:uc_takecoure} توصیف مورد کاربرد اخذ یک ارائه توسط یک دانشجو در یک ترم}
\end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  DISABLE_TERM_OFFERINGS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}
\begin{center}
\begin{tabular}{|p{5cm}|p{10cm}|}
	\hline
	\textbf{نام مورد کاربرد} &
درخواست غیر فعال کردن ارائه‌های یک ترم برای انتخاب واحد\\
	\hline
	\textbf{بازیگر(ان)} &
کاربر(مدیر سیستم)\\
	\hline
	\textbf{شروع می‌شود زمانی که} &
درخواست غیرفعال کردن ارائه‌های یک ترم وارد سیستم می‌شود.\\
	\hline
	\textbf{پیش‌شرط‌ها} &
 ترم در سیستم تعریف شده باشند.\\
	\hline
	\textbf{جریان اصلی} &
۱. درخواست غیر فعال کردن ارائه‌های یک ترم وارد سیستم می‌شود.\newline
۲.سیستم تمام ارائه‌های یک ترم را غیرفعال می‌کند.\\
	\hline
	\textbf{تمام می‌شود زمانی که} &
تمام ارائه‌های ترم برای انتخاب واحد غیرفعال می‌شوند.\\
	\hline
	\textbf{پس شرط‌ها} &
انتخاب واحد در ترم امکان پذیر نیست.\\
	\hline
\end{tabular}
\caption{\label{table:uc_disableofferings} توصیف مورد کاربرد غیرفعال کردن ارائه‌های یک ترم برای انتخاب واحد}
\end{center}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%  ENABLE_TERM_OFFERINGS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}
\begin{center}
\begin{tabular}{|p{5cm}|p{10cm}|}
	\hline
	\textbf{نام مورد کاربرد} &
درخواست فعال کردن ارائه‌های یک ترم برای انتخاب واحد\\
	\hline
	\textbf{بازیگر(ان)} &
کاربر(مدیر سیستم)\\
	\hline
	\textbf{شروع می‌شود زمانی که} &
درخواست فعال کردن ارائه‌های یک ترم وارد سیستم می‌شود.\\
	\hline
	\textbf{پیش‌شرط‌ها} &
 ترم در سیستم تعریف شده باشند.\\
	\hline
	\textbf{جریان اصلی} &
۱. درخواست فعال کردن ارائه‌های یک ترم وارد سیستم می‌شود.\newline
۲.سیستم تمام ارائه‌های یک ترم را فعال می‌کند.\\
	\hline
	\textbf{تمام می‌شود زمانی که} &
تمام ارائه‌های ترم برای انتخاب واحدفعال می‌شوند.\\
	\hline
	\textbf{پس شرط‌ها} &
انتخاب واحد در ترم امکان پذیر است.\\
	\hline
\end{tabular}
\caption{\label{table:uc_enableofferings} توصیف مورد کاربرد فعال کردن ارائه‌های یک ترم برای انتخاب واحد}
\end{center}
\end{table}


\subsection{اشیاء دامنه}
\label{subsec:mainEntities}
 موجودیت‌های اصلی  مدل ابتدایی این سیستم عبارتند از:
\textbf{\textit{دانشجو}}\LTRfootnote{Student}، \textbf{\textit{درس}}\LTRfootnote{Course}، \textbf{\textit{ترم}}\LTRfootnote{Term}، \textbf{\textit{ارائه}}\LTRfootnote{Offering} و \textbf{\textit{سابقه}}\LTRfootnote{Study Record}.\\
در هر \textit{ترم} تحصیلی، تعدادی \textit{ارائه} از دروس مختلف وجود دارد. هر درس می‌تواند \textit{ارائه}های مختلفی داشته باشد. به عنوان مثال درس ریاضی۱ می‌تواند در ترم ۹۰-۹۱-۱سه ارائه‌ی مختلف داشته باشد. دانشجو با اخذ هر ارائه \textit{سابقه}‌ای از آن ارائه را به اسم خود ثبت می‌کند. در این سابقه اطلاعاتی مثل نمره‌ی دانشجو و وضعیت قبول یا مردودی درس در طول ترم ثبت خواهد شد. دروس می‌توانند رابطه‌ی پیش‌نیازی\LTRfootnote{prerequisite} باهم داشته باشند. 
\begin{figure*}
    \begin{center}
	\includegraphics[width=12cm]{4-ProposedFramework/Figures/SimpleClassDiagram.pdf}
    \end{center}
    \caption{\label{fig:edu_class1} نمودار کلاس مدل ابتدای سیستم آموزش ساده }
\end{figure*}
شکل \ref{fig:edu_class1} مدل دامنه‌ی سیستم را به وسیله‌ی یک نمودار کلاس مبتنی بر \textbf{یو‌ام‌ال}\LTRfootnote{UML} نشان می‌دهد.

\newpage
\section{طراحی سیستم آموزش به روش تبادل ناهمگام پیغام}
در این بخش طراحی سیستم معرفی شده در بخش \ref{section:eduIntro} به روش تبادل ناهمگام پیغام ارائه می‌گردد. سعی شده است تا به جای ارائه‌ی یکباره‌ی طراحی نهایی، یک رویکرد \gls{افزایشی}\LTRfootnote{incremental} برای طراحی اتخاذ شود. در این رویکرد مراحل تشکیل نهایی طرح و حتی اقدامات اشتباهی که در طول طراحی برداشته شده است ارائه خواهد شد. به  این ترتیب علاوه بر قابل استفاده‌تر بودن پژوهش به صورت یک دستورالعمل \LTRfootnote{receipe} طراحی، قابلیت فهم روش طراحی هم بالاتر می‌رود.
\subsection{طراحی اکتور‌های مدل دامنه}
اکتورهای اصلی سیستم همان اشیاء مدل دامنه هستند که در بخش \ref{subsec:mainEntities} معرفی شدند.البته احتمالاً علاوه بر این اکتورها، اکتورهای دیگری نیز برای پیاده‌سازی کارکردهای سیستم استفاده خواهند شد. در طراحی اکتورهای اصلی صرفا فیلد‌های داده‌ای اکتور و نیز پیغام‌های اصلی که از روابط موجود در نمودار کلاس \ref{fig:edu_class1} قابل استخراج هستند در نظر گرفته ‌می‌شود. منطق پیاده‌سازی عملیات هر پیغام و  پیغام‌های دیگری که به این منظور ایجاد می‌شوند در ادامه به طراحی افزوده خواهد شد. 
با توجه به اینکه در مدل اکتور،‌ تنها راه ارتباط بین اکتور‌ها استفاده از تبادل پیغام است و این که یک اکتور برای امکان ارسال پیغام به اکتور دیگر نیاز به دسترسی به اسم آن دارد، بهترین راه برای طراحی رابطه‌های وابستگی\LTRfootnote{association} این است که در کلاس یک اکتور برای هر کلاس دیگر که رابطه‌ای با آن وجود دارد یک فیلد از نوع کلاس طرف دیگر در نظر گرفته شود. این مورد مشابه طراحی شیءگرای عادی (ترتیبی) است. از طرف دیگر در مدل طراحی شیءگرای ترتیبی برای هر کارکرد اصلی یک شیء نیز یک متد در کلاس متناظر با آن در نظر گرفته می‌شود که برای اجرای کارکرد، متد مورد نظر فراخوانی می‌شود. با توجه به اینکه در مدل اکتور مکانیزم کنترلی برنامه به جای فراخوانی متد، تبادل پیغام است، باید به ازای هر متد متناظر در حالت شیءگرا، یک پیغام دریافت شود. البته در این مرحله از طراحی منطق پیاده‌سازی کارکرد هر پیغام در نظر گرفته نشده است و در مراحل بعدی به تدریج اضافه خواهد شد.
\begin{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%										Student												%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item\textbf{اکتور دانشجو:}
این اکتور دارای فیلد‌های نام و شناسه است. به علت ارتباط دانشجو با سابقه‌ها و نیاز  به ارسال پیغام به آنها یک فیلد از نوع لیست سابقه نیز در کلاس دانشجو وجود دارد. قطعه کد \ref{fig:mainActors:student} طرح ابتدایی کلاس اکتور دانشجو را نشان می‌دهد. همان‌طور که در بخش قبل ذکر شد منطق پیاده‌سازی کارکرد پیغام‌ها در این مرحله اضافه نشده و در ادامه‌ی فصل به تدریج تکمیل خواهد شد. پیغام‌هایی که اکتور دانشجو دریافت می‌کند عبارتند از:
\begin{enumerate}
%\item\textbf{:\lr{HasPassed(course)}}
%با دریافت این پیغام اکتور دانشجو باید پاسخ بدهد که آیا درس مربوطه را گذرانده است یا خیر.
%\item\textbf{:\lr{HasTaken(course)}}
%با دریافت این پیغام دانشجو باید پاسخ دهد که در ترم جاری این درس را اخذ کرده است یا خیر.
\item\textbf{:\lr{GPARequest(term)}}
با دریافت این پیغام دانشجو باید پاسخ دهد که معدل دانشجو در ترم جاری  چند بوده است.
\item\textbf{:\lr{TakeCourse(offering)}}
با دریافت این پیغام دانشجو باید درس ارائه‌ی مربوطه را اخذ کند. طبیعتاً تمام شرایط ذکر شده در مورد کاربرد \ref{table:uc_takecoure} باید بررسی شود.
\end{enumerate}
طبیعتاً این موارد تنها شامل پیغام‌هایی است که مستقیماً از موارد کاربرد قابل استخراج هستند. در هنگام طراحی کارکردهای موارد کاربرد، در صورت لزوم پیغام‌های جدیدی به این کلاس اضافه خواهد شد.
\codelisting[language=scala]{4-ProposedFramework/src/mainActors/Student.scala}{ساختار کلاس اکتور دانشجو}{fig:mainActors:student}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%										StudyRecord										%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item\textbf{اکتور سابقه:}
مطابق مدل دامنه‌ که در شکل \ref{fig:edu_class1} ارائه شده است، تنها فیلد داده‌ای این اکتور، نمره است. به علت ارتباط سابقه با اکتور ارائه، یک فیلد از نوع ارائه نیز در کلاس سابقه وجود دارد. قطعه کد \ref{fig:mainActors:studyrecord} طرح ابتدایی کلاس اکتور سابقه را نشان می‌دهد. همان‌طور که در بخش قبل ذکر شد منطق پیاده‌سازی کارکرد پیغام‌ها در این مرحله اضافه نشده و در ادامه‌ی فصل به تدریج تکمیل خواهد شد. در این مرحله، پیغامی که مستقیماً از موارد کاربرد قابل استخراج باشد وجود ندارد
و در هنگام طراحی کارکردهای موارد کاربرد، در صورت لزوم پیغام‌های جدیدی به این کلاس اضافه خواهد شد.
\codelisting[language=scala]{4-ProposedFramework/src/mainActors/StudyRecord.scala}{ساختار کلاس اکتور سابقه}{fig:mainActors:studyrecord}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%										Offering										%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item\textbf{اکتور ارائه:}
مطابق مدل دامنه‌ که در شکل \ref{fig:edu_class1} ارائه شده است، فیلدهای داده‌ای این اکتور عبارتند از شناسه و تاریخ امتحان\LTRfootnote{examDate}. به علت ارتباط ارائه با اکتور‌های درس و ترم، یک فیلد از نوع درس و یک فیلد از نوع ترم نیز در کلاس ارائه وجود دارد. قطعه کد \ref{fig:mainActors:offering} طرح ابتدایی کلاس اکتور ارائه را نشان می‌دهد. در این مرحله، پیغامی که مستقیماً از موارد کاربرد قابل استخراج باشد وجود ندارد
و در هنگام طراحی کارکردهای موارد کاربرد، در صورت لزوم پیغام‌های جدیدی به این کلاس اضافه خواهد شد.
\codelisting[language=scala]{4-ProposedFramework/src/mainActors/Offering.scala}{ساختار کلاس اکتور ارائه}{fig:mainActors:offering}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%										Course										%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item\textbf{اکتور درس:}
مطابق مدل دامنه‌ که در شکل \ref{fig:edu_class1} ارائه شده است، فیلدهای داده‌ای این اکتور عبارتند از شناسه، نام و تعداد واحد. تنها ارتباط این کلاس که نیاز به ایجاد فیلد دارد ارتباط دروس پیش‌نیاز است. بنابراین یک فیلد از نوع لیست درس نیز به این منظور باید به کلاس اضافه شود. قطعه کد \ref{fig:mainActors:course} طرح ابتدایی کلاس اکتور درس را نشان می‌دهد. در این مرحله، پیغامی که مستقیماً از موارد کاربرد قابل استخراج باشد وجود ندارد
و در هنگام طراحی کارکردهای موارد کاربرد، در صورت لزوم پیغام‌های جدیدی به این کلاس اضافه خواهد شد.
\codelisting[language=scala]{4-ProposedFramework/src/mainActors/Course.scala}{ساختار کلاس اکتور درس}{fig:mainActors:course}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%										Term										%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item\textbf{اکتور ترم:}
مطابق مدل دامنه‌ که در شکل \ref{fig:edu_class1} ارائه شده است، فیلدهای داده‌ای این اکتور عبارتند از نام و تاریخ شروع{startDate}. با توجه به موارد کاربرد مطرح شده، اکتور ترم آغاز کننده‌ی هیچ ارتباطی نیست و به همین دلیل نیازی به داشتن فیلدی برای این منظور نیست. اکتور ترم قطعه کد \ref{fig:mainActors:term} طرح ابتدایی کلاس اکتور ترم را نشان می‌دهد. در این مرحله، پیغامی که مستقیماً از موارد کاربرد قابل استخراج باشد وجود ندارد
و در هنگام طراحی کارکردهای موارد کاربرد، در صورت لزوم پیغام‌های جدیدی به این کلاس اضافه خواهد شد.
\codelisting[language=scala]{4-ProposedFramework/src/mainActors/Term.scala}{ساختار کلاس اکتور ترم}{fig:mainActors:term}
\end{enumerate}
\newpage
\subsection{مورد کاربرد محاسبه‌ی معدل}
این مورد کاربرد در جدول \ref{table:uc_gpa} توصیف شده است. 
\subsubsection{رویکرد اول}
\label{gpa_approach1}
برای محاسبه‌ی معدل ترم یک دانشجو نیاز داریم نمره‌ی تمام درس‌های دانشجو در ترم به همراه تعداد واحد‌های آن درس‌ها را در اختیار داشته باشیم. درخواست معدل برای ترم از طرف دانشجو صورت می‌گیرد بنابراین شروع پیغام‌ها از این اکتور آغاز می‌شود.
 اکتور دانشجو به هر کدام از اکتور‌های سابقه\LTRfootnote{StudyRecord} یک پیغام می‌فرستد و به وسیله‌ی آن اعلام می‌کند نمره و تعداد واحد‌های درس مربوط به سابقه در پاسخ ارسال شود. علاوه بر این، در پاسخ باید مشخص شود که آیا سابقه‌ مربوط به همان ترم است که معدل برای آن درخواست شده یا خیر. بنابراین پیغام‌های  درخواست نمره برای معدل و پاسخ آن به صورت زیر خواهند بود:
\begin{latin}
 \begin{description}
 \item[\lr{request: GPAInfoRequest( term: Term)}]
  \item[\lr{response: GPAInfoResponse(isForTerm:Boolean, grade: Double, units:Int)}]
 \end{description}
 \end{latin}
  اکتور سابقه امکان اینکه بدون برقراری ارتباط با اکتور ارائه\LTRfootnote{Offering} جواب این پیغام را بدهد، ندارد. دلیل این امر این است که اولا سابقه‌ لزوما مربوط به ترمی نیست که معدل برای آن درخواست شده است، ثانیا سابقه اطلاعی از تعداد واحد‌های درس مربوطه ندارد. به همین دلیل، سابقه باید برای جمع‌آوری این اطلاعات با اکتورهای دیگر تبادل پیغام انجام دهد. از طرف دیگر تنها اکتوری که به نمره‌ی دانشجو دسترسی ادارد، اکتور سابقه است. در نتیجه فرستادن پاسخ به درخواست دانشجو نیاز به همکاری ۳ اکتور سابقه، درس و ترم دارد. با توجه به اینکه دسترسی سابقه به اکتورهای درس و ترم از طریق اکتور ارائه ممکن می‌شود، این اکتور نیز در تبادل پیغام‌ها مشارکت خواهد داشت.\\
با توجه به موارد ذکر شده، اکتور سابقه دو راهکار پیش رو دارد:
\begin{enumerate}
\item اکتور سابقه به وسیله‌ی درخواست‌هایی، تعیین کند که ترم مربوط به این سابقه همان ترم مورد درخواست در معدل است یا خیر، و نیز تعداد واحد‌های درس چند است. و  در ادامه با ترکیب این اطلاعات با نمره‌ی سابقه، خود پاسخ اکتور دانشجو را ارسال کند.
\item اکتور سابقه نمره را در پاسخ قرار دهد ولی با توجه به اینکه پاسخ هنوز کامل نیست (هنوز معلوم نیست که درس چند واحدی است و آیا مربوط به ترم درخواستی است یا خیر)، به جای اینکه پاسخ را برای دانشجو پس بفرستد، آن را برای تکمیل به اکتور ارائه منتقل کند.
\end{enumerate} 
در این رویکرد فرض بر انتخاب اول است، یعنی اینکه خود اکتور سابقه، با گرفتن اطلاعات مورد نیاز از ارائه، پاسخ دانشجو را ارسال می‌کند.\\
برای این کار اکتور سابقه پیغام GPAInfoRequest را برای اکتور ارائه ارسال می‌کند و منتظر دریافت پاسخ می‌ماند. اکتور ارائه با دریافت GPAInfoRequest دو پیغام به صورت زیر به ترتیب برای اکتور ترم و اکتور درس ارسال می‌کند و منتظر پاسخ آنها می‌ماند:
\begin{latin}
 \begin{description}
 \item[\lr{IsYourTermRequest(term: Term)}]
  \item[\lr{NumOfUnitsRequest}]
 \end{description}
 \end{latin}
هدف از درخواست اول این است که مشخص شود که  درسی که سابقه به آن متعلق است، متعلق به همان ترمی است که معدل برای‌ آن درخواست شده یا خیر (اگر جواب خیر باشد نمره‌ی درس در معدل در نظر گرفته نخواهد شد). پیغام دوم هم تعداد واحد‌های درس را از اکتور درس درخواست می‌کند. ترم و درس به سادگی به این دو پیغام پاسخ می‌دهند و ارائه با گرفتن پاسخ‌ها، اطلاعات آنها را تجمیع\footnote{منظور از تجمیع در اینجا این است که  پاسخ فرضی true برای پیغام \lr{IsYourTermRequest(term)} و پاسخ فرضی 3 برای پیغام \lr{NumOfUnitsRequest} را که به ترتیب از اکتورهای ترم و درس گرفته شده، به صورت پیغام \lr{GPAInfoResponse(isForTerm=true,grade=null,unit=3)} باهم ترکیب می‌کند.} کرده و برای اکتور سابقه ارسال می‌کند.  سابقه با دریافت این پیغام، به تمام اطلاعات لازم برای این که پاسخ اکتور دانشجو را بدهد، دسترسی دارد. بنابراین می‌تواند با اضافه کردن مقدار فیلد نمره‌ی خود به پیغام آن را برای دانشجو ارسال کند. دانشجو با گرفتن این پاسخ، یکی از نمره‌های لازم برای محاسبه‌ی معدل را در دست دارد. بقیه‌ی نمره‌ها از تکرار همین عملیات برای تمام اکتورهای سابقه‌ی مربوط به دانشجو به طور مشابه به دست می‌آیند. در نهایت اکتور دانشجو با جمع نمراتی که مربوط به ترم درخواستی بوده‌اند (که از مقدار فیلد isForTerm از پیغام‌های پاسخ قابل تشخیص است) و تقسیم آن بر جمع واحد‌های مربوط به ترم (فیلد units پیغام پاسخ) معدل را محاسبه کرده و برای اکتوری که درخواست معدل داده ارسال می‌کند.
   شکل \ref{fig:gpa1_sequence} نمودار ترتیب\LTRfootnote{sequence diagram} برای پیغام‌های مبادله شده در این رویکرد را در قالب یک مثال نشان می‌دهد. در بخشی از این مثال که در شکل قابل مشاهده است فرض شده ترم مربوط به درخواست معدل باشد و تعداد واحد‌های درس ۳ باشد. نمره‌ی سابقه‌ای که درخواست برای آن ارسال شده ۱۲ است. درنهایت پس از تکرار حلقه‌ی مشخص شده در شکل و ارسال پیغام‌‌ها به تمام سابقه‌ها عدد فرضی ۱۵/۲۵ به عنوان معدل محاسبه شده و به صورت پیغام ارسال شده است. لازم به ذکر است که در این شکل برای سادگی نمایش فرض شده که تکرارهای حلقه برای سابقه‌های مختلف انجام شده است و طبیعتا استاندارد یو‌ام‌ال برای آن به طور کامل رعایت نشده است.

\begin{figure*}
    \begin{center}
	\includegraphics[width=16cm]{4-ProposedFramework/Figures/gpa_1_sequence.pdf}
    \end{center}
    \caption{\label{fig:gpa1_sequence} نمودار ترتیب برای رویکرد اول محاسبه‌ی معدل }
\end{figure*}
\FloatBarrier
در این بخش از طراحی لازم است به دو پرسش مهم پاسخ دهیم:\\
پرسش اول این است که در هر کدام از قسمت‌های طراحی که یک اکتور پیغام را فرستاده و منتظر جواب می‌ماند، آیا اکتور می‌تواند در طول مدت انتظار به فعالیت‌های دیگربپردازد؟ به عبارت بهتر، \textbf{آیا ارسال پیغام‌ها به صورت همگام است یا ناهمگام؟}\\
پرسش دوم این است که در صورتی که ارسال پیغام ناهمگام باشد ادامه‌ی فعالیت اکتور به چه صورتی مجاز است؟ آیا می‌تواند پیغام‌های جدیدی دریافت کند و به اجرای منطق مربوط به آنها بپردازد؟\\
برای پاسخ به این پرسش‌ها در رویکرد اول، در هر مورد که پیغامی دریافت و فرستاده می‌شود این پرسش‌ها را بررسی می‌کنیم:
\begin{enumerate}
\item اکتور دانشجو:\\
تنها پیغامی که اکتور دانشجو تا این مرحله از طراحی ارسال می‌کند پیغام GPAInfoRequest است. ابتدا منطق پیاده‌سازی شده در این تبادل این پیغام را بررسی ‌می‌کنیم:\\
 شبه کد \ref{fig:usecases:gpa:1:student_sync} تبادل پیغام‌های دانشجو با اکتور‌های سابقه را نشان می‌دهد. در این قطعه‌کد از دستور \lr{?!} (تبادل همگام) برای فرستادن پیغام استفاده شده است. اکتور دانشجو به هر اکتور سابقه یک پیغام GPAInfoRequest می‌فرستد و با دریافت هر پاسخ GPAInfoResponse این عملیات را انجام می‌دهد:
در صورتی که فیلد isForTerm از پیغام مقدار true داشته باشد مجموع وزن‌دار\footnote{عددی که از جمع حاصل‌ضرب هر نمره در تعداد واحدهای درس حاصل شده است.} نمرات گرفته شده تا حال را با حاصل ضرب فیلد grade در فیلد units جمع می‌کند. و حاصل جمع واحد‌ها را به اندازه‌ی units افزایش می‌دهد. نهایتا بعد از مبادله‌ی پیغام با تمام اکتور‌های سابقه، حاصل تقسیم  مجموع وزن‌دار نمرات بر تعداد واحد‌ها به عنوان معدل دانشجو در ترم اعلام می‌شود.
\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/Student_sync.scala}{شبه‌کد اسکالا برای اکتور دانشجو در رویکرد ۱ با ارسال همگام پیغام}{fig:usecases:gpa:1:student_sync} 

حال پرسش اول برای اکتور دانشجو به این صورت بیان می‌شود:\\
آیا اکتور دانشجو بعد از ارسال پیغام GPAInfoRequest به یک اکتور سابقه و در مدتی که هنوز پاسخی از این اکتور دریافت نکرده می‌تواند به فعالیت خود ادامه دهد؟ ابتدا باید به این نکته دقت کرد که تفاوت اصلی رویکرد حاصل از پاسخ مثبت به این پرسش (ارسال ناهمگام) و پاسخ منفی به آن (ارسال همگام) از دیدگاه اکتور فرستنده‌ی درخواست چیست؟ با کمی دقت و تحلیل می‌توان دریافت که تفاوت اصلی این دو رویکرد از دیدگاه فرستنده در نحوه‌ی برخورد با پاسخ پیغام است. به بیان دقیق‌تر در حالت همگام، این که پاسخ دریافت شده مربوط به کدام درخواست بوده است، به طور ضمنی مشخص است. ولی اگر بعد از ارسال پیغام، اکتور منتظر جواب نماند و به کار خود ادامه دهد در هر زمان دیگری ممکن است پاسخ دریافت شود و در این هنگام امکان اینکه تشخیص داده شود این پاسخ مربوط به کدام درخواست بوده ممکن است امکان‌پذیر نباشد. دقت به منطق پیاده شده برای دریافت پیغام GPAInfoResponse نشان می‌دهد که اینکه هر پاسخ مربوط به کدام درخواست بوده اهمیتی ندارد. به بیان دیگر ترتیب دریافت این پاسخ‌ها تاثیری در معدل اعلام شده ندارد. بنابراین پاسخ به پرسش اول در مورد اکتور دانشجو مثبت است. \\
\textbf{نتیجه:}
می‌توانیم پیغام‌های GPAInfoRequest را به صورت ناهمگام ارسال کنیم.\\
اکنون نوبت به پرسش دوم می‌رسد: آیا اکتور دانشجو در حالی که هنوز پاسخ تمام پیغام‌ها را دریافت نکرده می‌تواند درخواست جدیدی را پردازش کند؟\\
برای پاسخ به این پرسش فرض می‌کنیم که اکتور دانشجو در حالی که پاسخ تعدادی از پیغام‌های GPAInfoRequest را دریافت نکرده، یک پیغام جدید \lr{GPARequest} دریافت می‌کند (یک درخواست جدید برای محاسبه‌ی معدل). برای محاسبه‌ی معدل، اکتور دانشجو مطابق منطق پیاده شده اقدام به ارسال پیغام GPAInfoRequest به تمام اکتور‌های سابقه می‌کند. در این حالت فرض کنیم یک پیغام پاسخ GPAInfoResponse دریافت شود. با دریافت این پیغام باید متغیرهای محلی اکتور دانشجو به هدف محاسبه‌ی معدل بروزرسانی می‌شوند. اما با توجه به اینکه مشخص نیست که پاسخ دریافت شده مربوط به کدام در خواست بوده است نمی‌توانیم معدل را به صورت صحیح محاسبه کنیم. به عبارت دیگر منطق محاسبه‌ی معدل برای دو درخواست باهم مخلوط می‌شوند. به همین دلیل پاسخ به پرسش دوم منفی است.\\
\textbf{نتیجه:}
علیرغم اینکه ارسال پیغام‌های GPAInfoRequest را می‌توانیم به صورت ناهمگام انجام دهیم (چون ترتیب دریافت پیغام‌ها اهمیتی ندارد)، قبل از دریافت همه‌ی پاسخ‌های مربوط به درخواست معدل درحال پردازش، نمی‌توانیم درخواست جدیدی دریافت کنیم.\\
البته باید دقت کرد که با وجود اینکه میزان به تعویق انداختن دریافت پاسخ‌ها محدود است (به دلیل پرسش دوم)، کماکان ارسال ناهمگام پیغام‌های  GPAInfoRequest ارزشمند است. چرا که در حالت تبادل ناهمگام، تمام اکتورهای سابقه، به صورت همروند پاسخ این پیغام را آماده می‌کنند در حالی که در حالت همگام به صورت نوبتی و ترتیبی این اتفاق می‌افتد.\\
با توجه به پاسخ به این دو پرسش، طراحی اکتور دانشجو برای محاسبه‌ی معدل به صورت شبه‌کد شکل \ref{fig:usecases:gpa:1:student_Async} تغییر می‌کند. در این شبه‌کد از روش تبادل پیغام  \gls{آینده}\LTRfootnote{Future} (رجوع کنید به بخش \ref{section:scalaActorLib}) استفاده شده است.

\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/Student_Async.scala}{شبه‌کد اسکالا برای اکتور دانشجو در رویکرد ۱ با ارسال ناهمگام پیغام (آینده)}{fig:usecases:gpa:1:student_Async} 

 \FloatBarrier
% در واقع این حالت، رویکرد پیش‌فرض در طراحی به روش شیءگرا است. ارسال پیغام همگام در مدل اکتور در واقع معادل با فراخوانی یک متد در مدل شیءگرای ترتیبی است. و این خاصیت طراحی ترتیبی زیربنای نحوه‌ی استدلال در مورد طرز کار طراحی است. در طراحی ترتیبی اطمینان داریم که تفاوت حالت شیء قبل از  فراخوانی یک متد و بعد از آن، صرفا به منطق پیاده شده در داخل متد وابسته است و خارج از آن هیچ تغییر دیگری رخ نخواهد داد. در صورتی که در طراحی همروند به صورت ناهمگام، این‌گونه نیست.
\item اکتور سابقه:\\
در مورد اکتور سابقه جواب دادن به ۲ پرسش مذکور آسان‌تر است. این اکتور فقط پیغام GPAInfoRequest را ارسال می‌کند و با دریافت هر پیغام پاسخ GPAInfoResponse، صرفا نمره‌ی سابقه را به آن اضافه کرده و برای اکتور دانشجو ارسال می‌کند. واضح است که در این تبادل پیغام، ترتیب پیغام‌‌های پاسخ اهمیتی ندارد. بنابراین پاسخ اولین پرسش مثبت است (ارسال ناهمگام مجاز است). در مورد پرسش دوم با اینکه این اکتور هیچ حالتی\LTRfootnote{state} برای درخواست‌ها نگه نمی‌دارد.\footnote{بر خلاف حالت اکتور دانشجو که در آن متغیر‌هایی برای هر درخواست مقداردهی می‌شدند.} اما دریافت درخواست جدید قبل از گرفتن پاسخ‌های درخواست قبلی  مشکل دیگری ایجاد می‌کند. با توجه به اینکه  هر درخواست که از اکتور دانشجو به اکتور سابقه می‌رسد، نهایتا باید توسط خود اکتور سابقه پاسخ داده شود، در هنگام فرستادن پیغام پاسخ باید آدرس فرستنده‌ی درخواست اولیه موجود باشد. در حالی که اگر قبل از پاسخ به درخواست اکتور دانشجو، درخواست جدیدی دریافت شود و عملیات پردازش درخواست جدید آغاز گردد، هیچ اثری از فرستنده‌ی 
درخواست اول برای ارسال پاسخ به آن موجود نخواهد بود. برای روشن شدن مطلب، شبه‌کد  \ref{fig:usecases:gpa:1:studyrec_Async_wrong} را در نظر بگیرید که در آن فرض شده اکتور سابقه بتواند قبل از فرستادن پاسخ درخواست قبلی، درخواست جدیدی را پردازش کند. همان‌طور که در خط ۱۱ کد اشاره شده است، در هنگامی‌که یک پاسخ از اکتور ارائه دریافت شده، دسترسی به اکتور فرستنده‌ی پیغام اصلی (که در خط ۸ دریافت شده) وجود ندارد تا بتوانیم پاسخ را برای آن ارسال کنیم. باید دقت شود که با اینکه فرستنده‌ی یک پیغام به وسیله‌ی شیء sender قابل دسترسی است، اما این شیء به فرستنده‌ی پیغامی اشاره می‌کند که پیغام آن در حال پردازش است. در مورد خط ۱۱ این شیء اشاره به اکتور ارائه دارد که فرستنده‌ی آخرین پیغام بوده، نه اکتور دانشجو که در انتظار گرفتن پاسخ از اکتور سابقه است. بنابراین پاسخ به پرسش دوم در مورد اکتور سابقه منفی است و این اکتور باید پاسخ هر درخواست را قبل از  پردازش درخواست‌های دیگر ارسال کند. نکته‌ی قابل توجه این است که با توجه به اینکه اکتور سابقه برای پاسخ به درخواست GPAInfoRequest تنها یک پیغام ارسال می‌کند و بدون دریافت پاسخ آن قادر به پاسخگویی به درخواست مذکور نیست، تفاوتی در ارسال همگام و ناهمگام پیغام وجود ندارد چرا که پس از ارسال تنها یک پیغام مجبور به توقف و انتظار برای دریافت پاسخ است. شبه کد \ref{fig:usecases:gpa:1:studyrec_Async_right} طراحی صحیح تبادل پیغام در اکتور سابقه را برای رویکرد ۱ نشان می‌دهد.

\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/StudyRecord_Async_wrong.scala}{شبه‌کد اکتور سابقه برای حالتی که بتواند قبل از پاسخ به درخواست قبلی، درخواست جدیدی را پردازش کند. (این رویکرد اشتباه است.)}{fig:usecases:gpa:1:studyrec_Async_wrong} 

\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/StudyRecord_Async_right.scala}{شبه‌کد صحیح برای  اکتور سابقه در رویکرد ۱}{fig:usecases:gpa:1:studyrec_Async_right} 

\FloatBarrier
\item اکتور ارائه:\\
اکتور ارائه پس از دریافت درخواست GPAInfoRequest دو پیغام به ترتیب برای اکتور‌های ترم و درس ارسال می‌کند و در هر کدام از این دو پیغام بخشی از اطلاعات لازم برای فرستادن پاسخ به اکتور سابقه را از آنها دریافت می‌کند.
پرسش اول در مورد اکتور ارائه اینطور مطرح می‌شود که آیا اکتور ارائه پس از فرستادن هر کدام از پیغام‌های مذکور به ترم و درس می‌تواند پیغام بعدی را ارسال کند یا باید پس از ارسال هرکدام بلافاصله منتظر دریافت پاسخ بماند؟ جواب این پرسش مثبت است به این دلیل که ترتیب پیغام‌های پاسخ اهمیتی ندارد. اما با استدلالی مشابه آنچه که در مورد اکتور سابقه توضیح داده شد، جواب پرسش دوم برای اکتور ارائه منفی است. یعنی اکتور ارائه تا زمانی که پاسخ یک درخواست را به اکتور سابقه‌ی مربوطه نفرستاده، نمی‌تواند درخواست جدیدی (احتمالاً از یک اکتور سابقه‌ی دیگر) پردازش کند. به همین دلیل حداکثر میزان ناهمگامی در ارسال پیغام‌ها برای اکتور ارائه این است که دو پیغام IsYourTermRequest و  NumOfUnitsRequest را به صورت ناهمگام برای اکتورهای ترم و درس ارسال کند و سپس منتظر دریافت پاسخ آنها بماند. بنابراین طراحی تبادل پیغام اکتور ارائه در رویکرد ۱ مطابق شبه‌کد شکل \ref{fig:usecases:gpa:1:offering_Async_right}  خواهد بود. در این شکل نیز از ویژگی آینده\LTRfootnote{Future} (رجوع کنید به \ref{section:scalaActorLib}) استفاده شده است.
\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/Offering_Async_right.scala}{شبه‌کد طراحی نحوه‌ی تبادل پیغام برای  اکتور ارائه در رویکرد ۱.}{fig:usecases:gpa:1:offering_Async_right} 
\FloatBarrier
\item اکتورهای ترم و درس:\\
در مورد  این دو اکتور تصمیم به استفاده از ارسال همگام یا ناهمگام بسیار ساده است. با توجه به اینکه در هر دو اکتور مذکور، تمام اطلاعات لازم برای پاسخ به درخواست‌ها در خود اکتور موجود است، نیازی به ارسال پیغام به سایر اکتورها وجود ندارد و پاسخ درخواست‌ها بلافاصله ارسال می‌شود. لذا هیچ نیازی به تبادل همگام وجود ندارد (چون پاسخی دریافت نخواهد شد). طراحی این دو اکتور از نظر تبادل پیغام در شبه‌کدهای \ref{fig:usecases:gpa:1:term}  و \ref{fig:usecases:gpa:1:course}  نمایش داده شده است.
\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/Term.scala}{شبه‌کد طراحی نحوه‌ی تبادل پیغام برای  اکتور ترم در رویکرد ۱.}{fig:usecases:gpa:1:term} 
\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/1/Course.scala}{شبه‌کد طراحی نحوه‌ی تبادل پیغام برای  اکتور درس در رویکرد ۱.}{fig:usecases:gpa:1:course} 
\FloatBarrier

\end{enumerate}

\subsubsection{رویکرد دوم}
\label{gpa_approch2}
رویکرد دوم از طراحی مورد کاربرد محاسبه‌ی مدل را با بررسی رویکرد ۱ و طرح چند پرسش در مورد آن آغاز می‌کنیم. نحوه‌ی طراحی ارتباطات و پیغام‌ها در رویکرد اول در بخش قبل به طور کامل توضیح داده شد. در این قسمت خلاصه‌ای از این طراحی را بررسی می‌کنیم:\\
عملیات با دریافت پیغام درخواست معدل \lr{GPARequest(term)} در اکتور دانشجو آغاز می‌شود. اکتور دانشجو به هر کدام از اکتورهای سابقه، یک پیغام درخواست اطلاعات معدل \lr{GPAInfoRequest(term)} ارسال می‌کند. این پیغام از طریق اکتور سابقه به دست اکتور ارائه می‌رسد و از طریق این اکتور به دست اکتورهای درس و ترم می‌رسد و هر کدام از این اکتورها اطلاعات لازم را برای اکتور ارائه ارسال می‌کنند. در ادامه اکتور ارائه یک پیغام پاسخ اطلاعات معدل \lr{(GPAInfoResponse)}  تولید می‌کند و برای اکتور سابقه ارسال می‌کند. سابقه عدد نمره را به پیغام اضافه کرده و برای دانشجو می‌فرستد. دانشجو با تکرار همین عملیات برای تمام سابقه‌ها تمام اطلاعات لازم برای محاسبه‌ی معدل در اختیار دارد.\\
هر اکتور در این مورد کاربرد به دلایل مختلفی اقدام به مشارکت در محاسبه‌ی معدل می‌کند: دانشجو به این دلیل که مسئولیتِ گرفتن درخواست اصلی را دارد و نیز به این دلیل که به اکتور سابقه دسترسی دارد. اکتور سابقه به این دلیل که نمره (یکی از اطلاعات لازم برای محاسبه‌ی معدل) را در اختیار دارد و نیز از طریق اکتور ارائه به درس و ترم دسترسی دارد. اکتور ارائه به دلیل دسترسی به درس و ترم. و اکتورهای درس و ترم به دلیل اینکه اطلاعات مورد نیاز برای محاسبه‌ی معدل را در اختیار دارند. در نتیجه مشارکت تمام این اکتورها در محاسبه‌ی معدل ضروری است. اما پرسشی که پیش می‌آید این است که آیا میزان مشارکت این اکتورها نیز باید در همین میزان باشد؟ اگر هر دریافت یا ارسال یک نوع پیغام را یک مشارکت برای اکتور در طراحی این مورد کاربرد در نظر بگیریم، آیا می‌توان تعداد مشارکت‌های اکتورها را کاهش داد؟ به عنوان مثال اکتور سابقه را در نظر می‌گیریرم. همان‌طور که ذکر شد مشارکت این اکتور به دلیل داشتن فیلد نمره و نیز دسترسی به اکتور ارائه ضروری است. تعداد مشارکت اکتور  سابقه با توجه به تعریف ارائه شده، از روی نمودار ترتیب شکل \ref{fig:gpa1_sequence} به این ترتیب قابل استخراج است: هر فلشی که از خط زمان\LTRfootnote{time line} اکتور سابقه خارج یا به آن وارد می‌شود معادل ارسال یا دریافت یک نوع پیغام است. بنابراین تعداد مشارکت اکتور سابقه در این مورد کاربرد ۴ است. مشارکت اول مربوط به دریافت پیغامِ درخواست از دانشجو است، مشارکت دوم مربوط به ارسال درخواست به ارائه است، مشارکت سوم دریافت پاسخ از ارائه و مشارکت چهارم مربوط به ارسال پاسخ به دانشجو است. حال بررسی می‌کنیم که از این تعداد مشارکت، دو مورد الزامی است. یکی دریافت درخواست از دانشجو به دلیل اینکه دانشجو از طریق دیگری به اطلاعات مورد نیاز برای محاسبه‌ی معدل دسترسی ندارد، و دیگری ارسال درخواست برای ارائه. دو مورد دیگر یعنی دریافت پاسخ ارائه و تحویل آن به دانشجو را می‌توان حذف کرد. روش حذف به این صورت است که اکتور ارائه به نحوی مطلع شود که جواب نهایی به چه کسی ارسال خواهد شد (دانشجو). این کار از طریق \textbf{قرار دادن مقصد نهایی پیغام در داخل پیغام} قابل انجام است. در این حالت دیگر نیازی به برگشت پیغام به دست سابقه وجود ندارد. تنها موردی که موردی که به نظر مشکل‌ساز می‌آید این است که فیلد نمره در رویکرد ۱ در هنگام برگشت پیغام در  آن قرار داده می‌شود و اگر پیغام از طریق سابقه برگشت داده نشود فیلد نمره را نخواهد داشت. البته این مورد به سادگی قابل حل است و در همان بار اول که پیغام به دست سابقه رسید، می‌تواند نمره را به پیغام اضافه کند. البته مثال اکتور سابقه در مورد بقیه‌ی اکتورها نیز قابل بررسی است ولی به دلیل پرهیز از تکرار استدلال به همین مورد اکتفا می‌کنیم.\\
مورد دیگری که در رویکرد ۱ بررسی می‌کنیم عدم امکان پردازش درخواست‌های جدید در هنگام انتظار برای تکمیل اطلاعات مورد نیاز برای پاسخ به درخواست قبلی است. مثلا در مورد دانشجو این مورد باعث شد که در رویکرد ۱، دانشجو قبل از ارسال پاسخ درخواست معدل،‌ درخواست دیگری را بررسی کند. در مورد دانشجو دلیل این پدیده این بود که منطق محاسبه‌ی معدل قسمتی از حالت\LTRfootnote{state} این اکتور بود و تداخل درخواست‌های معدل می‌تواند باعث عملکرد غلط اکتور شود. یک راه برای حل این مشکل این است که به نوعی مشخص کنیم که هر پاسخی که اکتور دانشجو دریافت می‌کند مربوط به کدام درخواست اصلی بوده‌ است. یعنی حالت اکتور را در قالب نگاشت‌هایی از پیغام‌ها حفظ کنیم. مثلا برای اکتور دانشجو، به جای اینکه یک متغیر برای مجموع نمره‌هایی که تا این لحظه پاسخ آنها بررسی شده (رجوع کنید به شبه‌کد شکل \ref{fig:usecases:gpa:1:student_Async})، می‌توانیم نگاشتی\LTRfootnote{map} از شناسه‌ی درخواست معدل به متغیر مجموع نگهداری کنیم، به این ترتیب با رسیدن یک پاسخ، متغیر مربوط به درخواست مربوطه برای محاسبه استفاده می‌شود. البته این روش اولاً باعث پیچیده‌تر شدن منطق اکتور می‌شود و ثانیاً نگهداری ساختار داده‌ی نگاشت اهمیت زیادی پیدا می‌کند. به این دلایل استفاده از نگاشت رویکرد مناسبی نیست. روش دیگر این است که به حالت مربوط به بررسی یک درخواست را به اکتور دیگری که به همین منظور ایجاد می‌شود، منتقل کنیم. مثلا وقتی دانشجو یک درخواست محاسبه‌ی معدل دریافت می‌کند، یک اکتور مختص همان درخواست ایجاد کنیم و همه‌ی تبادلات مربوط به آن درخواست را به اکتور جدید واگذار کنیم. طبیعتا تمام اطلاعات لازم از جمله دسترسی به اکتور سابقه باید به اکتور جدید منتقل شود. در نتیجه‌ی این رویکرد، دانشجو می‌تواند با دریافت هر درخواست معدل بلافاصله به پردازش آن بپردازد.\\
با توجه به موارد ذکر شده و بدون تکرار نکاتی که در رویکرد اول ذکر شد به ارائه‌ی خلاصه‌ای از طراحی اکتورها در رویکرد دوم می‌پردازیم.
شکل \ref{fig:gpa2_sequence} نمودار ترتیب برای رویکرد دوم محاسبه‌ی معدل را نشان ‌می‌دهد. برای پرهیز از تکرار، در این رویکرد مراحل طراحی معرفی شده در رویکرد اول بسط داده نشده است و صرفاً چند تغییر اساسی توضیح داده می‌شود.

\begin{figure*}
    \begin{center}
	\includegraphics[width=16cm]{4-ProposedFramework/Figures/gpa_2_sequence.pdf}
    \end{center}
    \caption{\label{fig:gpa2_sequence} نمودار ترتیب برای رویکرد دوم محاسبه‌ی معدل }
\end{figure*}
\FloatBarrier
\begin{enumerate}
\item اکتور محاسبه‌ی معدل \lr{(GPAActor)}:\\
همان طور که قبلا توضیح داده شد، این اکتور برای انجام کل فعالیت‌های مربوط به یک درخواست معدل را انجام می‌دهد (در رویکرد اول این‌ کار توسط خود اکتور دانشجو انجام می‌شد).  این اکتور برای انجام وظیفه‌ی خود اولاً نیاز به برقراری ارتباط با اکتورهای سابقه دارد، و ثانیاً نیاز به دسترسی به مقصد پاسخ درخواست دارد تا بتواند نتیجه را برای آن ارسال کند. این موارد توسط اکتور دانشجو در اختیار اکتور محاسبه‌ی معدل قرار می‌گیرد. شبه کد \ref{fig:usecases:gpa:2:gpaActor} نحوه‌ی طراحی این اکتور را نشان می‌دهد. اکتور محاسبه‌ی معدل با شروع به کار پیغام‌های لازم برای سایر اکتور‌ها را ارسال می‌کند و با گرفتن هر پاسخ، متغیر‌های حالت خود را بروزرسانی می‌کند. پایان کار این اکتور زمانی مشخص می‌شود که به تعدادی که پیغام ارسال کرده پاسخ دریافت کند. این تعداد برابر با تعداد اکتورهای سابقه است. بنابراین پس از دریافت این تعداد پیغام، معدل محاسبه شده را برای مقصد نهایی ارسال می‌کند.

\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/2/GPAActor.scala}{شبه‌کد طراحی اکتور محاسبه‌ی معدل در رویکرد ۲.}{fig:usecases:gpa:2:gpaActor} 

تغییر مهم اکتور دانشجو این است که با توجه به واگذاری عملیات محاسبه‌ی معدل به اکتوری دیگر، نیازی به نگهداری متغیرهای حالت که به این منظور ایجاد شده بودند، ندارد. شبه کد 
اکتور دانشجو در رویکرد جدید در شکل \ref{fig:usecases:gpa:2:student}  نشان داده شده است. مقایسه‌ی طراحی این اکتور در دو رویکرد نشان می‌دهد که با انجام این عمل، طراحی اکتور دانشجو بسیار ساده‌تر شده است.

\codelisting[language=scala]{4-ProposedFramework/src/usecases/gpa/2/Student.scala}{شبه‌کد طراحی اکتور دانشجو در رویکرد ۲.}{fig:usecases:gpa:2:student} 
\FloatBarrier

\end{enumerate}
%۱: نقش سابقه در این پیغام‌ها چیه؟ یکی اینکه نمره دست اونه و دیگه اینکه راهیه که به بقیه اطلاعات برسیم. اولی باعث می‌شه که حتما به دست اون برسه. ولی آیا اینکه جواب اول دست سابقه برسه بعد به دانشجو برسه الزامیه؟ با توجه به اینکه یک بار از زیر دستش رد می‌شه و دفعه‌ی دوم فقط relay می‌کنه.
%۲: یادآوری سوال ۲ بخش قبل. تاکید بر اینکه این بده چون ما همروندی رو پایین میاریم. آیا راهی برای این کار وجود نداره؟ یه اکتور درست می‌کنیم که فقط اینو ....
%۳: هیچ جا نمی‌شه مسیرو کوتاهتر کرد؟ زودتر جواب آخر رو فرستاد؟ منظور اینه که از domain بفهمیم. در این مورد اگر مربوط به ترم نباشه اصلا حساب نمی‌شه. پس اگه ترم ۱ سره بتونه جواب بده خیلی خوبه.
\subsubsection{مقایسه‌ی دو رویکرد}
در بخش‌های قبلی ۲ رویکرد متخلف برای طراحی اکتورها در ارتباط با مورد کاربرد محاسبه‌ی معدل معرفی شده و مراحل انجام طراحی در آنها شرح داده شد. علیرغم صحت عملکرد هر دو رویکرد، تفاوت‌های کیفی در طراحی به وسیله‌ی این دو رویکرد حائز اهمیت هستند. به همین دلیل در این بخش به مقایسه‌ی این دو رویکرد می‌پردازیم.\\
رویکرد دوم دو تغییر عمده نسبت به رویکرد اول دارد:
\begin{enumerate}
\item قرار دادن مقصد نهایی درخواست در داخل پیغام:\\
در رویکرد اول هر اکتوری که پیغامی را به عنوان درخواست از یک اکتور دیگر دریافت می‌کند، وظیفه‌ی پاسخ به آن را نیز به عهده دارد. در صورتی که برای پاسخ به درخواست نیاز به برقراری ارتباط با اکتورهای دیگر وجود داشته باشد،‌این اکتور اقدام به ارسال پیغام‌های مرتبط به سایر اکتورها می‌کند و در نهایت با جمع‌آوری پاسخ‌ها، درخواست اصلی را پاسخ می‌دهد. با اینکه این رویکرد از دیدگاه طراحی شیءگرا به روش ترتیبی،‌ رویکردی متداول و حتی اجباری است\footnote{در طراحی شیءگرای ترتیبی، مکانیزم کنترل برنامه فراخوانی متد است. با هر فراخوانی متد، منطق پیاده شده در متد اجرا می‌شود و پس از بازگشت از متد، اجبارا کنترل برنامه به همان قسمتی که متد فراخوانی شده بود برمی‌گردد.}، در مدل تبادل پیغام این امکان وجود دارد که پاسخ درخواست را اکتوری غیر از دریافت کننده‌ی درخواست ارسال کند. لازم به ذکر است که در مدل اکتور هیچ فرضی در مورد مشخصات فرستنده‌ی پیغام صورت نمی‌گیرد. بنابراین یک اکتور می‌تواند به جای اینکه پس از ارسال پیغام‌های مربوط به یک درخواست، منتظر دریافت جواب برای فرستادن به درخواست کننده بماند،‌ آدرس (نام) مقصد نهایی را در داخل پیغام برای اکتور ها ارسال کند تا در صورت لزوم از آن برای فرستادن نتیجه استفاده کنند. رویکرد دوم در واقع از این امتیاز استفاده کرده و به این روش از تعدادی از تبادلات پیغام که صرفاً به دلیل ذکر شده صورت می‌گیرند، جلوگیری می‌کند. با این کار نیازی به برگشت پیغام در همان مسیری که طی شده وجود نخواهد داشت و در هر لحظه که اطلاعات لازم برای تکمیل پاسخ تأمین شود، پاسخ به مقصد ارسال خواهد شد.
\item واگذار کردن پردازش‌های مربوط به یک درخواست به یک اکتور موقت:\\
 در رویکرد اول اکتور دانشجو، پس از ارسال پیغام‌های لازم و دریافت جواب، تمام محاسبات لازم برای تعیین معدل را انجام ‌می‌داد. در اثر استفاده از این رویکرد، اولاً دانشجو باید تعدادی پیغام برای تهیه‌ی اطلاعات لازم جهت محاسبه‌ی معدل به سایر اکتورها ارسال کرده و منتظر جواب بماند، ثانیاً برای محاسبه‌ی معدل اطلاعات موقتی را به عنوان متغیر حالت در خود نگهداری کند. مقدار این متغیر‌ها فقط در زمانی که یک درخواست مشخص در حال پردازش است معتبر است به همین دلیل در صورت شروع به پردازش درخواست‌های دیگر قبل از اتمام عملیات مربوط به درخواست قبلی امکان‌پذیر نمی‌باشد. در نتیجه میزان همروندی در درخواست‌های مشابه پایین می‌آید. از طرف دیگر در صورتی که قرار باشد، اکتور انواع متعددی از درخواست‌هایی را که این خاصیت را دارند پردازش کند، مدیریت پیچیدگی حاصل از اطلاعات حالت مربوط به درخواست‌های مختلف نیز کار آسانی نخواهد بود و منجر به پیچیدگی زیاد  و تغییرپذیری کمتر کلاس خواهد شد. به همین دلایل در رویکرد دوم سیاست جدید اتخاذ شد و آن سپردن کل فعالیت‌های محاسبه‌ی معدل به یک اکتور جدید است. با این کار دو نتیجه‌ی مطلوب حاصل می‌شود. اولاً پیچیدگی‌های مربوط به اجرای یک درخواست به اکتور دیگری منتقل می‌شود که صرفاً برای پاسخ به درخواست مورد نظر طراحی شده است. ثانیا با توجه به اینکه هر نمونه از اکتور جدید صرفاً محدود به یک درخواست بوده و پس از پاسخ به‌ آن به فعالیت خاتمه می‌دهد، امکان پاسخ به درخواست‌های همروند به درخواست‌ها هم به وجود می‌آید.
\end{enumerate}
لازم به ذکر است که هدف از معرفی این دو رویکرد در طراحی منطق مربوط به محاسبه‌ی معدل صرفاً تأکید بر تفاوت‌های آنها و حفظ وضوح روش طراحی دارد. طبیعتاً علیرغم صحت رویکرد اول، در ادامه‌ی طراحی از سیاست‌های ذکر شده در رویکرد دوم استفاده خواهد شد
\subsection{مورد کاربرد اخذ درس}
\label{subsection:take_course_uc_design}
در بخش قبل مراحل طراحی مورد کاربرد محاسبه‌ی معدل با استفاده از دو رویکرد مختلف توضیح داده شد. در این بخش مراحل طراحی مورد کاربرد اخذ درس با توجه به تجربیات حاصل از بخش قبل ارائه می‌گردد. \\
توصیف مورد کاربرد اخذ درس در جدول \ref{table:uc_takecoure} ارائه شد. دانشجو در زمان انتخاب واحد یکی از ارائه‌\LTRfootnote{Offering}های موجود ترم را انتخاب می‌کند. سیستم شرایط لازم برای اخذ این ارائه را بررسی می‌کند. در صورتی که دانشجو مجاز به انتخاب این ارائه باشد، یک سابقه از ارائه‌ی مورد نظر را برای دانشجو ذخیره می‌کند. در صورتی که هر کدام از شرایط لازم برای اخذ محقق نشده باشد سیستم یک پیغام خطا برای کاربر نمایش می‌دهد.
همانند مورد کاربرد قبل،‌ این مورد کاربرد هم با دریافت یک پیغام توسط اکتور دانشجو آغاز می‌شود. تنها اطلاعاتی که در این پیغام باید موجود باشد ارائه‌ی انتخاب شده برای اخذ است. بنابراین فرمت پیغام درخواست اخذ درس به شکل زیر خواهد بود:
\begin{latin}
TakeCourseRequest(offering: Offering)
\end{latin}
پاسخ این درخواست نیز باید حاوی نتیجه‌ی عملیات و نیز احتمالاً یک پیغام برای کاربر خواهد بود. بنابراین پیغام پاسخ اخذ درس به فرمت زیر خواهد بود:
\begin{latin}
TakeCourseResponse(result: Boolean, comment: String)
\end{latin}
مطابق توضیحاتی که در طراحی مورد کاربرد محاسبه‌ی معدل داده ‌شد، اکتور دانشجو در مواجهه با پیغام درخواست اخذ دو راهکار کلی پیش رو دارد. راهکار اول این است که منطق مورد نیاز برای پردازش اخذ درس را خودش پیاده‌سازی کند (مانند رویکرد اول در طراحی مورد کاربرد محاسبه‌ی معدل) و راهکار دوم این است که به یک اکتور دیگر وکالت این محاسبات را بسپارد. همان‌طور که در بخش قبل ذکر شد،‌ تصمیم به سپردن محاسبات به کاربرد دیگر به دو انگیزه‌ی مختلف صورت می‌گیرد. انگیزه‌ی اول جلوگیری از پیجیده و بزرگ شدن یک اکتور در اثر پردازش پیغام‌های مختلف و انگیزه‌ی دوم ایجاد امکان همروندی در پردازش پیغام‌های مشابه.\\
در این مورد کاربرد هر دو انگیزه برای سپردن محاسبات به یک اکتور دیگر معتبر می‌باشند: اکتور دانشجو در مدل دامنه‌ی معرفی شده، مسئولیتِ دریافت اکثر درخواست‌های کاربران را به عهده دارد (به دلیل اینکه کاربر اصلی این سیستم دانشجو است)، درخواست‌های مختلفی را دریافت خواهد کرد. به همین دلیل در صورتی که  پردازش تمام این پیغام‌ها را بر عهده بگیرد، اندازه و پیچیدگی آن زیاد شده و در نتیجه تغییرپذیری آن تنزّل خواهد کرد (انگیزه‌ی اول). علاوه بر این، اکتور دانشجو برای پردازش هر درخواست اخذ درس، باید شروط مختلفی را بررسی کند و برای این کار با اکتورهای دیگر به دفعات تبادل پیغام انجام خواهد داد و برای حفظ نتایج میانی تبادلات پیغام تا پایان پردازش درخواست، مجبور به استفاده از متغیرهای حالت اکتور (فیلدهای داده‌ی محلی) خواهد بود (مشابه متغیرهایی که در محاسبه‌ی معدل استفاده شد). در نتیجه پردازش همروند درخواست‌های اخذ درس بسیار پیچیده و یا نشدنی خواهد بود. بنابراین در این مورد، ایجاد همروندی در پردازش درخواست‌ها نیز انگیزه‌ی معتبری برای سپردن محاسبات به یک اکتور دیگر است (انگیزه‌ی دوم). \\
\subsubsection{ اکتور اخذ درس}
\label{section:takeCourse}
با توجه به توضیحات ذکر شده اکتور دانشجو با گرفتن درخواست اخذ درس، کلیه‌ی محاسبات لازم و ارسال پاسخ را به اکتور اخذ درس منتقل می‌کند. وظیفه‌ی اکتور اخذ درس بررسی شرایط دانشجو برای اخذ درس و ارسال پاسخ درخواست است. طبق توصیف مورد کاربرد اخذ درس (جدول \ref{table:uc_takecoure})، شروطی که باید قبل از قبول اخذ درس بررسی شوند عبارتند از:
\begin{enumerate}
\item دانشجو در ترم‌های قبل درس مربوط به ارائه‌ی انتخاب شده را  نگذرانده باشد.
\item دانشجو در ترم‌ جاری این درس را اخذ نکرده باشد.
\item دانشجو تمام پیش‌نیاز‌های این درس را با موفقیت گذرانده باشد.
\item تعداد واحد‌های اخذ شده توسط دانشجو در این ترم پس از اخذ این درس بیشتر از ۲۰ نشود.
\end{enumerate}
در این مرحله، اکتور اخذ درس باید برای هریک از شروط ذکر شده، اولاً قالب پیغام مناسب را طراحی کند، ثانیاً مقصد پیغام را مشخص کند (تشخیص اکتور مسئول). این دو مورد باید برای هریک از چهار شرط فوق بررسی شوند. در ادامه بررسی این موارد برای شرط اول به صورت مبسوط بررسی می‌شود و برای سایر شروط با توجه به شباهت به شرط اول صرفاً نتیجه‌ی بررسی ارائه می‌گردد:
\begin{itemize}
\item شرط ۱:\\
 این شرط باید تعیین کند که دانشجو قبلاً سابقه‌ای از گذراندن این درس را دارد یا خیر. قبل از انتخاب قالب پیغام، بحثی در مورد پذیرنده‌ی پیغام (اکتور مسئول) می‌کنیم. گزینه‌های موجود برای اکتور مسئول بررسی شرط گذراندن درس باشد اینها هستند:
 \begin{enumerate}
 \item خود اکتور اخذ درس:\\
  انتخاب اول در واقع به این معنی است که اکتور اخذ درس به جای اینکه درخواستی برای بررسی گذرانده شدن درس ارسال کند،‌ خود این بررسی را به عهده بگیرد. البته این به این معنی نیست که برای انجام این بررسی هیچ پیغامی به اکتورهای دیگر ارسال نکند، بلکه به این معنی است که وظیفه‌ی پیاده‌سازی منطق لازم برای رسیدن به پاسخ این پرسش (آیا این دانشجو قبلاً این درس را گذرانده است؟) بر عهده‌ی اکتور اخذ درس باشد. این حالت به دو دلیل مناسب نیست: اولاً در این حالت اکتور اخذ درس به صورت ابتدا به ساکن (بدون دریافت درخواستی برای این کار) اقدام به پیاده‌سازی یک منطق کرده است. در نتیجه این پیاده‌سازی به جز این اکتور برای اکتور دیگری قابل استفاده‌ی مجدد نیست.
 \footnote{  البته یک راهکار ممکن برای برطرف کردن این مشکل این است که به اکتور اخذ درس، قابلیت دریافت پیغامی از نوع بررسی شرط مذکور اضافه شود و این اکتور برای بررسی این شرط، یک پیغام به خودش بفرستد تا به این صورت قابلیت استفاده‌ی مجدد داشته باشد. اما ایراد این رویکرد این است که از نظر منطقی اضافه کردن این رفتار به اکتوری که صرفاً وظیفه‌ی پاسخ به یک درخواست اخذ درس را دارد، از نظر تقسیم مسئولیت عمل درستی نیست.}
  ثانیاً با توجه به اینکه این اکتور شروط متعددی را بررسی می‌کند، پیاده کردن منطق بررسی این شروط خوانایی کلاس را کاهش می‌دهد. 
 
  البته یک راهکار ممکن برای برطرف کردن این مشکل این است که به اکتور اخذ درس، قابلیت دریافت پیغامی از نوع بررسی شرط مذکور اضافه شود و این اکتور برای بررسی این شرط، یک پیغام به خودش بفرستد تا به این صورت قابلیت استفاده‌ی مجدد داشته باشد. اما ایراد این رویکرد این است که از نظر منطقی اضافه کردن این رفتار به اکتوری که صرفاً وظیفه‌ی پاسخ به یک درخواست اخذ درس را دارد، از نظر تقسیم مسئولیت عمل درستی نیست. 
 \item اکتور جدیدی که به این منظور تولید می‌شود:\\
 این رویکرد ایرادهای شمرده شده برای انتخاب اول را ندارد. اما با فرض این که درخواست بررسی گذرانده شدن درس یک درخواست قابل استفاده‌ی مجدد در منطق دامنه‌ی سیستم باشد، با این رویکرد در هر قسمتی از برنامه که نیاز به بررسی این درخواست وجود داشته باشد، باید اکتوری به این منظور ایجاد شود و اطلاعات لازم به آن داده شود و سپس درخواست برای آن ارسال شود. از نظر طراحی شیءگرا، تکرار این عملیات در هر بار نیاز به این درخواست پدیده‌ی مطلوبی نمی‌باشد.
 \item اکتور دانشجو:\\
 انتخاب اکتور دانشجو برای ارسال درخواست بررسی گذرانده شدن درس علاوه بر اینکه ایرادهای مطرح شده در گزینه‌ی اول را ندارد، مشکل تکرار عملیات (گزینه‌ی دوم) را نیز ندارد. در این حالت، هر اکتوری که نیاز به بررسی درخواست گذرانده شدن درس را داشته باشد، پیغام مربوطه را برای اکتور دانشجو ارسال می‌کند و تنها جایی که عملیات ایجاد اکتور جدید برای پردازش این درخواست انجام می‌شود اکتور دانشجو است. از نظر منطق دامنه نیز بررسی گذرانده شدن درس توسط اکتور دانشجو انتخاب مطلوبی به نظر می‌رسد.
 \end{enumerate}
 با توجه به استدلال فوق، اکتور اخذ درس، اکتور دانشجو را به عنوان مسئول بررسی گذرانده شدن درس انتخاب می‌کند.\\
 با انتخاب مقصد پیغام درخواست بررسی گذرانده شدن درس، طراحی قالب پیغام آن به آسانی انجام می‌شود. با توجه به اینکه این پیغام به مقصد اکتور دانشجو ارسال می‌شود، تنها داده‌ای که لازم است در آن قرار داده شود درس مربوطه است. بنابراین قالب پیغام درخواست به صورت زیر می‌باشد:
 \begin{latin}
 PassedRequest(course:Course)
 \end{latin}
 پیغام پاسخ کافی‌ است که اطلاع دهد که درس مورد نظر گذرانده شده است یا خیر. بنابراین قالب پیغام پاسخ به صورت زیر می‌باشد:
 \begin{latin}
PassedResponse(result:Boolean)
 \end{latin}
% با توجه به توضیحات داده‌ شده، طراحی اکتور اخذ درس تا این مرحله از طراحی به صورت شبه‌کد شکل بلاه خواهد بود.

\item شرط ۲:\\
 این شرط باید تعیین کند که دانشجو قبلاً در همین ترم این درس را اخذ کرده است یا خیر. با استدلال مشابه شرط ۱ به این نتیجه می‌رسیم که مقصد پیغام درخواست بررسی اخذ تکراری اکتور دانشجو است و قالب پیغام‌های درخواست و پاسخ برای این شرط به صورت زیر می‌باشد:
 \begin{latin}
 TakenRequest(course:Course)
 TakenResponse(result:Boolean)
 \end{latin}

\item شرط ۳:\\
 این شرط باید تعیین کند که دانشجو تمام پیش‌نیازهای درس را با موفقیت گذرانده است یا خیر. با استدلال مشابه شرط ۱ به این نتیجه می‌رسیم که مقصد پیغام درخواست بررسی اخذ تکراری اکتور دانشجو است و قالب پیغام‌های درخواست و پاسخ برای این شرط به صورت زیر می‌باشد:
 \begin{latin}
 PassedPresRequest(course:Course)
 PassedPresResponse(result:Boolean)
 \end{latin}
 
\item شرط ۴:\\
 این شرط کنترل می‌کند که با اخذ این درس آیا تعداد واحدهای دانشجو در ترم جاری بیشتر از ۲۰ می‌شود یا خیر. گذراندن بیش از تعدادی واحد به احتمال زیاد در چنین سیستمی به جز در بررسی شرایط کاربرد دیگری ندارد (بر خلاف موردی مثل بررسی گذرانده شدن درس که در موارد متعددی می‌تواند کاربرد داشته باشد) به همین دلیل پیغام مربوط به این مورد بهتر است به جای دانشجو به اکتور دیگری که مختص این کاربرد طراحی می‌شود سپرده شود. گیرنده‌ی پیغام مربوط به این شرط اکتور تأیید تعداد واحد (UnitsValidatorActor)  خواهد بود. با توجه به این که اکتور مذکور نیاز به دسترسی به سوابق دانشجو و نیز تعداد واحد درس انتخاب شده دارد، در هنگام ایجاد این اکتور، باید فیلد‌های دانشجو و درس را در اختیار اکتور قرار دهیم. به این ترتیب، اکتور تأیید تعداد واحد به محض ایجاد می‌تواند کار خود را شروع کند و  اکتور اخذ درس نیازی به ارسال پیغام به آن ندارد. با توجه به این توضیحات پیغام‌ پاسخ برای این شرط به صورت زیر می‌باشد:
 \begin{latin}
  UnitsValidationResponse(result:Boolean)
 \end{latin}
\end{itemize}
در این مرحله باید تعیین کنیم که اکتور بررسی اخذ درس با دریافت پاسخ هر پیغام چه عملی را باید انجام دهد:\\
هر یک از پاسخ‌هایی که اکتور بررسی اخذ درس دریافت می‌کند در واقع نتیجه‌ی بررسی یکی از شروط لازم برای اخذ درس است. برای موافقت با اخذ درس توسط دانشجو، تمام شروط باید بررسی شوند. بنابراین پاسخ موافقت با اخذ درس فقط زمانی می‌تواند ارسال شود که تمام پاسخ‌ها دریافت شوند. برای اینکه اکتور اخذ درس از اتمام دریافت دروس مطلع شود لازم است که متغیری به منظور نگه‌داری تعداد پاسخ‌هایی که باید دریافت شود ایجاد شده بروزرسانی شود. با این کار اکتور اخذ درس می‌داند که چه زمانی کار به اتمام رسیده است. اما در این مورد کاربرد، در همه‌ی حالت‌ها لازم نیست اکتور منتظر تمام پاسخ‌ها بماند. دلیل این امر این است که در صورتی که هر یک از شروط اخذ درس نقض شود، نیازی به بررسی سایر شروط نیست. مثلاً اگر دانشجو قبلاً درس را گذرانده باشد نیازی به دریافت سایر پاسخ‌ها وجود ندارد و می‌توانیم پاسخ درخواست را ارسال کنیم (خطای گذرانده شدن درس). بنابراین در این مورد کاربرد با گرفتن هر پاسخ به این ترتیب عمل می‌کنیم که اگر شرط برقرار باشد، مقدار متغیر تعداد پاسخ‌های دریافت شده را یکی زیاد می‌کنیم، اگر مقدار جدید برابر با تعداد پاسخ مورد انتظار بود (این یعنی تمام پاسخ‌ها دریافت شده‌اند)، پاسخ نهایی درخواست را ارسال می‌کنیم. و اگر شرط نقض شده باشد پاسخ درخواست را که عدم موفقیت اخذ به دلیل نقض شرایط است ارسال می‌کنیم.
نمودار شکل \ref{fig:take_course_sequence_1} تصمیمات اتخاذ شده تا این مرحله از طراحی را به صورت شماتیک نشان می‌دهد. در این نمودار حالتی بررسی شده که تمام شرایط اخذ درس برقرار شده و اخذ با موفقیت انجام می‌شود. حالت دیگری که یکی از شروط (تعداد واحد) برقرار نشده است در شکل \ref{fig:take_course_sequence_2} نشان داده شده است. در این حالت با توجه به اینکه یکی از پاسخ‌ها نشان‌دهنده‌ی این است که یکی از شروط برقرار نشده،‌ به محض دریافت این پیغام، اکتور اخذ درس نتیجه‌ی درخواست را ارسال می‌کند و به کار خود پایان می‌دهد. طبیعتا پیغام‌های دیگری که برای این اکتور ارسال شده‌اند پردازش نخواهند شد.
لازم به تأکید است که در هر دو شکل ترتیب پیغام‌ها فقط نشان دهنده‌ی یک حالت فرضی هستند. در عمل در هر بار اجرای برنامه، ترتیب گرفتن پاسخ‌ها ممکن است عوض شود.

\begin{figure*}
    \begin{center}
	\includegraphics[width=14cm]{4-ProposedFramework/Figures/take_course_seq1.pdf}
    \end{center}
    \caption{\label{fig:take_course_sequence_1} نمودار ترتیب تبادل پیغام‌ برای اخذ درس- حالتی که تمام شروط برای اخذ برقرار است }
\end{figure*}
%\FloatBarrier

\begin{figure*}
    \begin{center}
	\includegraphics[width=14cm]{4-ProposedFramework/Figures/take_course_seq2.pdf}
    \end{center}
    \caption{\label{fig:take_course_sequence_2} نمودار ترتیب تبادل پیغام‌ برای اخذ درس- حالتی که یکی از شروط برقرار نیست }
\end{figure*}
%\FloatBarrier


 در این مرحله، طراحی اکتور اخذ درس به پایان رسیده است. شبه‌کد \ref{fig:usecases:take_course:take_course} ساختار کلاس اکتور اخذ درس را نشان می‌دهد.
 \codelisting[language=scala]{4-ProposedFramework/src/usecases/take_course/TakeCourseActor.scala}{شبه‌کد طراحی اکتور اخذ دانشجو.}{fig:usecases:take_course:take_course} 
%\FloatBarrier
  در ادامه باید تغییرات سایر اکتورها در اثر دریافت پیغام‌های ارسال شده از اکتور اخذ درس اعمال شود و نیز اکتور جدیدی که ایجاد شده (اکتور تایید تعداد واحد) نیز طراحی گردد.
%   برای رعایت اختصار و اجتناب از طرح نکات تکراری، جزئیات طراحی بررسی شرط گذرانده شدن درس‌ ارائه می‌گردد.
\subsubsection{بررسی گذرانده شدن درس}
\label{subsection:passCourse}
  برای بررسی گذرانده شدن درس، اکتور اخذ درس یک پیغام CoursePassRequest به اکتور دانشجو ارسال می‌کند. اکتور دانشجو بررسی این شرط را به اکتور جدید گذراندن درس\LTRfootnote{CoursePassActor} می‌سپارد. این اکتور برای بررسی گذرانده شدن درس، نیاز به برقراری ارتباط با اکتورهای سابقه\LTRfootnote{StudyRecord} دارد. بنابراین اکتور دانشجو لیست سابقه‌ی دانشجو و نیز درسی که باید گذرانده شدن آن بررسی شود را در اختیار اکتور بررسی گذراندن درس قرار می‌دهد. اکتور گذراندن درس از تمام اکتورهای سابقه سؤال می‌کند که آیا سابقه‌ی مربوطه یک گذراندن موفق از درس مذکور است یا خیر. این کار با ارسال یک پیغام با قالب زیر صورت می‌پذیرد:
  \begin{latin}
  AreYouPassCourseRequest(course)
  \end{latin}
هر اکتور سابقه‌ با دریافت این پیغام باید اولاً بررسی کند که آیا سابقه‌ای مربوط به درس مذکور است یا خیر، و ثانیاً نمره‌ی سابقه نمره‌ی قبولی است یا خیر. در اینجا با توجه به اینکه نمره‌ی مربوطه در اختیار خود اکتور سابقه است، بررسی آن ساده‌تر است. در صورتی که نمره کمتر از ۱۰ باشد، این اکتور بلافاصله پاسخ پیغام (منفی) را می‌دهد، در غیر این صورت برای بررسی این که این سابقه مربوط به درس مذکور است یا خیر، یک پیغام برای اکتور ارائه ارسال می‌کند. اکتور ارائه با گرفتن این پیغام آن را برای اکتور درس ارسال می‌کند تا این اکتور بررسی کند که آیا با درسی که در قالب پیغام دریافت کرده برابر است یا خیر. این اکتور پاسخ نهایی را مستقیماً برای اکتور بررسی گذرانده شدن درس ارسال می‌کند.  
\begin{figure}
    \begin{center}
	\includegraphics[width=14cm]{4-ProposedFramework/Figures/HasPassed.pdf}
    \end{center}
    \caption{\label{fig:take_course_haspassed}نمایش شماتیک تبادل پیغام بین اکتورهای مختلف برای بررسی گذرانده شدن یک درس }
\end{figure}

شکل \ref{fig:take_course_haspassed} تبادل پیغام‌های مربوط به بررسی گذرانده شدن درس را به صورت شماتیک نشان می‌دهد. در این شکل خط عمودی در حالتی به کار رفته‌ است که یک اکتور در زمان‌های مختلف پیغام دریافت کرده باشد. در مثال بررسی شده در شکل، اکتور اخذ درس یک درخواست بررسی گذرانده شدن درس (درس c1 ( را برای اکتور دانشجو ارسال می‌کند. اکتور دانشجو یک اکتور بررسی گذرانده شدن درس (HasPassedActor) ایجاد می‌کند و کار بررسی را به آن واگذار می‌کند. این اکتور پیغام‌های مناسب را برای دو اکتور سابقه‌ی دانشجو ارسال می‌کند. یکی از اکتورهای سابقه به این دلیل که نمره‌ی کمتر از ۱۰ (۷) دارد، بلافاصله پاسخ را برای اکتور مقصد ارسال می‌کند. اکتور سابقه‌ی دیگر با توجه به اینکه نمره‌ی قبولی دارد،‌ برای اطمینان از اینکه مربوط به همان درسی است که گذرانده شدن آن بررسی می‌شود، یک پیغام به اکتور ارائه ارسال می‌کند. اکتور ارائه پیغام را به درس منتقل می‌کند و اکتور درس با مقایسه‌ی درس موجود در پیغام با خودش، جواب را برای مقصد می‌فرستد.
\FloatBarrier
\subsubsection{بررسی گذرانده شدن پیش‌نیازهای درس}
اکتور دانشجو با دریافت پیغام بررسی گذرانده شدن پیش‌نیازهای درس، محاسبات مربوطه را به اکتوری که به این منظور طراحی شده ارسال می‌کند. با توجه به اینکه پیش‌نیازهای هر درس نیز خود از نوع درس هستند، در طراحی این بخش می‌توان از اکتور بررسی گذرانده شدن درس استفاده کرد. بنابراین اکتور مذکور به ازای هر کدام از پیش‌نیازهای درس، یک پیغام بررسی گذرانده شدن درس به دانشجو ارسال می‌کند. با دریافت هر پاسخ اگر مشخص شود که درسی از میان پیش‌نیازها گذرانده نشده است، بلافاصله پاسخ درخواست به مقصد (اکتور اخذ درس) ارسال می‌شود. در غیر این صورت پس از گرفتن تمام پاسخ‌ها، یک پیغام به اکتور اخذ درس ارسال می‌کند و به وسیله‌ی آن اعلام می‌کند که تمام پیش‌نیازها گذرانده شده است.
\begin{figure}
    \begin{center}
	\includegraphics[width=14cm]{4-ProposedFramework/Figures/Prerequisites.pdf}
    \end{center}
    \caption{\label{fig:take_course_pres}نمایش شماتیک تبادل پیغام بین اکتورهای مختلف برای بررسی گذرانده شدن پیشنیازها‌ی یک درس }
\end{figure}
شکل \ref{fig:take_course_pres} ارتباط اکتورها برای بررسی گذرانده شدن درس نشان می‌دهد. در این شکل، ابتدا اکتور اخذ درس پیغام بررسی گذرانده شدن درس c1 را به اکتور دانشجو ارسال می‌کند. اکتور دانشجو بررسی بررسی این مورد را به اکتور بررسی پیش‌نیاز\LTRfootnote{PassPresActor} واگذار می‌کند. این اکتور به ازای هر کدام از پیشنیاز‌های  درس، یک پیغام بررسی گذرانده شدن درس برای خود دانشجو ارسال می‌کند. طراحی مورد بررسی گذراندن درس در بخش \ref{subsection:passCourse} توضیح داده شد. در این شکل برای جلوگیری از پیچیدگی طراحی، از نمایش نحوه‌ی بررسی گذرانده شدن درس صرف نظر شده است و اکتورها و پیغام‌های مربوط به آن به صورت شکل ابر نمایش داده شده است.

\FloatBarrier
\subsubsection{بررسی عدم اخذ مجدد درس}
همان‌طور که در بخش \ref{section:takeCourse} توضیح داده شد، اکتور اخذ درس یک پیغام برای بررسی عدم اخذ مجدد درس برای اکتور دانشجو ارسال می‌کند. اکتور دانشجو مطابق حالت‌های قبل بررسی این مورد را به اکتور بررسی اخذ درس\LTRfootnote{CourseTakenCheckActor} واگذار می‌کند. بررسی  اخذ شدن درس کاملاً مشابه بررسی گذرانده شدن درس است. در بررسی گذرانده شدن درس، اکتور سابقه نمره را بررسی می‌کند، در صورتی که نمره قبولی نباشد جواب را ارسال می‌کند و در صورتی که نمره قبولی باشد برای بررسی اینکه درس مربوط به سابقه همان درس مورد سؤال است یا خیر، با اکتور ارائه تبادل پیغام انجام می‌دهد. در بررسی عدم اخذ مجدد درس، از هر اکتور سابقه سؤال می‌شود که آیا سابقه مربوط به ترم جاری است یا خیر. برای اینکه  یک سابقه مربوط به ترم جاری باشد، کافی است نمره‌ای برای آن اعلام ثبت نشده باشد. بنابراین اکتور سابقه بررسی می‌کند که نمره‌ای برایش ثبت شده یا خیر اگر مقدار فیلد نمره null باشد یعنی مربوط به ترم جاری است و برای بررسی اینکه مربوط به همان درس مورد سؤال است مانند حالت بررسی گذرانده شدن درس، یک پیغام به ارائه ارسال می‌کند. در غیر این صورت حتماً جواب منفی است و بلافاصله یک پیغام برای اکتور بررسی عدم اخذ مجدد ارسال می‌شود. شکل  \ref{fig:take_course_taken} تبادل پیغام بین اکتورها برای بررسی این شرط را نشان می‌دهد. همان‌طور که مشاهده می‌شود این شکل بسیار شبیه به شکل \ref{fig:take_course_haspassed} است که بررسی گذرانده شدن درس را نشان می‌دهد.

\begin{figure}
    \begin{center}
	\includegraphics[width=14cm]{4-ProposedFramework/Figures/HasTaken.pdf}
    \end{center}
    \caption{\label{fig:take_course_taken}نمایش شماتیک تبادل پیغام بین اکتورهای مختلف برای بررسی عدم اخذ مجدد درس }
\end{figure}





\FloatBarrier
\subsubsection{بررسی عدم اخذ بیش از ۲۰ واحد}
در بخش طراحی اکتور اخذ درس (بخش \ref{section:takeCourse}) دیدیم که اکتور اخذ درس برای بررسی این شرط که تعداد واحدهای اخذ شده بیشتر از ۲۰ نشود، یک اکتور به این منظور ایجاد می‌کند. این اکتور با بررسی این شرط نتیجه را به صورت پیغام UnitsValidationResponse برای اکتور اخذ درس ارسال می‌کند. طراحی این کارکرد به این صورت است که اکتور مورد نظر از تمام سابقه‌های ترم درخواست می‌کند تا در صورتی که مربوط به ترم جاری هستند، تعداد واحدهای درس مربوط به خود را ارسال کنند. همان‌طور که در بخش قبل توضیح داده شد، اینکه سابقه مربوط به ترم جاری است از null بودن فیلد نمره مشخص می‌شود. بنابراین اگر فیلد نمره null نباشد اکتور سابقه عدد صفر را به عنوان تعداد واحد ارسال می‌کند. در غیر این صورت مشابه‌ حالت‌های قبل یک پیغام برای اکتور درس (از طریق اکتور ارائه) ارسال می‌کند تا تعداد واحدها را به اکتور مقصد (اکتور بررسی عدم اخذ بیش از ۲۰ واحد) ارسال کند. اکتور مذکور با گرفتن هر پیغام تعداد واحدها را بروزرسانی می‌کند و با اتمام پیغام‌ها بررسی می‌کند که آیا جمع واحدها بیش از ۲۰ است یا خیر. در نهایت پاسخ را برای اکتور اخذ درس ارسال می‌کند. شکل \ref{fig:take_course_units} همکاری اکتورها برای بررسی این  شرط را به صورت شماتیک نشان می‌دهد.

\begin{figure*}
    \begin{center}
	\includegraphics[width=14cm]{4-ProposedFramework/Figures/NumOfUnits.pdf}
    \end{center}
    \caption{\label{fig:take_course_units}نمایش شماتیک تبادل پیغام بین اکتورهای مختلف برای بررسی عدم اخذ بیش از ۲۰ واحد}
\end{figure*}



\chapter{روش طراحی و الگوها}
\label{chapter:RelatedWork}
%\section{روش طراحی و الگوها}
%TODO fix references to chapters
در بخش‌های پیشین  یک سیستم نمونه معرفی شد و پس از توصیف موارد کاربرد آن، روش طراحی آن با استفاده از مدل تبادل ناهمگام پیغام بررسی شد. در ادامه‌ی این فصل تلاش می‌شود با توجه به تجربیات حاصل از انجام این طراحی، روش معرفی شده به صورت نظام‌مند معرفی شود. در قسمت اول از این بخش، قدم‌های لازم برای طراحی یک سیستم به روش تبادل ناهمگام پیغام ذکر شده و در موارد ممکن، از قسمت‌هایی از سیستم طراحی شده به عنوان نمونه بهره گرفته شده است. در قسمت بعد تلاش شده الگوهای کلی هماهنگی اکتورها با تمرکز بر خواص منطق دامنه بررسی شود. در بخش بعد قسمتی از تجربیات حاصل از بررسی رویکردهای متعدد برای طراحی سیستم نمونه (سیستم آموزش ساده) ارائه شده است. و نهایتا در بخش پایانی قسمتی بحث مختصری در مورد نکات برنامه‌نویسی در هنگام پیاده‌سازی سیستم مطرح شده است.


%\subsection{ارتباط طراحی شیءگرا و طراحی به روش تبادل ناهمگام پیغام}

\section{گام‌های طراحی به روش تبادل ناهمگام پیغام }
\label{section:design_steps}
روش بررسی شده در این پژوهش ارتباط تنگاتنگی با مبحث طراحی شیءگرا دارد. طراحی شیءگرا با استفاده از لفافه‌بندی\LTRfootnote{encapsulation} اشیاء منجر به تفکیک واسط کارکردی یک شیء از حالت محلی آن می‌شود و جزئیات پیاده‌سازی رفتار را مخفی ‌می‌کند. این خاصیت منجر به افزایش امکان استدلال در مورد نحوه‌ی طراحی اشیاء می‌شود. در این روش، مکانیزم کنترل اجرای برنامه‌ها فراخوانی متد است. روش تبادل ناهمگام به تفکیک کنترل اجرای منطق برنامه از زمان اجرای آن می‌پردازد. به این ترتیب قابلیت افزودن همروندی در طراحی را اضافه می‌کند. آلن کِی در \cite{Kay_messaging} اظهار داشته است که ایده‌ی اصلی در طراحی شیءگرا، ارسال پیغام بوده است. و این مسئله ارتباط تنگاتنگ طراحی شیءگرا و طراحی مبتنی بر تبادل ناهمگام پیغام را نشان می‌دهد.\\
بنابراین بسیاری از ایده‌های طراحی و تحلیل شیءگرا عیناً در این روش نیز کاربرد دارند. به همین دلیل در ارائه‌ی روش طراحی به بررسی جزئیات مواردی که دقیقاً مشابه طراحی شیءگرا هستند پرداخته نشده است. علاوه بر این، در ارائه‌ی روش فرض شده که خروجی‌های تحلیل سیستم موجود هستند. طبیعتاً روش‌های تحلیل شیءگرا و کسب شناخت از سیستم تحت طراحی، عیناً قابل اعمال در این نوع طراحی هستند. در گام‌های ذکر شده برای طراحی به روش تبادل ناهمگام، بعضی از گامها مربوط به خروجی‌های تحلیل سیستم هستند که برای حفظ انسجام، توضیح داده شده‌اند. با توجه به این موارد، در این بخش گام‌های طراحی به روش تبادل پیغام را ارائه می‌کنیم:

\subsection{شناخت سیستم و تشخیص اکتورهای دامنه}
شناخت سیستمی که باید طراحی شود پیش از شروع به طراحی لازم است. فعالیت‌های مربوط به این بخش مشابه همین فعالیت‌ها در روش‌های تحلیل نیازمندی‌ها و کسب شناخت\LTRfootnote{Inception} در متدولوژی‌های طراحی شیءگرا است و جزئیات آنها در حوزه‌ی این پژوهش نمی‌باشد. تعدادی از خروجی‌های این فعالیت‌ها از جمله توصیف موارد کاربرد سیستم و استخراج اشیاء دامنه به طور گسترده در طراحی مورد استفاده قرار می‌گیرند.
در مدل اکتور، همه‌ی موجودیت‌های سیستم اکتور هستند. بنابراین تمام اشیاء مدل دامنه‌ی سیستم که در مراحل ابتدایی طراحی و تحلیل شناسایی می‌شوند، به صورت اکتور طراحی می‌شوند. در منابع تحلیل و طراحی شیءگرا، روش‌هایی برای تشخیص اشیاء دامنه و نمایش مناسب آنها بیان شده است که طبیعتاً قابل اعمال در این روش نیز می‌باشند\cite{Larman_2004}. در سیستم آموزش معرفی شده، مدل دامنه در قالب نمودار کلاس در بخش \ref{subsec:mainEntities} نمایش داده شده است.
\subsection{انتخاب مورد کاربرد برای طراحی جزئیات}
با در دست داشتن موارد کاربرد و اشیاء دامنه، فعالیت‌های مربوط به طراحی اکتورهای سیستم آغاز می‌گردد. در گام اول نیاز داریم یکی از موارد کاربرد را برای طراحی انتخاب کنیم. معمولاً انتخاب مورد کاربرد با توجه به اولویت و اهمیت‌ آن صورت می‌پذیرد. پس از انتخاب مورد کابرد باید رخداد‌های سیستمی آن شناسایی شوند. این رخدادها نتیجه‌ی تعامل بازیگران خارجی با سیستم هستند. استخراج رخداد‌های سیستمی با توجه به موارد کاربرد صورت می‌گیرد. این رخدادها را می‌توان با استفاده از نمودارهای ترتیب سیستمی\LTRfootnote{system sequence diagram (SSD)} نمایش داد\cite{Larman_2004}. در نمودار ترتیب سیستمی، سیستم به صورت جعبه‌ی سیاه\LTRfootnote{black box} درنظر گرفته می‌شود و تعامل بازیگر خارجی با سیستم به صورت فرستادن درخواست و دریافت پاسخ نمایش داده می‌شود. 
به عنوان مثال شکل \ref{fig:ssd} نمودار ترتیب سیستمی را برای سناریوی اصلی مورد کاربرد محاسبه‌ی معدل نشان می‌دهد. رخدادهای سیستمی نقطه‌ی مناسبی برای شروع به طراحی اکتورها و ارتباطات آنها هستند. در طراحی شیءگرای ترتیبی، رخدادهای سیستمی در ارتباطی تنگاتنگ با متدهای یک شیء قرار دارند. در واقع نقطه‌ی آغاز اجرای محاسبات مربوط به یک رخداد سیستمی یک متد است. دلیل این پیش‌فرض این است که مکانیزم کنترل برنامه در طراح شیءگرای ترتیبی (و هر روش ترتیبی دیگر) فراخوانی متد است. در حالی که در روش مبتنی بر اکتور، مکانیزم ارتباطی تبادل پیغام است. بنابراین در این روش هر رخداد سیسستمی به یک پیغام نگاشت می‌شود که به دست یکی از اکتورها سیستم می‌رسد. 
\begin{figure*}[bh]
    \begin{center}
	\includegraphics[width=6cm]{4-ProposedFramework/Figures/ssd.pdf}
    \end{center}
    \caption{\label{fig:ssd}نمودار ترتیب سیستمی برای یک سناریو از مورد کاربرد محاسبه‌ی معدل}
\end{figure*}

\subsection{طراحی اکتور اول}
همان‌طور که در مورد قبل توضیح داده شد، در مدل طراحی اکتور، وقوع یک رخداد سیستمی، به وسیله‌ی ارسال پیغام صورت می‌گیرد. گام اول در طراحی سیستم به هدف پاسخگویی به این پیغام این است که مشخص شود کدام اکتور باید اولین پیغام را دریافت کند. این مورد در طراحی شیءگرا در قالب مفهوم \textbf{مسئولیت شیء} بیان می‌شود. در طراحی شیءگرا شیءای موظف به دریافت درخواست است که مسئولیت درخواست با آن باشد. تشخیص مسئولیت با توجه به منطق دامنه صورت می‌گیرد و بدون در نظر گرفتن منطق دامنه، قاعده‌ای برای انتخاب شیء مسئول وجود ندارد. مسئولیت اشیاء از نظر نوع به دو دسته‌ی کلی مسئولیت \textit{انجام}\LTRfootnote{Doing Responsibilities} (مانند مسئولیت ایجاد یک شیء و آغاز یک عملیات) و مسئولیت \textit{اطلاع}\LTRfootnote{Knowin Responsibilities} (مانند اطلاع از اشیاء مرتبط یا اطلاع از داده‌های محلی لفافه‌بندی شده) تقسیم می‌شود\cite{Larman_2004,rdd}.
معمولاً  مسئولیت پاسخگویی به درخواست‌های سیستمی بعد از  تهیه‌ی مدل دامنه آسان‌تر می‌شود. در سیستم بررسی شده در این پژوهش مسئولیت پاسخ‌گویی به درخواست محاسبه‌ی 
معدل اکتور دانشجو است. با مشخص شدن اکتور مسئول برای دریافت پیغام، در ادامه‌ی طراحی باید روش پردازش پیغام در اکتور مورد نظر بررسی گردد.
\subsection{منطق پردازش درخواست}
تا این مرحله از طراحی، مشخص شده است که اکتور مسئول برای دریافت پیغام درخواست کدام است. در این مرحله باید تصمیم گرفته شود که نحوه‌ی پردازش پیغام درخواست به چه صورتی خواهد بود.
 \subsubsection{تصمیم‌گیری برای انتقال پردازش درخواست به اکتور دیگر}
 \label{design:delegate}
پردازش پیغام به دو صورت کلی انجام می‌پذیرد. حالت اول این است که خود اکتور مسئولیت پردازش پیغام را بر عهده بگیرد. در این حالت اکتور مذکور یا به تنهایی قادر به انجام تمام عملیات مرتبط با درخواست دریافت شده است و یا با همکاری اکتورهای دیگر می‌تواند منطق مربوط به درخواست را اجرا کند. 

حالت دوم  به این صورت است که اکتور تصمیم بگیرد که اکتور جدیدی را به منظور پردازش این درخواست ایجاد کند و تمام عملیات مربوط به درخواست را به این اکتور واگذار کند. حالت مشابه‌ این مورد در طراحی شیءگرای ترتیبی نیز رخ می‌دهد. در طراحی شیءگرا ممکن است به دلیل جلوگیری از افزایش پیچیدگی کلاس و  حفظ قابلیت تغییر، تمام کار پردازش یک درخواست را به کلاس دیگری که به همین منظور ایجاد می‌شود منتقل کند. در روش طراحی مبتنی بر تبادل ناهمگام، علاوه بر این مورد به دلیل دیگری نیز این تصمیم اتخاذ می‌شود. این مسئله در ادامه در قالب یک مثال توضیح داده می‌شود:\\
فرض کنید یک مدل دامنه از ۳ اکتور تشکیل شده باشد. اکتور A که یک متغیر محلی عددی به نام a دارد. این اکتور یک نوع پیغام دریافت می‌کند: پیغام getA که در پاسخ آن مقدار a را ارسال می‌کند. اکتور B به طور مشابه یک متغیر محلی عددی به نام b دارد و با دریافت پیغام getB مقدار b را ارسال می‌کند. اکتور سوم Sum نام دارد که با دریافت پیغام sum باید مجموع مقادیر a و b را ارسال کند. اکتور Sum چون از مجموع a و b اطلاع ندارد برای پاسخ به پیغام sum نیاز به همکاری A و B دارد. فرض کنیم اکتور Sum به این شکل طراحی می‌شود که با دریافت پیغام sum ابتدا متغیرهای محلی s و count را صفر می‌کند و سپس پیغام‌های getA و getB را برای اکتورهای A و B ارسال می‌کند با دریافت هر پاسخ مقدار count را یکی زیاد می‌کند و متغیر s را با عدد دریافت شده جمع می‌کند. بعد از دریافت هر پاسخ و بروزرسانی متغیرهای داخلی، اگر مقدار count برابر با عدد ۲ شد (یعنی هر دو پاسخ دریافت شده است) مقدار متغیر s (حاصل‌جمع) را به عنوان پاسخ درخواست ارسال می‌کند. شکل \ref{fig:coord1} همکای این ۳ اکتور برای پاسخ به درخواست sum را نشان می‌دهد.
\begin{figure*}[h]
    \begin{center}
	\includegraphics[width=10cm]{4-ProposedFramework/Figures/ExampleCoord1.pdf}
    \end{center}
    \caption{\label{fig:coord1} همکاری موفق اکتورها برای پاسخ به درخواست مجموع a و b}
\end{figure*}
مشکل این طراحی زمانی مشخص می‌شود که اکتور Sum بعد از دریافت پاسخ‌ A و قبل از دریافت پاسخ B یک درخواست sum دیگر دریافت می‌کند. اکتور Sum برای پاسخ به این درخواست مقدار متغیرهای s و count را صفر می‌کند و دو پیغام جدید برای A و B ارسال می‌کند. در این هنگام اکتور Sum پاسخ B برای درخواست اول را دریافت می‌کند اما چون مقدار متغیر count صفر است، متوجه اتمام عملیات درخواست اول نمی‌شود. شکل \ref{fig:coord2} این حالت را نمایش می‌دهد.
\begin{figure*}[h]
    \begin{center}
	\includegraphics[width=8cm]{4-ProposedFramework/Figures/ExampleCoord2.pdf}
    \end{center}
    \caption{\label{fig:coord2} مشکل پیغام‌های همروند در همکاری اکتورها برای پاسخ به درخواست مجموع a و b}
\end{figure*}
مثال فوق نشان می‌دهد که در طراحی به روش تبادل ناهمگام پیغام در صورتی که نیاز به همکاری بین اکتورها وجود داشته باشد ممکن است درخواست‌های همروند موجب تداخل در محاسبات همدیگر بشوند. این مشکل زمانی پیش می‌آید که شرایط زیر برقرار باشند:\\
 \begin{enumerate}
 \item برای پاسخ به یک درخواست، اکتور مجبور به همکاری با سایر اکتورها باشد.
 \item همکاری به ارسال پیغام به سایر اکتورها ختم نشود و در ادامه لازم باشد پاسخ آنها دریافت شود. 
 \item ارسال پیغام‌ها به صورت ناهمگام انجام شود. به این معنی که اکتور مورد نظر پس از ارسال پیغامهای مربوطه بتواند بدون توقف برای دریافت پاسخ‌ها به پردازش سایر پیغام‌ها بپردازد.
 \item اکتور با دریافت هر کدام از پاسخ‌ها متغیر(های) محلی خود را بروزرسانی کند.
 \end{enumerate}
راه حل مشکل:\\
برای حل این مشکل در زمان طراحی چند گزینه پیش رو داریم:
\begin{itemize}
\item گزینه‌ی اول این است که به جای ارسال ناهمگام پیغام‌های مربوط به یک درخواست، عمل تبادل پیغام را به صورت همگام انجام دهیم. در این حالت اطمینان حاصل می‌شود که درخواست جدید قبل از اتمام عملیات درخواست قبلی پردازش نمی‌شود. ایراد این روش این است که باعث محدودیت در همروندی سیستم می‌گردد.
\item راه دوم این است که به گونه‌ای متغیرهای حالت را نگهداری کنیم که با پردازش درخواست‌های همروند دچار مشکل نشوند. برای این کار نیاز داریم تا متغیرهای حالت را برای درخواست‌های پردازش شده اختصاصی کنیم. در مثال معرفی شده در  شکل \ref{fig:coord1} این کار به این صورت انجام می‌شود که به جای متغیر‌های s و count برای هر درخواست متغیر جدیدی در نظر بگیریم. طبیعتاً این روش منجر به ایجاد پیچیدگی در زمان پیاده‌سازی می‌شود و تضمین محافظت از متغیرها کار دشواری خواهد بود.
\item
 راه مناسب برای حل این مشکل این است که تمام عملیات مربوط به درخواست دریافت شده، به یک اکتور دیگر که فقط وظیفه‌ی پاسخ به این درخواست را دارد منتقل شود. به این روش هم مشکل متغیر‌های حالت محلی به وجود نمی‌آید و هم همروندی سیستم محدود نمی‌شود. طبیعتاً برای جلوگیری از تکرار همین مشکل برای اکتور جدید باید به ازای هر درخواست مشابه یک نمونه‌ی جدید از اکتور مذکور ایجاد کنیم.\\
بنابراین در طراحی به روش تبادل ناهمگام پیغام علاوه‌ بر جلوگیری از پیچیدگی و بزرگ شدن بیش از حد کلاس، ممکن است به دلیل ایجاد امکان پردازش درخواست‌های همروند نیز تصمیم به واگذاری درخواست به اکتوری جدید نماییم.
 در طراحی سیستم آموزش که در بخش‌های قبل توضیح داده شد، در موارد متعددی از جمله در مورد کاربرد محاسبه‌ی معدل (بخش \ref{gpa_approch2}) این الگو مشاهده شد.

\end{itemize}
\subsubsection{پردازش پیغام بدون همکاری با سایر اکتورها}
 مستقل از این موضوع که پردازش یک درخواست توسط خود اکتور انجام می‌شود یا به اکتور جدیدی منتقل می‌شود، در طراحی سیستم باید مشخص شود که منطق مربوط به یک درخواست چگونه پیاده‌سازی خواهد شد. ساده‌ترین حالت برای اجرای منطق مربوط به یک درخواست این است که اکتور دریافت کننده، بتواند بدون همکاری با سایر اکتورها عملیات لازم را انجام دهد و در صورت لزوم پاسخ درخواست را ارسال کند. این حالت زمانی رخ می‌دهد که اکتور تمام اطلاعات لازم برای اجرای منطق مربوطه را در حالت خود داشته باشد.
 در این حالت اکتور پس از دریافت پیغام، منطق مربوط به آن را انجام می‌دهد و در صورت لزوم پاسخ مناسب را برای مقصد ارسال می‌کند. ممکن است حالت اکتور پس از  پردازش این پیغام تغییر کند. شکل \ref{fig:no_collaboration} این حالت را نشان می‌دهد.
 \begin{figure*}[h]
    \begin{center}
	\includegraphics[width=6cm]{4-ProposedFramework/Figures/NoCollaboration.pdf}
    \end{center}
    \caption{\label{fig:no_collaboration} پردازش پیغام بدون همکاری با سایر اکتورها}
\end{figure*}

\subsubsection{پردازش پیغام به وسیله‌ی همکاری با سایر اکتورها}
در بخش قبل ذکر شد که ممکن است یک اکتور با دریافت یک پیغام درخواست، قادر باشد بدون برقراری ارتباط با سایر اکتورها پاسخ درخواست را بدهد. در مواردی که اطلاعات مورد نیاز برای پردازش درخواست را در اختیار نداشته باشد، باید با اکتورهای دیگر ارتباط برقرار کند. برای برقراری ارتباط با سایر اکتورها از تبادل پیغام استفاده می‌شود. در برقراری ارتباط با سایر اکتورها نکات زیر باید در نظر گرفته شوند:\\
\begin{itemize}
\item بررسی اینکه تبادل پیغام به صورت همگام صورت گیرد یا ناهمگام:\\
یک عامل مهم در این تصمیم‌گیری منطق مربوط به پردازش پیغام است. در برخی موارد گزینه‌ای جز همگام‌سازی پیغام‌ها وجود ندارد.مثلاً اگر منطق مورد نظر احتیاج به پردازش به ترتیب زمانی داشته باشد و برای هر بخش آن نیاز به برقراری ارتباط با سایر اکتورها وجود داشته باشد، ارسال پیغام باید به صورت همگام صورت پذیرد. یا در حالتی که از اطلاعات مورد نیاز برای یک مرحله از پردازش پیغام، وابسته به نتیجه‌ی مرحله‌ی قبل باشد. در چنین مواردی ملزم به استفاده از تبادل همگام پیغام هستیم. البته این به این مفهوم نیست که فقط در این حالت می‌توان از پیغام همگام استفاده کرد. در واقع استفاده از ارتباط همگام، هیچ محدودیت ذاتی در مدل اکتور ندارد. حتی در این روش می‌توان یک مدل ترتیبی را با نگاشت هر متد از شیء به یک ارتباط همگام، به صورت مدل اکتور طراحی کرد. در این حالت با اینکه هر اکتور به صورت همروند اجرا می‌شود، در اجرای برنامه همروندی وجود نخواهد داشت.
بنابراین از ارتباط ناهمگام برای ایجاد همروندی در پردازش درخواست‌ها استفاده می‌شود.
\item بررسی اینکه پیغام پاسخ در چه زمانی و توسط چه اکتوری ارسال شود:\\
پردازش یک پیغام ممکن است نیازی به ارسال پاسخ نداشته باشد. این نوع پیغام‌ها ممکن است صرفاً برای ایجاد تغییر در سیستم ارسال شوند و فرستنده نیازی به اطلاع از نتیجه نداشته باشد. در این حالت پس از پردازش پیغام، عملیات مربوط به آن تمام می‌شود. اما در بیشتر موارد ارسال کننده‌ی درخواست نیاز به اطلاع از نتیجه‌ی کار دارد و یا اطلاعاتی را درخواست کرده که باید به صورت پاسخ دریافت کند. در این موارد باید یک پاسخ هم برای فرستنده‌ی درخواست ارسال شود. یک تفاوت مهم مدل اکتور با مدل طراحی شیءگرای ترتیبی،‌ در این است که در مدل مدل ترتیبی، پاسخ یک درخواست الزاماً توسط همان شیءای داده می‌شود که درخواست به آن داده شده است. البته باید دقت شود که در اینجا منظور این نیست که کل پردازش درخواست را شیء مذکور انجام می‌دهد. بلکه منظور این است که نهایتاً نتیجه‌ی کار از همان متدی بازگشت داده می‌شود که فراخوانی شده است. اما در مدل اکتور به دلیل همروندی سیستم،‌ پیغام پاسخ می‌تواند توسط هر کدام از اکتورهای همکاری کننده ارسال شود. بنابراین در طراحی به این روش باید دقت کرد که طراحی را مقید به این نکنیم که دریافت کننده‌ی یک پیغام حتماً پاسخ‌ آن را بدهد. در رویکرد دوم طراحی مورد کاربرد معدل (بخش \ref{gpa_approch2}) به طور مفصل به این مورد پرداخته شده است.
\item استفاده از الگوهای همکاری اکتورها:\\
برای اینکه چند اکتور بتوانند باهم همکاری کرده و پاسخ یک درخواست را ارسال کنند راهکارهای طراحی متعددی وجود دارد که برخی از آنها در طراحی سیستم آموزش در بخش‌های قبل ذکر شده است. برخی از این روش‌ها به دلیل تکرار در حالت‌های زیاد و قابلیت استفاده‌ی مجدد، حالت الگو به خود می‌گیرند. در بخش‌های بعد تعدادی از این الگوها معرفی شده است.
\item انتخاب اکتورهای مقصد برای پیغام‌های مربوط به درخواست\\
در صورتی که تصمیم به همکاری بین اکتورها گرفته شده باشد، پس از طراحی مدل همکاری (با استفاده از الگوهای همکاری اکتورها)، باید تبادل پیغام بین اکتورهایی که همکاری می‌کنند، طراحی شود. گام اول در این طراحی انتخاب مقصد پیغام است. این کار با بررسی مسئولیت‌های اکتورها با توجه به منطق دامنه انجام می‌شود. در صورتی که هیچ یک از اکتورهایی که تا این مرحله طراحی شده‌اند مسئول پردازش پیغام تشخیص داده نشوند،‌ باید اکتور جدیدی برای پردازش پیغام طراحی شود.
\item طراحی قالب پیغام‌های مربوط به درخواست\\
در این مرحله از طراحی باید پیغام‌های مربوط به منطق یک درخواست طراحی شده و ارسال شوند. در طراحی یک پیغام نکات زیر باید مورد توجه قرار گیرد:
\begin{itemize}
\item نام پیغام متناسب با عملکرد آن در نظر گرفته می‌شود. 
به طور کلی در طراحی شیءگرا توصیه می‌شود که نام کلاس‌ها و متدها متناسب با عملکرد و مسئولیت کلاس در نظر گرفته شود.
\item اطلاعات مورد نیاز سایر اکتورهایی که پیغام به دست‌ آنها خواهد رسید در پیغام قرار داده شود.
اطلاعات قرار داده شده در پیغام به چند دسته تقسیم می‌شوند:\\
\begin{enumerate}
\item مقدار متغیر‌های محلی اکتور\\
 این اطلاعات زمانی در پیغام قرار داده می‌شوند که اکتور دیگری برای ادامه‌ی محاسبات نیاز به دسترسی به آنها داشته باشد. به عنوان مثال در رویکرد دوم محاسبه‌ی معدل (بخش \ref{gpa_approch2}) اکتور سابقه، با دریافت پیغام GPAInfoRequest مقدار نمره‌ی سابقه را در بخشی از پیغام قرار می‌دهد و برای اکتور درس ارسال می‌کند.
\item نام (آدرس) اکتورهایی که با این اکتور در ارتباط هستند\\
اکتوری که پیغام برای آن ارسال می‌شود ممکن است برای ادامه‌ی پردازش، نیاز به دسترسی به اکتور دیگری داشته باشد. اگر فرستنده‌ی پیغام به این اکتور دسترسی داشته باشد، می‌تواند نام آن را در پیغام قرار دهد تا اکتور دیگر بتواند با آن ارتباط برقرار کند.
\item قرار دادن مقصد نهایی درخواست در پیغام\\
اگر بخواهیم هر کدام از اکتورهای دریافت کننده‌ی پیغام بتوانند پاسخ نهایی درخواست را ارسال کنند، باید نام اکتور گیرنده‌ی پاسخ نهایی در قالب پیغام قرار داده شوند.
\end{enumerate}
\end{itemize}
\item منطق پردازش پاسخ(ها)\\
در صورتی که در مدل همکاری انتخاب شده، اکتور فرستنده‌ی پیغام‌های مربوط به درخواست، موظف به گرفتن پاسخ از آنها باشد، در این مرحله منطق پردازش پاسخ‌ها طراحی گردد. این منطق ممکن است شامل ارسال پیغام‌های جدید، یا بروزرسانی متغیرهای حالت باشد و در ساده‌ترین حالت ممکن است ارسال همان پاسخ به اکتوری دیگر باشد.
\end{itemize}

\subsection{طراحی سایر اکتورها}
در صورتی که در طراحی منطق پردازش درخواست قبلی، اکتور مسئول پیغام پاسخ درخواست را بدون همکاری با سایر اکتورها ارسال کند، در این مرحله طراحی رخداد سیستمی مورد کاربرد انتخاب شده به اتمام می‌رسد و گام‌های طراحی برای رخداد سیستمی بعدی (یا مورد کاربرد بعدی) تکرار می‌شود. در غیر این صورت 
(در طراحی منطق پردازش درخواست، تصمیم به ارسال پیغام به سایر اکتورها گرفته شده باشد) طراحی اکتورهای گیرنده از گام ``منطق پردازش درخواست'' ادامه می‌یابد.




\section{الگوهای طراحی}
در این بخش تعدادی از الگوهایی که می‌توانند در طراحی به روش تبادل ناهمگام پیغام به کار گرفته شوند گردآوری و ارائه شده است. ذکر چند نکته‌ی مقدماتی در این بخش ضروری به نظر می‌رسد:
\begin{enumerate}


\item در ابتدا باید تأکید شود که هر چند که نکات این بخش تحت عنوان الگوی طراحی ارائه شده‌اند، اما به معنای دقیق کلمه از دیدگاه مهندسی نرم‌افزار، همردیف الگوهای طراحی (مشابه الگوهای طراحی شیءگرا\cite{GOF})  نیستند. دلیل این امر این است که اولاً الگوهای طراحی باید دارای نامگذاری دقیق و نظام‌مند باشند تا بتوان از آنها به عنوان زبان مشترکی بین طراحان و برنامه‌نویسان روش مورد بحث استفاده کرد. ثانیاً الگوهای طراحی در اثر تجربیات طراحی و پیاده‌سازی‌های متعدد و  ارزیابی‌های دقیق حاصل می‌شوند. این درحالی‌ است که اولاً این بخش از این پژوهش، اولین تلاش در راستای استخراج الگوهای طراحی در این روش است که در آن بیشتر تجربیات در اثر طراحی و پیاده‌سازی یک سیستم آزمایشی به دست آمده است و به همین دلیل احتمالاً از شمول و پختگی کافی برخوردار نیست و ثانیاً نام‌گذاری این الگوها فرایند حساسی‌ است که از حوزه‌ی این پژوهش خارج است. 
\item در بخش اول این فصل الگوهای طراحی منطق پردازش یک درخواست در اکتورها ارائه می‌شود. در اینجا منظور از درخواست، پیغامی است که آغاز کننده‌ی یک فعالیت در اکتور است.  همان طور که در بخش \ref{section:design_steps} ذکر شد، برای یک اکتور در قبال دریافت یک درخواست دو رویکرد می‌توان متصور بود: حالت اول این است که اکتور مورد نظر به تنهایی بتواند عملیات مربوط به درخواست را اجرا کند، و حالت دوم این است که نیاز به همکاری با سایر اکتورها داشته باشد. طبیعتاً طراحی حالت اول بسیار ساده بوده و نیازی به ارائه‌ی الگو برای آن وجود ندارد. بنابراین در این فصل الگوهایی بررسی می‌شوند که در آنها بیش از یک اکتور در پردازش یک درخواست درگیر باشند.
\item الگوهای ذکر شده ممکن است با الگوهای کلی طراحی همروند (مانند الگوی خط-لوله که در بخش \ref{section:actorPatterns} معرفی شد) در ارتباط باشند اما در این فصل بیشتر تأکید روی ارائه‌ی خواص الگوها و تناسب آنها با منطق دامنه است.
\item تقسیم‌بندی الگوها با این دیدگاه مسئولیت اکتور دریافت کننده‌ی درخواست در پردازش منطق صورت گرفته است. 
%TODO چرا این تقسیم بندی؟ در واقع دسته‌ی اول اونایی هستند که قطعا نیازی به همگام‌سازی و اینا ندارن
\end{enumerate}

\subsection{دسته‌ی اول}
دسته‌ی اول الگوهای طراحی، الگوهایی هستند که در آن اکتور دریافت کننده‌ی درخواست پس از ارسال پیغام‌های لازم مسئولیت دیگری در اجرای درخواست نخواهد داشت. شکل \ref{fig:Patterns_stateless} حالت کلی این الگوها را نشان می‌دهد.

\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=8cm]{4-ProposedFramework/Figures/Patterns_stateless.pdf}
    \end{center}
    \caption{\label{fig:Patterns_stateless}توصیف کلی الگوهایی که در آن اکتور دریافت کننده‌ی درخواست پس از ارسال پیغام(ها) مسئولیتی در پردازش درخواست ندارد.}
\end{figure*}

\subsubsection{الگوی ۱ (انتقال یا تحویل)}
در این حالت درخواست مربوطه صرفاً پیغامی‌ است که باید تحویل یکی از اکتورهایی شود که اکتور دریافت کننده‌ی درخواست به آن دسترسی دارد. این درخواست حالت اکتور دریافت کننده‌ی درخواست را عوض نمی‌کند ولی ممکن است حالت اکتور بعدی را عوض کند. 

\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=8cm]{4-ProposedFramework/Figures/Patterns_stateless_forward.pdf}
    \end{center}
    \caption{\label{fig:Patterns_stateless_forward}الگوی ۱ (انتقال یا تحویل)}
\end{figure*}


\subsubsection{الگوی ۲ (انتشار)}
این الگو مشابه الگوی قبل است با این تفاوت که پیغام برای تعداد بیشتری از اکتورهای در ارتباط با اکتور جاری ارسال می‌شود.
\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=8cm]{4-ProposedFramework/Figures/Patterns_stateless_broadcast.pdf}
    \end{center}
    \caption{\label{fig:Patterns_stateless_broadcast}الگوی ۲ (انتشار)}
\end{figure*}




\subsubsection{الگوی ۳ (وکالت)}
همان‌طور که در بخش \ref{design:delegate} توضیح داده شد، در کاربردهای زیادی اکتور دریافت کننده‌ی درخواست تصمیم می‌گیرد کل عملیات مربوط به اجرای یک درخواست را به اکتور دیگری منتقل کند. اکتور دریافت کننده‌ی درخواست اطلاعات لازم از جمله خود پیغام درخواست، فرستنده‌ی درخواست و متغیرهای حالت محلی و نیز دسترسی‌های لازم به سایر اکتورها را در اختیار اکتور جدید قرار می‌دهد. در این الگو یک اکتور جدید در سیستم شروع به کار می‌کند. در اکثر موارد عمر اکتور جدید محدود به پردازش درخواست است. در طراحی مورد کاربرد اخذ درس، پردازش پیغام درخواست اخذ درس مثالی از این الگو است (مراجعه کنید به بخش \ref{subsection:take_course_uc_design}).
\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=10cm]{4-ProposedFramework/Figures/Patterns_stateless_Delegate.pdf}
    \end{center}
    \caption{\label{fig:Patterns_stateless_delegate}الگوی ۳ (وکالت)}
\end{figure*}

\subsubsection{الگوی ۴}
در این الگو اکتور برای پردازش درخواست، نیاز به ارسال پیغامی دیگر به یکی از اکتورهای در ارتباط با اکتور جاری است. تفاوت این نوع درخواست با درخواستی که در الگوی ۱ معرفی شد این است که در الگوی ۱ درخواست متعلق به اکتوری بود که اکتور دریافت کننده‌ی درخواست به آن دسترسی داشت. بر خلاف الگوی ۱، در این الگو درخواست به اکتور دریافت کننده مربوط است اما این اکتور تمام اطلاعات لازم برای پردازش پیغام را در اختیار ندارد (یا پردازش فقط مربوط به اکتور اول نیست). شکل \ref{fig:Patterns_stateless_4} این الگو را نمایش می‌دهد. در این الگو، دریافت کننده‌ی پیغام، محاسبات مربوط به خود را انجام می‌دهد و اطلاعات لازم را در اختیار اکتور بعدی قرار می‌دهد. مثالی از این الگو، درخواست بررسی قبولی درس، در مورد کاربرد اخذ درس (بخش \ref{section:takeCourse}) است.
\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=10cm]{4-ProposedFramework/Figures/Patterns_stateless_4.pdf}
    \end{center}
    \caption{\label{fig:Patterns_stateless_4}الگوی ۴}
\end{figure*}






\subsection{دسته‌ی دوم}
دسته‌ی دوم الگوهای طراحی، الگوهایی هستند که در آن مسئولیت اکتور دریافت کننده‌ی درخواست، با ارسال‌ پیغام به سایر اکتورها پایان نمی‌پذیرد.

\subsubsection{الگوی ۵ (انشعاب و الحاق بدون ترتیب)}
توضیح:\\
در این الگو اکتور برای پردازش درخواست، نیاز به ارسال پیغام به چند اکتور دیگر دارد و بعد از دریافت پاسخ از این اکتورها می‌تواند پاسخ درخواست را ارسال کند. فرض بر این است که ترتیب فرستادن پیغام‌ها و ترتیب دریافت پاسخ‌ آنها اهمیت ندارد.
عملکرد (پیاده‌سازی):\\

اکتور با دریافت درخواست، پیغام‌هایی به همراه اطلاعات لازم برای اکتورهای مرتبط ارسال می‌کند. با توجه به اینکه ترتیب پاسخ‌ها اهمیتی ندارد، اکتور می‌تواند پاسخ‌ها را به هر ترتیبی پردازش کند. تعداد پاسخ‌های دریافت شده با یک متغیر محلی نگهداری می‌شود و با دریافت هر پاسخ، مقدار آن بروزرسانی می‌شود. علاوه بر این متغیر، سایر متغیرهای حالت سیستم نیز می‌توانند بروزرسانی شوند.
موارد استفاده:\\
این الگو در حالاتی از منطق برنامه به کار می‌رود که درخواست مربوط به چندین اکتور
\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=10cm]{4-ProposedFramework/Figures/Patterns_statelfull_fj.pdf}
    \end{center}
    \caption{\label{fig:Patterns_statefull_5}الگوی ۵}
\end{figure*}


\subsubsection{الگوی ۶ (انشعاب و الحاق با ترتیب)}
در این الگو اکتور برای پردازش درخواست، نیاز به ارسال پیغام به چند اکتور دیگر دارد و بعد از دریافت پاسخ از این اکتورها می‌تواند پاسخ درخواست را ارسال کند. در این الگو فرض بر این است که ترتیب فرستادن پیغام‌ها و ترتیب دریافت پاسخ‌ آنها اهمیت ندارد. بنابراین اکتور به این ترتیب عمل می‌کند:\\
با دریافت درخواست، پیغام‌هایی به همراه اطلاعات لازم برای اکتورهای مرتبط ارسال می‌کند
\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=10cm]{4-ProposedFramework/Figures/Patterns_statelfull_fj_sequenced_receive.pdf}
    \end{center}
    \caption{\label{fig:Patterns_statefull_6}الگوی ۶}
\end{figure*}


\subsubsection{الگوی ۷ (فراخوانی مرتب)}
در این الگو اکتور برای پردازش درخواست، نیاز به ارسال پیغام به چند اکتور دیگر دارد و بعد از دریافت پاسخ از این اکتورها می‌تواند پاسخ درخواست را ارسال کند. در این الگو فرض بر این است که ترتیب فرستادن پیغام‌ها و ترتیب دریافت پاسخ‌ آنها اهمیت ندارد. بنابراین اکتور به این ترتیب عمل می‌کند:\\
با دریافت درخواست، پیغام‌هایی به همراه اطلاعات لازم برای اکتورهای مرتبط ارسال می‌کند
\begin{figure*}[hb]
    \begin{center}
	\includegraphics[width=10cm]{4-ProposedFramework/Figures/Patterns_statelfull_rpc.pdf}
    \end{center}
    \caption{\label{fig:Patterns_statefull_7}الگوی ۷}
\end{figure*}




% نحوه‌ی تقسیم‌بندی موارد این بخش به این صورت است که ابتدا الگوهای  کلی همکاری اکتورها برای پیاده‌سازی منطق دامنه برشمرده شده‌اند و برای هر مورد سعی شده تأثیر منطق دامنه در انتخاب الگو و نیز در نحوه‌ی پیاده‌سازی جزئیات الگو در نظر گرفته شود. در ادامه الگوها و نکته‌های مهم در طراحی پیغام‌ها ارائه شده‌اند. نهایتا نکات و تجربیاتی که در زمینه‌ی طراحی به روش انتقال ناهمگام و تفاوت‌های مهم آن با طراحی شیءگرای ترتیبی ارائه شده است.
%\subsection{الگوهای همکاری اکتورها}
%\subsubsection{الگوی انشعاب و الحاق}
%
%\begin{itemize}
%\item\textbf{نحوه‌ی پیاده‌سازی به روش تبادل ناهمگام پیغام:}\\
%همان‌طور که از نام این الگو بر می‌آید پیاده‌سازی آن از دو بخش تشکیل شده است. برای عمل انشعاب یک اکتور به تعدادی اکتور دیگر که به آنها دسترسی دارد و یا خود آنها را ایجاد می‌کند پیغام‌هایی می‌فرستد. این اکتورها تمام عملیات لازم برای تهیه‌ی پاسخ را انجام داده و پیغام‌های پاسخ را برای اکتور اصلی ارسال می‌کنند. مرحله‌ی جمع‌آوری پیغام‌ها انشعاب نامیده می‌شود. اکتور اصلی این پیغام‌‌ها را دریافت کرده و محاسبات لازم را روی آنها انجام می‌دهد. و در پاسخ عملیات را به صورت پیغام ارسال می‌کند.‍ شکل \ref{fig:fork_and_join} شمایی از این الگو را نشان می‌دهد.
%\begin{figure*}
%    \begin{center}
%	\includegraphics[width=16cm]{3-RelatedWork/Figures/Divide_and_Conquer.pdf}
%    \end{center}
%    \caption{\label{fig:fork_and_join}  شمای کلی از الگوی انشعاب و الحاق در مدل اکتور }
%\end{figure*}
%
%\item\textbf{موارد استفاده}\\
%این الگو برای حالاتی از منطق دامنه به کار می‌رود که مسئله از نوع تقسیم و حل است (رجوع کنید به بخش \ref{section:actorPatterns}). مثالی از این کارکرد در مورد کاربرد محاسبه‌ی معدل (جدول \ref{table:uc_gpa}) در بخش قبل مورد بررسی قرار گرفته است. در این مثال، اکتوری که وظیفه‌ی محاسبه‌ی معدل را بر عهده دارد به اکتورهای سابقه‌ی تحصیلی دانشجو دسترسی دارد و برای محاسبه‌ی معدل نیاز به اطلاعاتی دارد که این اکتورها به آن دسترسی دارند. استفاده از الگوی انشعاب و الحاق در این مثال به این صورت است که اکتور محاسبه‌ی معدل پیغام‌های درخواست اطلاعات نمره را برای تمام اکتورهای سابقه ارسال می‌کند (انشعاب)، این اکتورها با برقراری ارتباط با سایر اکتورها موجب می‌شوند اطلاعات لازم به صورت پیغام‌هایی برای اکتور محاسبه‌ی معدل ارسال شود. اکتور محاسبه‌ی معدل با گرفتن پیغام‌ها (الحاق) عملیات مورد نیاز برای محاسبه‌ی معدل را انجام‌ می‌دهد و معدل را به صورت پیغام برای اکتور مقصد ارسال می‌کند.
%%موارد استفاده‌ی دیگری هم دارد.؟
%
%\item\textbf{نکات مهم}\\
%\begin{enumerate}
%\item مناسب بودن مسائل تقسیم و حل برای این الگو به این معنی نیست که نمی‌توان از روش دیگری این مسائل را حل کرد. به عنوان مثال، مورد کاربرد محاسبه‌ی معدل در رویکرد  اول طراحی که در بخش \ref{gpa_approach1} توضیح داده شد، بدون استفاده از این الگو طراحی گردید. همان‌طور که در مقایسه‌ی دو رویکرد مذکور بیان شد، تفاوت استفاده و عدم استفاده از الگوی انشعاب و الحاق صرفا کیفیت طراحی می‌باشد و از نظر صحت عملکرد دو الگو یکسان هستند. بنابراین استفاده از این الگو بیشتر به تمرین در طراحی نیازمند است و صرفاً از روی منطق دامنه قابل تشخیص نیست.
%\item مورد دیگر این است که در بسیاری از موارد، استفاده از این الگو به ذهن برنامه‌نویس این طور القا می‌کند که اکتورهایی که انشعاب شده‌اند موظف به فرستادن نتیجه به اکتور اصلی هستند. باید دقت شود که استفاده از این الگو مستقل از این مورد است که نتیجه‌ی کارهای تقسیم شده به چه شکلی به دست اکتور اصلی می‌رسد. همان‌طور که در رویکرد دوم طراحی مورد کاربرد محاسبه‌ی معدل مشاهده شد، پاسخ اکتور محاسبه‌ی معدل می‌تواند از سوی اکتور ترم و یا اکتور درس ارسال شود.
%\item استفاده از این الگو صرفا با کشف مورد استفاده به اتمام نمی‌رسد. پس از تصمیم به استفاده از این الگو، تصمیمات دیگری در پاسخ به سؤالاتی از این قبیل باید اتخاذ شود: آیا  اکتور جاری که منطق مطابق با الگو در آن کشف شده است باید به عنوان اکتوری که انشعاب در نظر گرفته شود یا اکتور دیگری به این منظور ایجاد شود؟ آیا اکتور الحاق و اکتور انشعاب یکسان باشند یا اکتور دیگری عمل انشعاب را انجام دهد؟ آیا نتیجه‌ی عملیات حاصل از الگو به اکتور جاری فرستاده شود یا مستقیماً به گیرنده‌ی دیگری ارسال شود؟ 
%\end{enumerate} 
%
%\end{itemize}
%
%\subsubsection{الگوی خط لوله}
%
%\begin{itemize}
%\item\textbf{نحوه‌ی پیاده‌سازی به روش تبادل ناهمگام پیغام:}\\
%پیاده‌سازی این الگو به این صورت است که هر اکتور بخشی از عملیات منطق دامنه‌ را انجام می‌دهد و با ارسال پیغام به اکتور بعدی ادامه‌ی کار را به آن می‌سپارد.
%\begin{figure*}
%    \begin{center}
%	\includegraphics[width=16cm]{3-RelatedWork/Figures/pipeline.pdf}
%    \end{center}
%    \caption{\label{fig:pipeline_2}  مثالی از الگوی خط لوله }
%\end{figure*}
%
%\item\textbf{موارد استفاده}\\
%این الگو در دو حالت مورد استفاده قرار می‌گیرد. حالت اول مواردی را شامل می‌شود که خود منطق دامنه نیاز به ترتیب دارد. در این حالت‌ها عملی که در هر مرحله انجام‌ می‌گیرد به صورت منطقی وابسته به نتیجه‌ی مرحله‌ی قبل است. حالت دوم زمانی اتفاق می‌افتد که منطق دامنه نیاز به ترتیب ندارد ولی دسترسی اکتورها به صورت زنجیره‌ای است. مثالی از این حالت،‌ در مورد کاربرد محاسبه‌ی معدل در بخش قبل دیده شد. در این مثال اکتور سابقه، نمره‌ی دانشجو را برای معدل فراهم می‌کند و اکتور درس تعداد واحد‌های درس مربوطه را. با اینکه این دو عمل مستقل از هم بوده و می‌توانند به صورت موازی اجرا شوند،‌ مدل دامنه‌ی سیستم ایجاب می‌کند که پیغام از طریق اکتور سابقه به اکتور ارائه منتقل شود و از طریق این اکتور به دست اکتور درس برسد.
%
%\item\textbf{نکات مهم}\\
%\begin{enumerate}
%\item مناسب بودن م\textsl{سائل تقسیم و حل} برای این الگو به این معنی نیست که نمی‌توان از روش دیگری این مسائل را حل کرد. به عنوان مثال، مورد کاربرد محاسبه‌ی معدل در رویکرد  اول طراحی که در بخش \ref{gpa_approach1} توضیح داده شد، بدون استفاده از این الگو طراحی گردید. همان‌طور که در مقایسه‌ی دو رویکرد مذکور بیان شد، تفاوت استفاده و عدم استفاده از الگوی انشعاب و الحاق صرفا کیفیت طراحی می‌باشد و از نظر صحت عملکرد دو الگو یکسان هستند. بنابراین استفاده از این الگو بیشتر به تمرین در طراحی نیازمند است و صرفاً از روی منطق دامنه قابل تشخیص نیست.
%\item مورد دیگر این است که در بسیاری از موارد، استفاده از این الگو به ذهن برنامه‌نویس این طور القا می‌کند که اکتورهایی که انشعاب شده‌اند موظف به فرستادن نتیجه به اکتور اصلی هستند. باید دقت شود که استفاده از این الگو مستقل از این مورد است که نتیجه‌ی کارهای تقسیم شده به چه شکلی به دست اکتور اصلی می‌رسد. همان‌طور که در رویکرد دوم طراحی مورد کاربرد محاسبه‌ی معدل مشاهده شد، پاسخ اکتور محاسبه‌ی معدل می‌تواند از سوی اکتور ترم و یا اکتور درس ارسال شود.
%\item استفاده از این الگو صرفا با کشف مورد استفاده به اتمام نمی‌رسد. پس از تصمیم به استفاده از این الگو، تصمیمات دیگری در پاسخ به سؤالاتی از این قبیل باید اتخاذ شود: آیا  اکتور جاری که منطق مطابق با الگو در آن کشف شده است باید به عنوان اکتوری که انشعاب در نظر گرفته شود یا اکتور دیگری به این منظور ایجاد شود؟ آیا اکتور الحاق و اکتور انشعاب یکسان باشند یا اکتور دیگری عمل انشعاب را انجام دهد؟ آیا نتیجه‌ی عملیات حاصل از الگو به اکتور جاری فرستاده شود یا مستقیماً به گیرنده‌ی دیگری ارسال شود؟ 
%\end{enumerate} 
%
%\end{itemize}
