در این فصل به ارائه‌ی برخی کارهای پیشین و مرتبط به موضوع این پژوهش خواهیم پرداخت. در مورد هر یک از این موارد به ارتباط آن با بحث جاری، کاربرد و یا نقاط تأثیرگذار آن در موضوع این پژوهش و هم‌چنین ضعف ها و نقایص آن‌ها پرداخته شده است. 
\section{الگوهای برنامه‌نویسی بازیگر}
\label{section:actorPatterns}
در برنامه‌نویسی همروند با بازیگر‌ها دو نوع الگوی کلی معرفی شده است \cite{Agha1990}: یکی  \textit{\gls{تقسیم-و-حل}}\LTRfootnote{devide and conquer} و دیگری \textit{\gls{خط لوله}}\LTRfootnote{pipeline}. 
در روش تقسیم-و-حل مسئله‌ی مورد بحث به زیربخش‌های کوچکتر و مستقل تقسیم می‌شود که هرکدام به صورت مستقل حل می‌شوند و نتایج هر زیربخش برای نتیجه‌گیری کلی ادغام می‌شوند. در برنامه‌نویسی به مدل بازیگر، برای پیاده‌سازی این الگو یک بازیگر رئیس\LTRfootnote{master} در نظر گرفته می‌شود که تعدادی بازیگر کارگر\LTRfootnote{worker} را برای حل زیربخش‌های مسئله ایجاد می‌کند. عمل تقسیم به وسیله‌ی فرستادن پیغام‌ حاوی حالت لازم برای حل زیر بخش به کارگر‌ها انجام می‌شود. کارگرها به نوبه‌ی خود منطق لازم برای حل زیر بخش را ایجاد نموده و نتیجه را به صورت پیغام دیگری برای بازیگر رئیس ارسال می‌کنند. نهایتا رئیس با ادغام نتایج جواب نهایی 
مسئله را تولید می‌کند. شایان ذکر است که فازهای تقسیم و حل لزوما توسط بازیگر یکسان اجرا نمی‌شوند. ممکن است اجرای فاز حل به بازیگر دیگری سپرده شود.\cite{Feng08scalablemodels}
مثال دیگری از پیاده‌سازی الگوی تقسیم-و-حل در مدل بازیگر  در \cite{Feng08scalablemodels} آمده است که در آن الگوریتم جستجوی سریع\LTRfootnote{quick sort} توسط این الگو پیاده شده است.
\begin{figure*}
    \begin{center}
	\includegraphics[width=16cm]{3-RelatedWork/Figures/Divide_and_Conquer.pdf}
    \end{center}
    \caption{\label{fig:divide_conquer}  شمای کلی از الگوی تقسیم-و-حل در مدل بازیگر }
\end{figure*}
شکل \ref{fig:divide_conquer} شمایی از نحوه‌ی پیاده‌سازی الگوی تقسیم-و-حل در مدل بازیگر را نمایش می‌دهد.\\
الگوی خط لوله برای حالت‌هایی مناسب است که فعالیت قابل تقسیم به بخش‌های افزایشی باشد. در این صورت هر بازیگر تغییرات مربوطه را در مدل ایجاد می‌کند و آن را به عنوان پیغام به بازیگر بعدی در خط لوله منتقل می‌کند.

\begin{figure*}
    \begin{center}
	\includegraphics[width=16cm]{3-RelatedWork/Figures/pipeline.pdf}
    \end{center}
    \caption{\label{fig:pipeline}  مثالی از الگوی خط لوله (پردازش تصویر) }
\end{figure*}
به عنوان مثالی از الگوی خط لوله یک برنامه‌ی پردازش تصویر را در نظر بگیرید. هر مرحله از خط لوله، تغییراتی را در تصویر دریافتی ایجاد می‌کند و تصویر نتیجه را به مرحله‌ی بعد منتقل می‌کند. در پیاده‌سازی با روش بازیگر، هر مرحله به صورت یک بازیگر مدل می‌شود و تصویر به صورت پیغام بین مراحل رد و بدل می‌شود. در شکل \ref{fig:pipeline} شمایی از این الگو نشان داده شده‌ است. \\
در پژوهش‌های انجام شده مشخص شد که الگوهای ارائه شده صرفا الگوهای کلی همروندی هستند و جزئیات این الگوها در طراحی منطق دامنه، نحوه‌ی طراحی پیغام‌ها بررسی نشده اند .

\section{ همگام‌سازی و هماهنگی بازیگرها }
\label{section:coordinationAndSyncronization}
همان‌طور که در بخش‌های قبل ذکر شد،  مدل بازیگر دارای خاصیت ناهمگامی‌ است و ترتیب پیغام‌هایی که یک بازیگر دریافت می‌کند وابسته به ترتیب فرستاده شدن پیغام‌ها نیست. نتیجه‌ی این خاصیت این است که تعداد ترتیب\LTRfootnote{ordering}‌های دریافت پیغام‌ها در مدل بازیگر نمایی است\cite{KarmaniAgha_Actors_11}. به دلیل اینکه فرستنده‌ی پیغام از حالت محلی بازیگر گیرنده اطلاعی ندارد، ممکن است بعضی از ترتیب‌های ذکر شده برای پیغام‌ها مطلوب نباشد. به عنوان مثال الگوریتمی را در نظر بگیرید که زیر بخش‌های مختلف آن به بازیگر‌هایی فرستاده شده و نتایج آن دریافت می‌شود ولی در آن ترتیب دریافت نتایج اهمیت داشته باشد.  نیاز به این نوع اولویت‌بندی‌ها در مدل بازیگر منجر به ایجاد پیچیدگی در محاسبات همروند می‌شود و در صورت پیاده‌سازی نامناسب باعث ایجاد ناکارامدی در برنامه‌ها می‌شود. راه حل این مسئله در مدل اکتور همگام‌سازی است. در مدل بازیگر، بازیگر‌ها برای همگام‌سازی باهم ارتباط برقرار می‌کنند. در این قسمت دو نوع الگوی هماهنگی بازیگر‌ها را معرفی می‌کنیم: تبادل پیغام شبه آرپی‌سی (فراخوانی رویه راه دور)\LTRfootnote{Remote Procedure Call} و قیود همگام‌سازی محلی \LTRfootnote{Local Synchronization Constraints}. \cite{Agha1990,Agha93abstractionand,Papaioannou,KarmaniAgha_Actors_11} 
\subsection{تبادل پیغام شبه-آرپی‌سی}
در ارتباط شبه‌-آرپی‌سی، فرستنده‌ پس از ارسال پیغام منتظر گرفتن پیغام پاسخ از طرف گیرنده می‌ماند. رفتار بازیگر در این مدل به ترتیب زیر است:
\begin{enumerate}
\item بازیگر فرستنده درخواست را در قالب یک پیغام به بازیگر گیرنده ارسال می‌کند.
\item سپس فرستنده صندوق پیغام‌ها را بررسی می‌کند.   
\item اگر پیغام بعدی پاسخ درخواست ارسال شده باشد اقدام مناسب صورت می‌گیرد و فعالیت بازیگر ادامه پیدا می‌کند.
\item اگر پیغام بعدی پاسخ درخواست ارسال شده نباشد پیغام جاری در صورت امکان (بسته به منطق برنامه) پردازش می‌شود و در غیر این صورت برای پردازش در آینده به صندوق پیغام‌ها برگردانده می‌شود.
\end{enumerate}
شکل \ref{fig:rpc} مثالی از  پیاده‌سازی ارتباط شبه-آرپی‌سی در مدل بازیگر را نشان می‌دهد. ارتباط شبه-آرسی‌پی در دو نوع سناریوی خاص مفید و ضروری است: یک سناریو این است که بازیگر نیاز به ارسال پیغام به صورت ترتیبی به یک یا چند بازیگر خاص دارد و تا حاصل شدن اطمینان از رسیدن پیغام قبلی پیغام بعد را ارسال نمی‌کند. سناریوی دوم این است که حالت\LTRfootnote{state} بازیگر فرستنده بستگی به محتوای پاسخ دارد. در این حالت بازیگر قبل از دریافت پاسخ مورد نظر، نمی‌تواند پیغام‌های بعدی را به درستی پردازش کند. نکته‌ی قابل توجه این است که با توجه به شباهت ارسال پیغام شبه-آرپی‌سی به فراخوانی رویه\LTRfootnote{procedure}‌ها در زبان‌های \gls{ترتیبی}\LTRfootnote{sequential}، معمولا برنامه‌نویسان گرایش به استفاده‌ی بیش از حد از این نوع تبادل پیغام دارند که این ممکن است با ایجاد وابستگی‌های بی‌مورد در اشیاء برنامه، علاوه بر کاهش کارایی، منجر به ایجاد \gls{بن‌باز}\LTRfootnote{live lock} در برنامه شود (حالتی که یک بازیگر به علت انتظار برای پاسخی که هرگز دریافت نخواهد کرد، از پیغام‌های جدید مرتباً چشم‌پوشی می‌کند یا پردازش آنها را به تأخیر می‌اندازد).\\
امکان تبادل پیغام شبه-آرپی‌سی تقریبا در تمامی پیاده‌سازی‌های مدل بازیگر به صورت امکانات سطح زبان وجود دارد\cite{ActorsJVM2009}.

\begin{figure*}
    \begin{center}
	\includegraphics[width=10cm]{3-RelatedWork/Figures/RPC.pdf}
    \end{center}
    \caption{\label{fig:rpc} مثالی از ارتباط شبه-آرپی‌سی در بازیگرها) }
\end{figure*}
 
\subsection{قیود همگام‌سازی محلی}
استفاده از قیود همگام‌سازی محلی روشی برای اولیت‌بندی پردازش پیغام‌ها در مدل بازیگر است\cite{FrolundCoord}. برای توضیح مفهوم همگام‌سازی محلی مثالی در شکل \ref{fig:lsc} ارائه شده است. در این مثال بازیگر فایل پس از دریافت پیغام باز کردن فایل\LTRfootnote{open}، با استفاده از قیود همگام‌سازی خود را محدود به پردازش پیغام‌های \textit{بستن} , \textit{خواندن} می‌کند. در صورت عدم وجود امکانات مناسب برای قیود همگام‌سازی، برنامه‌نویس ناگزیر خواهد بود تا در میان منطق اجرای پیغام‌ها، میانگیر صندوق پیغام‌ها را بررسی و ترکیب یا ترتیب آنها را تغییر داده و یا با جستجو در آنها پیغام مناسب را انتخاب کند. این امر موجب مخلوط شدن منطق چگونگی پردازش پیغام  (چگونه) با منطق زمانی انتخاب پیغام (چه زمانی) می‌شود که در اصول نرم‌افزار پدیده‌ی نامطلوبی به حساب می‌آید\cite{KarmaniAgha_Actors_11}. به همین دلیل بسیاری از زبان‌ها و چارچوب‌های مبتنی بر بازیگر امکانات مناسبی برای پشتیبانی از قیود‌ همگام‌سازی محلی ارائه داده‌اند. به عنوان مثال در کتابخانه‌ی بازیگر اسکالا که در بخش \ref{section:scalaActorLib} معرفی شد، از مکانیزم تطابق الگو\LTRfootnote{pattern matching} برای اولیت بندی پردازش پیغام‌ها بدون اینکه با منطق اجرایی برنامه مخلوط گردد استفاده می‌شود.



\begin{figure*}
    \begin{center}
	\includegraphics[width=10cm]{3-RelatedWork/Figures/LSC.pdf}
    \end{center}
    \caption{\label{fig:lsc} مثالی از قیود همگام‌سازی محلی. بازیگر فایل به وسیله‌ی قیود همگام‌سازی محدود شده است. فلش عمودی به معنی ترتیب زمانی و برچسب‌های داخل دایره به معنی پیغام‌های قابل پردازش در هر حالت هستند. ) }
\end{figure*}
